<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeeWay</title>
  
  <subtitle>李海云</subtitle>
  <link href="https://leeway2zc.top/atom.xml" rel="self"/>
  
  <link href="https://leeway2zc.top/"/>
  <updated>2025-08-11T09:07:56.538Z</updated>
  <id>https://leeway2zc.top/</id>
  
  <author>
    <name>David Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux内核实验笔记</title>
    <link href="https://leeway2zc.top/2025/08/11/Linux%E5%86%85%E6%A0%B8%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    <id>https://leeway2zc.top/2025/08/11/Linux%E5%86%85%E6%A0%B8%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</id>
    <published>2025-08-11T17:04:55.000Z</published>
    <updated>2025-08-11T09:07:56.538Z</updated>
    
    <content type="html"><![CDATA[<h1><center>OS2 内核编程和驱动程序开发实验</center></h1><blockquote><p>基于布加勒斯特理工大学自动控制与计算机学院计算机科学与工程系的 “操作系统2” 课程</p></blockquote><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h3><ul><li>主机：在win10上使用oracle virtualbox创建的 ubuntu 20.04 作为上位机，用于编辑模块源代码、编译模块、将模块应用到操作系统上等</li><li>虚拟机：通过Docker配置虚拟机模拟OS内核，在ubuntu 20.04上直接使用，通过脚本运行完成内核模块代码测试</li></ul><h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><blockquote><p>若提示用户没有sudo权限，使用<code>su -</code>切换到 root 用户即可，密码是虚拟机设置镜像时自己设置的，一般就是开机密码</p></blockquote><ol><li><p>在ubuntu 20.04中安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加 Docker 官方 GPG 密钥</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \</span><br><span class="line">    <span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加 Docker 软件源</span></span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> \</span></span><br><span class="line"><span class="string">  signed-by=/etc/apt/keyrings/docker.gpg] \</span></span><br><span class="line"><span class="string">  https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | \</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 更新 apt 并安装 Docker</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 启动并设置开机启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure></li><li><p>在ubuntu 20.04中安装必需软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y flex bison build-essential gcc-multilib libncurses5-dev \</span><br><span class="line">qemu-system-x86 qemu-system-arm python3 minicom</span><br></pre></td></tr></table></figure></li><li><p>创建一个脚本文件并编辑如下内容，随后运行脚本</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ $(<span class="built_in">id</span> -u) != <span class="string">&quot;0&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Please run as root (or use sudo)&quot;</span></span><br><span class="line">   <span class="built_in">exit</span> 1 </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#================================= CONSTANTS =================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"></span><br><span class="line">RED=<span class="string">&#x27;\033[0;31m&#x27;</span></span><br><span class="line">NC=<span class="string">&#x27;\033[0m&#x27;</span></span><br><span class="line"></span><br><span class="line">DEFAULT_IMAGE_NAME=<span class="string">&quot;so2/so2-assignments&quot;</span></span><br><span class="line">DEFAULT_TAG=<span class="string">&#x27;latest&#x27;</span></span><br><span class="line">DEFAULT_REGISTRY=<span class="string">&#x27;gitlab.cs.pub.ro:5050&#x27;</span></span><br><span class="line">SO2_WORKSPACE=<span class="string">&quot;/linux/tools/labs&quot;</span></span><br><span class="line">SO2_VOLUME=<span class="string">&quot;SO2_DOCKER_VOLUME&quot;</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#=================================== UTILS ===================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">LOG_INFO</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[<span class="subst">$(date +%FT%T)</span>] [INFO] <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">LOG_FATAL</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[<span class="subst">$(date +%FT%T)</span>] [<span class="variable">$&#123;RED&#125;</span>FATAL<span class="variable">$&#123;NC&#125;</span>] <span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print_help</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;local.sh docker interactive [--privileged]&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;      --privileged - run a privileged container. This allows the use of KVM (if available)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;      --allow-gui - run the docker such that it can open GUI apps&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">docker_interactive</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> full_image_name=<span class="string">&quot;<span class="variable">$&#123;DEFAULT_REGISTRY&#125;</span>/<span class="variable">$&#123;DEFAULT_IMAGE_NAME&#125;</span>:<span class="variable">$&#123;DEFAULT_TAG&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">local</span> executable=<span class="string">&quot;/bin/bash&quot;</span></span><br><span class="line">    <span class="built_in">local</span> registry=<span class="variable">$&#123;DEFAULT_REGISTRY&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> [[ <span class="variable">$#</span> -gt 0 ]]; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        --privileged)</span><br><span class="line">            privileged=--privileged</span><br><span class="line">            ;;</span><br><span class="line">        --allow-gui)</span><br><span class="line">            allow_gui=<span class="literal">true</span></span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            print_help</span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ $(docker images -q <span class="variable">$full_image_name</span> 2&gt; /dev/null) == <span class="string">&quot;&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        docker pull <span class="variable">$full_image_name</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ! docker volume inspect <span class="variable">$SO2_VOLUME</span> &gt;/dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Volume <span class="variable">$SO2_VOLUME</span> does not exist.&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Creating it&quot;</span></span><br><span class="line">docker volume create <span class="variable">$SO2_VOLUME</span></span><br><span class="line"><span class="built_in">local</span> vol_mount=$(docker inspect <span class="variable">$SO2_VOLUME</span> | grep -i mountpoin | <span class="built_in">cut</span> -d : -f2 | <span class="built_in">cut</span> -d, -f1)</span><br><span class="line"><span class="built_in">chmod</span> 777 -R <span class="variable">$vol_mount</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The /linux directory is made persistent within the <span class="variable">$SO2_VOLUME</span>:&quot;</span></span><br><span class="line">    docker inspect <span class="variable">$SO2_VOLUME</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$allow_gui</span>; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO: remove this after you change sdl to gtk in qemu-runqemu.sh</span></span><br><span class="line"> docker run <span class="variable">$privileged</span> --<span class="built_in">rm</span> -it --cap-add=NET_ADMIN --device /dev/net/tun:/dev/net/tun \</span><br><span class="line">        -v <span class="variable">$SO2_VOLUME</span>:/linux \</span><br><span class="line">        --workdir <span class="string">&quot;<span class="variable">$SO2_WORKSPACE</span>&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$full_image_name</span>&quot;</span> sed <span class="string">&quot;s+\$&#123;QEMU_DISPLAY:-\&quot;sdl\&quot;+\$&#123;QEMU_DISPLAY:-\&quot;gtk\&quot;+g&quot;</span> -i /linux/tools/labs/qemu/run-qemu.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># wsl</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cat</span> /proc/version | grep -i microsoft &amp;&gt; /dev/null ; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">export</span> DISPLAY=<span class="string">&quot;<span class="subst">$(ip r show default | awk &#x27;&#123;print $3&#125;&#x27;)</span>:0.0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$DISPLAY</span> == <span class="string">&quot;&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Error: Something unexpected happend. The environment var DISPLAY is not set. Consider setting it with&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\texport DISPLAY=&lt;dispaly&gt;&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> xauth_var=$(<span class="built_in">echo</span> $(xauth info | grep Auth | <span class="built_in">cut</span> -d: -f2))</span><br><span class="line">        docker run --privileged --<span class="built_in">rm</span> -it \</span><br><span class="line">        --net=host --<span class="built_in">env</span>=<span class="string">&quot;DISPLAY&quot;</span> --volume=<span class="string">&quot;<span class="variable">$&#123;xauth_var&#125;</span>:/root/.Xauthority:rw&quot;</span> \</span><br><span class="line">        -v <span class="variable">$SO2_VOLUME</span>:/linux \</span><br><span class="line">        --workdir <span class="string">&quot;<span class="variable">$SO2_WORKSPACE</span>&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$full_image_name</span>&quot;</span> <span class="string">&quot;<span class="variable">$executable</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        docker run <span class="variable">$privileged</span> --<span class="built_in">rm</span> -it --cap-add=NET_ADMIN --device /dev/net/tun:/dev/net/tun \</span><br><span class="line">        -v <span class="variable">$SO2_VOLUME</span>:/linux \</span><br><span class="line">        --workdir <span class="string">&quot;<span class="variable">$SO2_WORKSPACE</span>&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$full_image_name</span>&quot;</span> <span class="string">&quot;<span class="variable">$executable</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">docker_main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;interactive&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">        docker_interactive <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;docker&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    docker_main <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;-h&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;--help&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    print_help</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    print_help</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在终端运行脚本</span></span><br><span class="line"><span class="built_in">sudo</span> bash ./local.sh docker interactive --privileged</span><br></pre></td></tr></table></figure><blockquote><p>显示如下内容时说明配置成功</p></blockquote><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250804165404202.png" alt="image-20250804165404202" style="zoom:67%;" /><ol start="4"><li><p>此时根目录下会出现一个目录&#x2F;linux，这是docker虚拟挂载出来的，只有执行脚本时才会出现这个目录。&#x2F;linux&#x2F;tools&#x2F;lab是这个docker容器的工作目录，是我们编译模块和启动虚拟机的地方。</p></li><li><p>需要两个Docker内部的终端，通过tmux(终端复用器)可以得到分离的两个终端，输入指令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$tmux</span></span><br></pre></td></tr></table></figure><p>使用ctrl+b然后shift+”可以得到水平分割的两个终端，如下所示</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/docker_tmux_VM.png" style="zoom:67%;" /><blockquote><p>使用ctrl+b然后shift+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>可以得到垂直分割的两个终端，但是不方便复制代码</mtext></mrow><annotation encoding="application/x-tex">可以得到垂直分割的两个终端，但是不方便复制代码</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">可以得到垂直分割的两个终端，但是不方便复制代码</span></span></span></span>   &gt; 使用ctrl+b然后按下 [ 可以自由浏览终端界面，方便复制粘贴代码<br>使用ctrl+b然后按下 d 可以推出tmux，但这会杀死所有tmux正在执行的进程</p></blockquote></li><li><p>配置好环境以后就可以进行试验了，将上面的窗格作为虚拟机OS2，下面的窗格作为主机Docker容器，在上面的窗格中执行以下命令即可生成骨架，开始实验</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ LABS=&lt;实验名称&gt; make skels</span><br></pre></td></tr></table></figure></li><li><p>接下来要启动虚拟机，执行 <code>make console</code> 使用 <code>root</code> 用户名登陆</p></li><li><p>我们的工作流程包括：在Docker内编写模块代码，修改Make|Kbuild文件，执行make build编译得到ko模块，然后在虚拟机中通过 <code>insmod</code> 命令将其插入到虚拟机，或者通过 <code>rmmod</code> 将其移除。</p><blockquote><p>每次构建模块无需重启虚拟机，停止虚拟机的操作是 ctrl+a，然后按下 q</p></blockquote></li></ol><h2 id="一-内核模块"><a href="#一-内核模块" class="headerlink" title="一 内核模块"></a>一 内核模块</h2><h3 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h3><ul><li>创建简单的模块</li><li>描述内核模块编译的过程</li><li>展示如何在内核中使用模块</li><li>简单的内核调试方法</li></ul><h3 id="1-内核模块的使用-加载-卸载"><a href="#1-内核模块的使用-加载-卸载" class="headerlink" title="1 内核模块的使用|加载|卸载"></a>1 内核模块的使用|加载|卸载</h3><blockquote><p>使用 make console 启动虚拟机，并完成以下任务 (正确启动虚拟机以及上位机应该是下面这个界面)</p></blockquote><ol><li>使用<code>ctrl+alt+t</code>打开一个终端，确保pwd下有文件<code>local.sh</code>，使用以下代码进入docker容器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash ./local.sh docker interactive --privileged</span><br></pre></td></tr></table></figure><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/%E4%B8%8A%E4%BD%8D%E6%9C%BA.png"  /><ol start="2"><li>在docker容器中构建骨架，编写模块代码，编译模块，然后启动虚拟机安装测试模块</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在docker容器中构建骨架，在里面编写代码</span></span><br><span class="line"><span class="comment"># 实验名称一般是skel目录下的目录路径如LABS=&quot;kernel_modules/6-cmd-mod kernel_modules/8-kprobes&quot;</span></span><br><span class="line">LABS=&lt;实验名称&gt; make skels</span><br><span class="line"><span class="comment"># 编写完成后，修改Make和Kbuild文件，使用 make build 编译得到 .ko 模块文件，就可以测试了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用tmux分离出一个终端，使用make console启动虚拟机</span></span><br><span class="line">make console <span class="comment">#使用root用户名login，效果如下，此时主机名为qemu</span></span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/xv6%E8%99%9A%E6%8B%9F%E6%9C%BA.png"></p><ul><li>加载内核模块<ol><li>在 <code>~/skels/kernel_modules</code> 目录下有很多模块目录，里面存放要完成的任务</li></ol></li></ul><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806091936889.png" alt="image-20250806091936889"></p><p>​          2. 在 <code>1-2-test-mod</code> 这个目录下，执行命令 <code>insmod hello_mod.ko</code> 完成模块加载</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806092135698.png" alt="image-20250806092135698"></p><ul><li><p>列出内核模块并检查当前模块是否存在</p><ol><li><p>使用指令 <code>lsmod</code>  查看模块是否加载成功</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806092445847.png" alt="image-20250806092445847" style="zoom:67%;" /></li></ol></li><li><p>卸载内核模块</p><ol><li>使用指令 <code>rmmod hello_mod</code> (不需要后缀) 完成模块卸载</li></ol></li><li><p>使用 <strong>dmesg</strong> 命令查看加载&#x2F;卸载内核模块时显示的消息</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806092748489.png" alt="image-20250806092748489"></p></li></ul><h3 id="2-Printk"><a href="#2-Printk" class="headerlink" title="2 Printk"></a>2 Printk</h3><blockquote><p>配置系统，使消息不直接显示在串行控制台上，只能使用 <code>dmesg</code> 命令来查看</p></blockquote><ul><li><p>使用命令 <code>echo &quot;4 4 1 7&quot; &gt; /proc/sys/kernel/printk</code> 修改打印日志行为设置</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806093723057.png" alt="image-20250806093723057"></p></li><li><p>此时再加载模块就不会显示消息在串行控制台上了</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806094004426.png" alt="image-20250806094004426"></p></li></ul><h3 id="3-错误"><a href="#3-错误" class="headerlink" title="3 错误"></a>3 错误</h3><blockquote><p>生成名为 <strong>3-error-mod</strong> 的任务的框架。编译源代码并得到相应的内核模块。</p><p>为什么会出现编译错误? <strong>提示:</strong> 这个模块与前一个模块有什么不同？</p><p>修改该模块以解决这些错误的原因，然后编译和测试该模块。</p></blockquote><ul><li><p>根据TODO提示，缺少头文件 <code>&lt;linux/module.h&gt;</code>，添加后能编译成功</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806104845849.png" alt="image-20250806104845849"></p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806104917752.png" alt="image-20250806104917752"></p></li></ul><h3 id="4-子模块"><a href="#4-子模块" class="headerlink" title="4 子模块"></a>4 子模块</h3><blockquote><p>查看 <code>4-multi-mod/</code> 目录中的 C 源代码文件 <code>mod1.c</code> 和 <code>mod2.c</code>。模块 2 仅包含模块 1 使用的函数的定义。</p><p>修改 <code>Kbuild</code> 文件，从这两个 C 源文件创建 <code>multi_mod.ko</code> 模块。</p><p>编译、复制、启动虚拟机、加载和卸载内核模块。确保消息在控制台上正确显示。</p></blockquote><ol><li><p>使用 <code>LABS=&quot;kernel_modules/4-multi-mod&quot; make skels</code> 构建骨架</p></li><li><p>在目录 <code>root@ubuntu20:/linux/tools/labs/skels/kernel_modules/4-multi-mod</code> 中修改Kbuild文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> add rules to create a multi object module</span></span><br><span class="line">obj-m = multi-mod.o</span><br><span class="line">multi-mod-y = mod1.o mod2.o</span><br></pre></td></tr></table></figure></li><li><p>然后 <code>cd /linux/tools/labs</code> 进行编译 <code>make build</code></p></li><li><p>启动虚拟机，加载和卸载 <code>multi-mod.ko</code> 模块</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806161240091.png" alt="image-20250806161240091" style="zoom:67%;" /></li></ol><h3 id="5-内核-oops"><a href="#5-内核-oops" class="headerlink" title="5 内核 oops"></a>5 内核 oops</h3><blockquote><p>学习当内核模块代码有问题导致模块插入后内核发生了错误应该怎么处理</p></blockquote><ol><li><p>使用 <code>LABS=&quot;kernel_modules/5-oops-mod&quot; make skels</code>  构建骨架</p></li><li><p>在 <code>root@ubuntu20:/linux/tools/labs/skels/kernel_modules/5-oops-mod</code> 中修改Kbuild文件，为Kbuild文件添加编译标记，使得之后在安装模块时，会出现编译过程信息，提示哪里出现了问题</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> add flags to generate debug information</span></span><br><span class="line">ccflags-y += -g</span><br><span class="line"></span><br><span class="line">obj-m = oops_mod.o</span><br></pre></td></tr></table></figure></li><li><p><code>make build</code> 进行编译，然后在虚拟机中安装模块 <code>insmod oops_mod.ko</code> 会输出很长一段编译信息，其中最重要的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 告诉我们错误的原因</span><br><span class="line">BUG: kernel NULL pointer dereference, address: 00000000</span><br><span class="line"># 告诉我们这是第一个 oops（#1）</span><br><span class="line">Oops: 0002 [#1] SMP</span><br><span class="line"># 造成错误的指令的地址，它解码了指令指针 (EIP) 的值，并指出错误出现在 my_oops_init 函数中，偏移为 d个字节</span><br><span class="line">EIP: my_oops_init+0xd/0x22 [oops_mod]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oops 代码（0002）提供了有关错误类型的信息（参见 arch/x86/include/asm/trap_pf.h ）：</span><br><span class="line"></span><br><span class="line">第 0 位 == 0 表示找不到页面，1 表示保护故障</span><br><span class="line">第 1 位 == 0 表示读取，1 表示写入</span><br><span class="line">第 2 位 == 0 表示内核模式，1 表示用户模式</span><br></pre></td></tr></table></figure></li><li><p>有了 EIP 值就可以使用 address2line 来找到出错的代码出现的位置，在主机中使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addr2line -e oops_mod.ko +0xd</span><br><span class="line">/linux/tools/labs/skels/./kernel_modules/5-oops-mod/oops_mod.c:15</span><br></pre></td></tr></table></figure><p>可以知道是 oops_mod.c 的第 15 行出现了问题</p></li><li><p>由于oops_mod.ko模块加载卡住了，所以无法正常卸载，因此要重启虚拟机才能完成卸载</p><blockquote><p>模块加载必须经过init函数以及注册exit函数</p></blockquote></li><li><p>重启虚拟机之后，删去第15行代码，重新编译以及插入模块即可完成模块的加载与卸载</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250807083857615.png" alt="image-20250807083857615" style="zoom:67%;" /></li></ol><h3 id="6-模块参数"><a href="#6-模块参数" class="headerlink" title="6 模块参数"></a>6 模块参数</h3><blockquote><p>在不修改源代码 <code>cmd_mod.c</code> 的情况下，加载内核模块以显示消息 <code>Early bird gets tired</code></p></blockquote><ul><li><p>通过命令行传递参数可以修改函数变量的值从而输出特定内容</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250807090120386.png" alt="image-20250807090120386" style="zoom: 80%;" /></li><li><p>使用命令行传递参数需要源代码满足以下条件</p><ol><li><p>变量必须是模块级别的全局变量，不能是函数内部变量，必须像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *str = <span class="string">&quot;default&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>module_param()</code> 宏声明该变量为模块参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">str：变量名</span></span><br><span class="line"><span class="comment">charp：变量类型（支持 int、charp、bool、ulong 等）</span></span><br><span class="line"><span class="comment">0：权限标志位（sysfs 中的访问权限）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">module_param(str, charp, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>模块必须使用标准 <code>init</code> &#x2F; <code>exit</code> 入口函数机制，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span> &#123; ... &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span> &#123; ... &#125;</span><br><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_exit);</span><br><span class="line"># 这样，内核在执行 insmod 时会先处理模块参数，再调用 init 函数。</span><br></pre></td></tr></table></figure></li><li><p>模块参数变量声明前不能加 <code>const</code> 因为内核需要在运行时修改它</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// ❌ 无法作为 module_param</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="7-进程信息"><a href="#7-进程信息" class="headerlink" title="7 进程信息"></a>7 进程信息</h3><blockquote><p>检查名为 <strong>7-list-proc</strong> 的任务的框架。添加代码来显示当前进程的进程 ID（ <code>PID</code> ）和可执行文件名</p></blockquote><ol><li><p>执行 <code>root@ubuntu20:/linux/tools/labs/skels/kernel_modules/7-list-proc# vim list_proc.c</code> 命令，修改 <code>list_proc.c</code> 文件源代码</p></li><li><p>在注释TO DO处添加如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> add missing headers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched/signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/* TODO/2: print current process pid and its name */</span></span><br><span class="line">pr_info(<span class="string">&quot;Current process: pid = %d; comm = %s\n&quot;</span>,</span><br><span class="line">        current-&gt;pid, current-&gt;comm);</span><br><span class="line"><span class="comment">/* TODO/3: print the pid and name of all processes */</span></span><br><span class="line">pr_info(<span class="string">&quot;\nProcess list:\n\n&quot;</span>);</span><br><span class="line">for_each_process(p)</span><br><span class="line">        pr_info(<span class="string">&quot;pid = %d; comm = %s\n&quot;</span>, p-&gt;pid, p-&gt;comm);</span><br><span class="line"><span class="comment">/* TODO/2: print current process pid and name */</span></span><br><span class="line">pr_info(<span class="string">&quot;Current process: pid = %d; comm = %s\n&quot;</span>,</span><br><span class="line">        current-&gt;pid, current-&gt;comm);</span><br></pre></td></tr></table></figure></li><li><p>编译执行得到如下输出</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250807100210962.png" alt="image-20250807100210962" style="zoom:67%;" /></li><li><p>这里得查很多资料才能知道这些代码是什么意思</p></li></ol><h3 id="8-KDB"><a href="#8-KDB" class="headerlink" title="8 KDB"></a>8 KDB</h3><blockquote><p>使用KDB(Kernel Debugger)分析堆栈找出错误代码位置|使用KDB找到模块加载的地址|在一个新窗口中使用 GDB 并根据 KDB 提供的信息查看代码(没解决)</p></blockquote><ol><li><p>在虚拟机中配置KDB使用hvc0串口 <code>echo hvc0 &gt; /sys/module/kgdboc/parameters/kgdboc</code></p></li><li><p>使用 SysRq 命令启用 KDB (<strong>Ctrl + O g</strong>)，此时进入KDB调试命令行，输入Help可查看可用KDB命令，如果出现乱码例如文字显示不出来，很多乱码挤在界面右侧，是因为minicom的换行格式有问题，按下 ctrl + A 然后按下 U(或者L)，这样会将minicom从列显示模式切换到行显示模式，此时输出即可恢复正常</p><blockquote><p> kdb&gt; “这里输入go可以继续执行内核跳出kdb调试，按回车是重新输入并执行上一个命令，按↑是显示上一个命令”</p></blockquote></li><li><p>加载 <code>hello_kdb</code> 模块。该模块在写入 <code>/proc/hello_kdb_bug</code> 文件时会模拟一个错误。使用以下命令模拟错误：<code>echo 1 &gt; /proc/hello_kdb_bug</code></p></li><li><p>运行这个命令就会发生oops错误，然后会进入KDB调试命令行，使用 <code>[0]kdb&gt; bt</code> 即可分析堆栈跟踪并确定导致错误的代码，bt输出的最下面是执行的起始处(堆栈跟踪要从后往前看)，有些行前面的 ? 是指KDB不确定这个地址偏移是否计算正确，bt输出中最重要的就是kgbd_panic、kgdb_breakpoint这两个点，这表明有函数执行之后发生了错误，可以看到kgbd_panic下面的函数是panic，panic下面的函数是dummy_func1并指明它是 hello_kdb.c文件中的函数，所以错误代码就是 hello_kdb.c 中的函数 dummy_func1 有问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">notify_die+0x4d/0x90</span><br><span class="line">exc_int3+0x5c/0x140</span><br><span class="line">handle_exception+0x140/0x140</span><br><span class="line">EIP: kgdb_breakpoint+0xe/0x20                                                         </span><br><span class="line">Code: b4 26 00 00 00 00 8d b6 00 00 00 00 31 c0 c3 8d b4 26 00 00 00 00 8d b6 00 00 00 00 3e ff8</span><br><span class="line">EAX: 0000001e EBX: c40b9e00 ECX: 00000000 EDX: 00000000</span><br><span class="line">ESI: c180e898 EDI: c1badb40 EBP: c4519e2c ESP: c4519e20                               </span><br><span class="line">DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068 EFLAGS: 00000002                         </span><br><span class="line">? exc_general_protection+0x2c0/0x2c0                                                 </span><br><span class="line">? kgdb_breakpoint+0xe/0x20                                                           </span><br><span class="line">? kgdb_panic+0x4d/0x60                                                               </span><br><span class="line">panic+0xbc/0x266                                                                     </span><br><span class="line">? dummy_func1+0x8/0x8 [hello_kdb]                                                     </span><br><span class="line">dummy_func18+0xd/0xd [hello_kdb]                                                     </span><br><span class="line">dummy_func17+0x8/0x8 [hello_kdb] </span><br></pre></td></tr></table></figure></li><li><p>使用 <code>[0]kdb&gt; lsmod</code> 可以看到模块的加载地址</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250808170413340.png" alt="image-20250808170413340"></p></li></ol><h3 id="9-PS模块"><a href="#9-PS模块" class="headerlink" title="9 PS模块"></a>9 PS模块</h3><h3 id="10-内存信息"><a href="#10-内存信息" class="headerlink" title="10 内存信息"></a>10 内存信息</h3><h3 id="11-动态调试"><a href="#11-动态调试" class="headerlink" title="11 动态调试"></a>11 动态调试</h3><h3 id="12-初始化期间的动态调试"><a href="#12-初始化期间的动态调试" class="headerlink" title="12 初始化期间的动态调试"></a>12 初始化期间的动态调试</h3><h2 id="二-内核-API"><a href="#二-内核-API" class="headerlink" title="二 内核 API"></a>二 内核 API</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;OS2 内核编程和驱动程序开发实验&lt;/center&gt;&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;基于布加勒斯特理工大学自动控制与计算机学院计算机科学与工程系的 “操作系统2” 课程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;环境配置&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="内核教程" scheme="https://leeway2zc.top/categories/%E5%86%85%E6%A0%B8%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="内核教程" scheme="https://leeway2zc.top/tags/%E5%86%85%E6%A0%B8%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>上传博客的教程</title>
    <link href="https://leeway2zc.top/2025/08/10/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%95%99%E7%A8%8B/"/>
    <id>https://leeway2zc.top/2025/08/10/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%95%99%E7%A8%8B/</id>
    <published>2025-08-10T20:26:31.000Z</published>
    <updated>2025-08-11T09:07:56.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以后写文章的流程"><a href="#以后写文章的流程" class="headerlink" title="以后写文章的流程"></a><strong>以后写文章的流程</strong></h2><ol><li><code>npx hexo new post &quot;文章标题&quot;</code></li><li>编辑 <code>source/_posts/文章标题.md</code></li><li><code>git add . &amp;&amp; git commit -m &quot;update post&quot; &amp;&amp; git push</code></li><li>等 1~2 分钟，GitHub Pages 自动更新</li></ol><h2 id="在其他设备上推送博客的流程"><a href="#在其他设备上推送博客的流程" class="headerlink" title="在其他设备上推送博客的流程"></a>在其他设备上推送博客的流程</h2><ol><li><p>安装git、node.js、npm</p><blockquote><p>使用git -v, node -v, npm -v检查是否安装成功</p></blockquote></li><li><p>选择一个目录打开 git bash，执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/Leeway2ZC/hexo-blog.git</span></span><br></pre></td></tr></table></figure></li><li><p>进入仓库目录 <code>cd hexo-blog</code></p></li><li><p>安装项目依赖 <code>npm install</code></p></li><li><p>在Git中设置本地用户名和邮箱</p><ul><li><p>配置全局Git用户名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Leeway2ZC&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>配置全局Git邮箱</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;leeway2zc@gmail.com&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>然后就可以按照上面的流程写文章啦</p></li></ol><h2 id="关于修改添加测试博客功能"><a href="#关于修改添加测试博客功能" class="headerlink" title="关于修改添加测试博客功能"></a>关于修改添加测试博客功能</h2><blockquote><p>参考hexo官方教程<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p></blockquote><p>使用git退回上一个提交版本(将源码分支和网站都退回到上个版本)：</p><ol><li><code>git log --oneline </code> # 找到上一个版本的 commit ID</li><li><code>git reset --hard &lt;commit-id&gt;</code> # 找到上一个版本的 commit ID</li><li><code>git push origin main --force</code> # 推送（覆盖远端）</li></ol><p>更改主题时，使用git在本地先进行测试，然后推送博客更新</p><ol><li><p><code>git branch</code>  # 查看当前分支</p></li><li><p><code>git checkout -b test-theme</code> # 创建并切换到测试分支</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这一步做了两件事，此时的 `test-theme` 是完全跟 `main` 一样的，只是互不影响</span><br><span class="line"></span><br><span class="line">1. 从 `main` 复制当前代码</span><br><span class="line">2. 切换到新分支 `test-theme`</span><br></pre></td></tr></table></figure></li><li><p>在测试分支修改主题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你在这个分支上可以随便改主题、调整配置、改文章。</span><br><span class="line">如果改坏了，直接删掉这个分支就行，main 分支不受影响。</span><br></pre></td></tr></table></figure></li><li><p>本地测试，在test-theme分支中运行 <code>npx hexo server</code> 浏览效果</p></li><li><p>确认没问题后合并到main</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge test-theme</span><br></pre></td></tr></table></figure></li><li><p>推送到远程（更新博客）<code>git push origin main</code></p></li><li><p>如果发现问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git branch -D test-theme</span><br></pre></td></tr></table></figure><p>直接删除分支，一切回到切换主题前</p></li></ol><h2 id="关于配置图床"><a href="#关于配置图床" class="headerlink" title="关于配置图床"></a>关于配置图床</h2><ol><li>安装PicGo</li><li>配置PicGo<ol><li>使用ini文件设置腾讯云Cos</li><li>设置Server修改监听端口与Typora保持一致</li></ol></li><li>配置Typora<ol><li>修改偏好设置中的图像</li><li>修改为上传图片，上传服务更改为PicGo</li><li>验证图片上传选项</li></ol></li></ol><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250811005047923.png" alt="image-20250811005047923" style="zoom:50%;" /><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>如果在另一台设备上做了修改，那么写文章前先要拉取最新代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><p>从而确保代码库是最新的，避免冲突</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;以后写文章的流程&quot;&gt;&lt;a href=&quot;#以后写文章的流程&quot; class=&quot;headerlink&quot; title=&quot;以后写文章的流程&quot;&gt;&lt;/a&gt;&lt;strong&gt;以后写文章的流程&lt;/strong&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;npx hexo new post</summary>
      
    
    
    
    
    <category term="教程" scheme="https://leeway2zc.top/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="https://leeway2zc.top/2025/08/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>https://leeway2zc.top/2025/08/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</id>
    <published>2025-08-10T18:50:13.000Z</published>
    <updated>2025-08-11T09:07:56.538Z</updated>
    
    <content type="html"><![CDATA[<p>这是我的第一篇博客，感谢大家捧场</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是我的第一篇博客，感谢大家捧场&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
