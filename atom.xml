<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeeWay</title>
  
  <subtitle>李海云</subtitle>
  <link href="https://leeway2zc.top/atom.xml" rel="self"/>
  
  <link href="https://leeway2zc.top/"/>
  <updated>2025-10-11T06:45:07.917Z</updated>
  <id>https://leeway2zc.top/</id>
  
  <author>
    <name>David Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IOR 测试</title>
    <link href="https://leeway2zc.top/2025/10/11/IOR-%E6%B5%8B%E8%AF%95/"/>
    <id>https://leeway2zc.top/2025/10/11/IOR-%E6%B5%8B%E8%AF%95/</id>
    <published>2025-10-11T14:42:36.000Z</published>
    <updated>2025-10-11T06:45:07.917Z</updated>
    
    <content type="html"><![CDATA[<h1><center>IOR 测试</center></h1><h2 id="一-本地文件系统测试"><a href="#一-本地文件系统测试" class="headerlink" title="一  本地文件系统测试"></a>一  本地文件系统测试</h2><h3 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1 安装依赖"></a>1 安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt install -y git build-essential automake libopenmpi-dev openmpi-bin libaio-dev</span><br></pre></td></tr></table></figure><h3 id="2-克隆并编译-IOR"><a href="#2-克隆并编译-IOR" class="headerlink" title="2 克隆并编译 IOR"></a>2 克隆并编译 IOR</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hpc/ior.git</span><br><span class="line"><span class="built_in">cd</span> ior</span><br><span class="line">./bootstrap</span><br><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h3 id="3-测试文件系统"><a href="#3-测试文件系统" class="headerlink" title="3 测试文件系统"></a>3 测试文件系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Test ext4 (replace /path/to/ext4/testfile with your ext4 mount path):</span></span><br><span class="line">./src/ior -a POSIX -w -r -t 1m -b 1g -s 1 -o /path/to/ext4/testfile -e -C</span><br></pre></td></tr></table></figure><h3 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4 测试结果"></a>4 测试结果</h3><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20251010085447357.png" alt="image-20251010085447357" style="zoom:150%;" /><h2 id="二-分布式文件系统测试"><a href="#二-分布式文件系统测试" class="headerlink" title="二  分布式文件系统测试"></a>二  分布式文件系统测试</h2><blockquote><p>配置：至少两个节点，节点间能互相ping通<br>这里使用两台virtualBox模拟两个节点，通过桥接模式连接<br>ior11作为客户端 ip 地址为 192.168.222.154，ubuntu20作为服务器 ip 地址为 192.168.222.233<br>文中node1和node2在此测试中分别为ubuntu20和ior11</p></blockquote><h3 id="1-部署-GlusterFS"><a href="#1-部署-GlusterFS" class="headerlink" title="1 部署 GlusterFS"></a>1 部署 GlusterFS</h3><ol><li>更新系统并添加 GlusterFS PPA（在所有节点上执行）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install software-properties-common -y</span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:gluster/glusterfs-10 -y</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 GlusterFS 服务器（在所有节点上执行）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install glusterfs-server -y</span><br></pre></td></tr></table></figure><ol start="3"><li>启动并启用 GlusterFS 服务（在所有节点上执行）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start glusterd</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> glusterd</span><br><span class="line"><span class="built_in">sudo</span> systemctl status glusterd  <span class="comment"># 检查服务是否运行</span></span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20251010153130847.png" alt="image-20251010153130847"></p><ol start="4"><li>配置主机名解析（在所有节点上执行）: 编辑 &#x2F;etc&#x2F;hosts 文件，添加所有节点的 IP 和主机名。例如</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/hosts</span><br></pre></td></tr></table></figure><p>​添加内容如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换node和地址为真实的主机名和ip地址</span></span><br><span class="line">192.168.1.101 node1  <span class="comment"># 使用hostname查看主机名</span></span><br><span class="line">192.168.1.102 node2  <span class="comment"># 使用ip a查看ip地址</span></span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20251010153354392.png" alt="image-20251010153354392"></p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20251010153421113.png" alt="image-20251010153421113"></p><blockquote><p>这一步的目的是确保双方能ping通</p></blockquote><ol start="5"><li>配置防火墙（如果启用，在所有节点上执行）: GlusterFS 使用端口 24007-24008、49152 等。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow from 192.168.1.0/24 to any port 24007:24008 proto tcp</span><br><span class="line"><span class="comment"># 根据卷 brick 数量调整</span></span><br><span class="line"><span class="built_in">sudo</span> ufw allow from 192.168.1.0/24 to any port 49152:49160 proto tcp  </span><br><span class="line"><span class="built_in">sudo</span> ufw reload</span><br></pre></td></tr></table></figure><blockquote><p>这一步我没整，因为虚拟机没启用防火墙</p></blockquote><ol start="6"><li>建立节点间的信任(从服务器节点上执行)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gluster peer probe node2</span><br><span class="line"><span class="built_in">sudo</span> gluster peer status  <span class="comment"># 检查是否连接成功</span></span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20251010153709826.png" alt="image-20251010153709826"></p><blockquote><p>只要能ping通就能连接</p></blockquote><ol start="7"><li><strong>创建存储砖</strong>（brick，在所有节点上执行）: 为 GlusterFS 准备专用目录和分区（例如，使用 &#x2F;data&#x2F;brick1）。假设您有一个空分区 &#x2F;dev&#x2F;sdb：</li></ol><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20251010153828717.png" alt="image-20251010153828717"></p><blockquote><p>通过在virtualbox中添加虚拟磁盘可以为虚拟机增加一个空分区sdb</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行下面命令完成分区创建以及挂载</span></span><br><span class="line"><span class="built_in">sudo</span> mkfs.xfs /dev/sdb</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /data/brick1</span><br><span class="line"><span class="built_in">sudo</span> mount /dev/sdb /data/brick1</span><br></pre></td></tr></table></figure><p>​编辑 &#x2F;etc&#x2F;fstab 添加自动挂载:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/sdb /data/brick1 xfs defaults 0 0</span><br></pre></td></tr></table></figure><ol start="8"><li>创建分布式卷（从服务器节点执行）: 这里创建一个简单的分布式复制卷（replicated volume），副本数为 2</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gluster volume create test-volume replica 2 node1:/data/brick1 node2:/data/brick1 force</span><br><span class="line"><span class="built_in">sudo</span> gluster volume start test-volume</span><br><span class="line"><span class="built_in">sudo</span> gluster volume info test-volume  <span class="comment"># 检查卷状态</span></span><br></pre></td></tr></table></figure><ol start="9"><li>挂载 GlusterFS 卷（在客户端节点或测试节点上执行）: 安装客户端（如果不是服务器节点）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install glusterfs-client -y</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /mnt/gluster</span><br><span class="line"><span class="built_in">sudo</span> mount -t glusterfs node1:/test-volume /mnt/gluster</span><br></pre></td></tr></table></figure><blockquote><p>此时就在客户端节点上挂载了服务器端的卷，客户端或服务器写这个卷两边都会同时修改</p></blockquote><ul><li>如果重启虚拟机，则需要重新挂载一一遍glusterfs</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mount -t glusterfs node1:/test-volume /mnt/gluster</span><br></pre></td></tr></table></figure><p>​或者设置自动挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/fstab</span><br><span class="line">node1:/test-volume /mnt/gluster glusterfs defaults,_netdev,backupvolfile-server=node2 0 0</span><br></pre></td></tr></table></figure><ul><li>在服务器上使用 <code>echo &quot;Hello Gluster&quot; &gt; /mnt/gluster/testfile</code> 测试是否挂载成功</li></ul><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20251010165013777.png" alt="image-20251010165013777"></p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20251010165020162.png" alt="image-20251010165020162"></p><ul><li>或者使用 <code>mount | grep /mnt/gluster</code> 查看是否挂载了 gluster 卷，如果为空则没有挂载</li></ul><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20251010164633499.png" alt="image-20251010164633499"></p><h2 id="2-安装-MPI-和-IOR"><a href="#2-安装-MPI-和-IOR" class="headerlink" title="2  安装 MPI 和 IOR"></a>2  安装 MPI 和 IOR</h2><blockquote><p>IOR 是一个 I&#x2F;O 基准测试工具，需要 MPI支持分布式测试，这里使用OpenMPI</p></blockquote><ol><li>安装OpenMPI（在所有测试节点上执行）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install openmpi-bin openmpi-common libopenmpi-dev -y</span><br><span class="line">mpirun --version</span><br></pre></td></tr></table></figure><p>​如果需要 SSH 支持分布式运行（多节点）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install openssh-server -y</span><br><span class="line"><span class="comment"># 配置无密码 SSH（生成密钥并复制到其他节点）</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">ssh-copy-id user@node2  <span class="comment"># 替换 user 和 node2</span></span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">ssh-copy-id user@node1  <span class="comment"># 替换 user 和 node2</span></span><br></pre></td></tr></table></figure><blockquote><p>配置无密码 SSH 时要注意，如果node1或2的ssh配置文件没有设置<br>PermitRootLogin yes<br>PasswordAuthentication yes<br>是无法通过密码 ssh 到 node1或2 上的<br>修改完ssh配置后，使用sudo sshd -t检查是否有语法错误，然后重启ssh服务<br>sudo systemctl restart ssh<br>sudo systemctl status ssh   # 检查服务是否运行，无错误</p></blockquote><ol start="2"><li>安装 IOR（在测试节点上执行，从源代码编译，因为 Ubuntu 仓库中没有直接包）: IOR 需要 MPI 支持，所以在配置时指定</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git autoconf automake libtool make gcc -y  # 安装依赖</span><br><span class="line">git clone https://github.com/hpc/ior.git</span><br><span class="line">cd ior</span><br><span class="line">./bootstrap</span><br><span class="line">./configure --prefix=/usr/local --with-mpiio</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><blockquote><p>如果提示 autoconf 版本不正确，则通过以下命令升级autoconf版本<br>sudo apt update &amp;&amp; sudo apt install -y wget tar make m4 perl<br>wget <a href="https://ftp.gnu.org/gnu/autoconf/autoconf-2.71.tar.gz">https://ftp.gnu.org/gnu/autoconf/autoconf-2.71.tar.gz</a><br>tar -xzf autoconf-2.71.tar.gz<br>cd autoconf-2.71<br>.&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;local<br>make<br>sudo make install</p></blockquote><h2 id="3-使用-IOR-通过-MPI-测试-GlusterFS-性能"><a href="#3-使用-IOR-通过-MPI-测试-GlusterFS-性能" class="headerlink" title="3  使用 IOR 通过 MPI 测试 GlusterFS 性能"></a>3  使用 IOR 通过 MPI 测试 GlusterFS 性能</h2><blockquote><p>IOR 支持多种 I&#x2F;O 模式（如 POSIX、MPI-IO），可以测试读&#x2F;写带宽、IOPS 等。使用 MPI 允许分布式测试（多进程&#x2F;多节点）</p></blockquote><ol><li>单机测试写入性能（MPI-IO 接口，2 进程，块大小 1MB，传输大小 1MB，重复 3 次）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpirun -np 2 ior -a MPIIO -b 1m -t 1m -i 3 -o /mnt/gluster/testfile -w</span><br></pre></td></tr></table></figure><ul><li>-np 2: 使用 2 个 MPI 进程（根据您的 CPU 核心调整）</li><li>-a MPIIO: 使用 MPI-IO 接口（适合分布式文件系统）</li><li>-b 1m: 块大小（block size）</li><li>-t 1m: 传输大小（transfer size）。</li><li>-i 3: 重复迭代 3 次。</li><li>-o: 输出文件路径（在 Gluster 卷上）</li><li>-w: 只测试写入。 输出将显示带宽（MB&#x2F;s）、操作时间等</li></ul><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20251010172727658.png" alt="image-20251010172727658"></p><ol start="2"><li>测试读取性能</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpirun -np 2 ior -a MPIIO -b 1m -t 1m -i 3 -o /mnt/gluster/testfile -r</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>多节点测试(重点部分)</strong></li></ol><p>使用 -hostfile 指定主机： 创建 hostfile.txt：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node1 slots=2  // slots是可用cpu数量</span><br><span class="line">node2 slots=2</span><br></pre></td></tr></table></figure><p>进行测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpirun --hostfile hostfile.txt ior -a MPIIO -b 1m -t 1m -i 3 -o /mnt/gluster/testfile -w</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20251011081051277.png" alt="image-20251011081051277"><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20251011081112988.png" alt="image-20251011081112988"></p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20251011081230613.png" alt="image-20251011081230613"></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><blockquote><p>做完了前面的准备工作后，使用ior测试分布式文件系统gluster的性能就这么几步</p></blockquote><ol><li>在所有节点上启动 GlusterFS 服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start glusterd</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> glusterd</span><br><span class="line"><span class="built_in">sudo</span> systemctl status glusterd</span><br></pre></td></tr></table></figure><ol start="2"><li>挂载 GlusterFS 卷</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t glusterfs node1:/test-volume /mnt/gluster</span><br></pre></td></tr></table></figure><ol start="3"><li>进行测试</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备hostfile.txt文件内容</span></span><br><span class="line">node1 slots=2</span><br><span class="line">node2 slots=2</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行测试</span></span><br><span class="line">mpirun --hostfile hostfile.txt ior -a MPIIO -b 1m -t 1m -i 3 -o /mnt/gluster/testfile -w</span><br></pre></td></tr></table></figure><h2 id="三-离线环境下安装-IOR"><a href="#三-离线环境下安装-IOR" class="headerlink" title="三  离线环境下安装 IOR"></a>三  离线环境下安装 IOR</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;IOR 测试&lt;/center&gt;&lt;/h1&gt;



&lt;h2 id=&quot;一-本地文件系统测试&quot;&gt;&lt;a href=&quot;#一-本地文件系统测试&quot; class=&quot;headerlink&quot; title=&quot;一  本地文件系统测试&quot;&gt;&lt;/a&gt;一  本地文件系统测试&lt;/h2&gt;&lt;h3</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VirtualBox 虚拟机使用代理教程</title>
    <link href="https://leeway2zc.top/2025/10/11/VirtualBox-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E6%95%99%E7%A8%8B/"/>
    <id>https://leeway2zc.top/2025/10/11/VirtualBox-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E6%95%99%E7%A8%8B/</id>
    <published>2025-10-11T14:40:49.000Z</published>
    <updated>2025-10-11T06:45:07.918Z</updated>
    
    <content type="html"><![CDATA[<h1><center>Oracle VirtualBox 虚拟机使用代理教程</center></h1><h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><ul><li>主机 win10 专业版</li><li>虚拟机镜像 ubuntu 20.04 LTS</li><li>代理使用 HTTP&#x2F;HTTPS&#x2F;SOCKS5 协议</li></ul><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><ol><li><p>在代理软件中查看代理使用的端口号(一般是4位数)</p></li><li><p>在主机中使用 cmd 输入命令 ipconfig 查看自己的主机 IP 地址</p></li><li><p>找到 ipv4 的地址信息，知道了这个就可以在ubuntu中设置代理了</p></li><li><p>在虚拟机中打开终端(ctrl+alt+T)，输入以下命令即可设置虚拟机走代理 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy mode <span class="string">&#x27;manual&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.http host <span class="string">&#x27;ipv4地址&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.http port 代理使用的端口号如7897</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.https host <span class="string">&#x27;ipv4地址&#x27;</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.system.proxy.https port 代理使用的端口号如7897</span><br></pre></td></tr></table></figure></li><li><p>为命令行工具配置代理如 apt、curl、wget 等(可选)，在终端使用 gedit ~&#x2F;.bashrc 打开bash配置文件，在文件末尾添加如下代码 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://ipv4地址:端口号&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://ipv4地址:端口号&quot;</span></span><br><span class="line"><span class="built_in">export</span> ftp_proxy=<span class="string">&quot;http://ipv4地址:端口号&quot;</span></span><br><span class="line"><span class="built_in">export</span> no_proxy=<span class="string">&quot;localhost,127.0.0.1,::1&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>在虚拟机终端执行 source ~&#x2F;.bashrc 更新配置</p></li><li><p>为 APT 工具设置代理(可选)，在终端输入sudo nano &#x2F;etc&#x2F;apt&#x2F;apt.conf.d&#x2F;95proxies，在末尾添加代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/apt/apt.conf.d/95proxies</span><br><span class="line"></span><br><span class="line">Acquire::http::Proxy <span class="string">&quot;http://ipv4地址:端口号&quot;</span>;</span><br><span class="line">Acquire::https::Proxy <span class="string">&quot;http://ipv4地址:端口号&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>在代理软件中选择”允许局域网连接”，在主机cmd中输入以下代码验证是否生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl cip.cc</span><br></pre></td></tr></table></figure></li><li><p>如果返回出口IP，也就是自己的IPv4地址就说明成功了，此后就可以在代理软件中选择允许局域网连接来控制虚拟机的代理了</p></li></ol><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/a48cfb879a73499b8af73907e2807df5.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;Oracle VirtualBox 虚拟机使用代理教程&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;环境：&quot;&gt;&lt;a href=&quot;#环境：&quot; class=&quot;headerlink&quot; title=&quot;环境：&quot;&gt;&lt;/a&gt;环境：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;主机 wi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式存储系统学习路径</title>
    <link href="https://leeway2zc.top/2025/10/09/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"/>
    <id>https://leeway2zc.top/2025/10/09/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</id>
    <published>2025-10-09T16:00:00.000Z</published>
    <updated>2025-10-11T06:45:07.918Z</updated>
    
    <content type="html"><![CDATA[<p>要达成的目标：</p><ul><li>精通C&#x2F;C++</li><li>具有多线程、高并发及各种IO模型的编程经验</li><li>熟悉分布式算法（如paxos、raft）</li><li>计算机网络（如各种rpc实现和高性能网络收发库）</li><li>理解大型分布式存储系统工作原理</li><li>开源实现（例如grpc、zk、etcd、braft等等）</li><li>有文件存储、块存储、对象存储开发经验<ul><li>Ceph、GlusterFS、Lustre、ZFS、fuse</li></ul></li><li>了解高速RDMA网络</li><li>用户态零拷贝存储SPDK</li><li>高性能存储介质NVMe</li><li>高并发无锁数据结构</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要达成的目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;精通C&amp;#x2F;C++&lt;/li&gt;
&lt;li&gt;具有多线程、高并发及各种IO模型的编程经验&lt;/li&gt;
&lt;li&gt;熟悉分布式算法（如paxos、raft）&lt;/li&gt;
&lt;li&gt;计算机网络（如各种rpc实现和高性能网络收发库）&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BeeGFS学习笔记</title>
    <link href="https://leeway2zc.top/2025/10/09/BeeGFS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://leeway2zc.top/2025/10/09/BeeGFS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-10-09T15:56:06.000Z</published>
    <updated>2025-10-11T06:45:07.917Z</updated>
    
    <content type="html"><![CDATA[<h1><center>BeeGFS 学习笔记</center></h1><blockquote><p>通过实践的方式学习BeeGFS</p></blockquote><h2 id="一-在虚拟机中通过docker容器搭建beegfs集群"><a href="#一-在虚拟机中通过docker容器搭建beegfs集群" class="headerlink" title="一  在虚拟机中通过docker容器搭建beegfs集群"></a>一  在虚拟机中通过docker容器搭建beegfs集群</h2><h3 id="1-目标"><a href="#1-目标" class="headerlink" title="1 目标"></a>1 目标</h3><p>在一台虚拟机中运行四个 Docker 容器</p><table><thead><tr><th>容器名</th><th>角色</th><th>IP</th><th>作用</th></tr></thead><tbody><tr><td><code>beegfs-mgmtd</code></td><td>管理节点</td><td>172.25.0.2</td><td>注册、调度、心跳</td></tr><tr><td><code>beegfs-meta</code></td><td>元数据节点</td><td>172.25.0.3</td><td>管理目录结构和 inode</td></tr><tr><td><code>beegfs-storage</code></td><td>存储节点</td><td>172.25.0.4</td><td>存放数据块</td></tr><tr><td><code>beegfs-client</code></td><td>客户端节点</td><td>172.25.0.5</td><td>挂载并访问 BeeGFS</td></tr></tbody></table><p>所有容器在同一个 Docker 自定义网络中，能够互相 <code>ping</code> 通</p><h3 id="2-创建自定义网络"><a href="#2-创建自定义网络" class="headerlink" title="2 创建自定义网络"></a>2 创建自定义网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --subnet=172.25.0.0/16 beegfs-net</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect beegfs-net | grep Subnet</span><br><span class="line"><span class="comment"># &quot;Subnet&quot;: &quot;172.25.0.0/16&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20251009092114274.png" alt="image-20251009092114274"></p><h3 id="3-创建四个容器"><a href="#3-创建四个容器" class="headerlink" title="3 创建四个容器"></a>3 创建四个容器</h3><h4 id="创建管理节点容器-mgmtd"><a href="#创建管理节点容器-mgmtd" class="headerlink" title="创建管理节点容器(mgmtd)"></a>创建管理节点容器(mgmtd)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name beegfs-mgmtd --hostname mgmtd \</span><br><span class="line">  --network beegfs-net --ip 172.25.0.2 \</span><br><span class="line">  --privileged ubuntu:20.04 bash</span><br></pre></td></tr></table></figure><h4 id="创建元数据节点-meta"><a href="#创建元数据节点-meta" class="headerlink" title="创建元数据节点(meta)"></a>创建元数据节点(meta)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name beegfs-meta --hostname meta \</span><br><span class="line">  --network beegfs-net --ip 172.25.0.3 \</span><br><span class="line">  --privileged ubuntu:20.04 bash</span><br></pre></td></tr></table></figure><h4 id="创建存储节点-storage"><a href="#创建存储节点-storage" class="headerlink" title="创建存储节点(storage)"></a>创建存储节点(storage)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name beegfs-storage --hostname storage \</span><br><span class="line">  --network beegfs-net --ip 172.25.0.4 \</span><br><span class="line">  --privileged ubuntu:20.04 bash</span><br></pre></td></tr></table></figure><h4 id="创建客户端节点-client"><a href="#创建客户端节点-client" class="headerlink" title="创建客户端节点(client)"></a>创建客户端节点(client)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name beegfs-client --hostname client \</span><br><span class="line">  --network beegfs-net --ip 172.25.0.5 \</span><br><span class="line">  --privileged ubuntu:20.04 bash</span><br></pre></td></tr></table></figure><h3 id="4-测试网络连通性"><a href="#4-测试网络连通性" class="headerlink" title="4 测试网络连通性"></a>4 测试网络连通性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 管理节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it beegfs-mgmtd bash</span><br><span class="line"><span class="comment"># 先安装工具</span></span><br><span class="line">apt update</span><br><span class="line">apt install -y iputils-ping net-tools vim build-essential gdb wget curl</span><br><span class="line"><span class="comment"># ping一下</span></span><br><span class="line">ping -c 2 172.25.0.3   <span class="comment"># meta</span></span><br><span class="line">ping -c 2 172.25.0.4   <span class="comment"># storage</span></span><br><span class="line">ping -c 2 172.25.0.5   <span class="comment"># client</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 元数据节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it beegfs-meta bash</span><br><span class="line"><span class="comment"># 先安装工具</span></span><br><span class="line">apt update</span><br><span class="line">apt install -y iputils-ping net-tools vim build-essential gdb wget curl</span><br><span class="line"><span class="comment"># ping一下</span></span><br><span class="line">ping -c 2 172.25.0.2   <span class="comment"># meta</span></span><br><span class="line">ping -c 2 172.25.0.4   <span class="comment"># storage</span></span><br><span class="line">ping -c 2 172.25.0.5   <span class="comment"># client</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it beegfs-storage bash</span><br><span class="line"><span class="comment"># 先安装工具</span></span><br><span class="line">apt update</span><br><span class="line">apt install -y iputils-ping net-tools vim build-essential gdb wget curl</span><br><span class="line"><span class="comment"># ping一下</span></span><br><span class="line">ping -c 2 172.25.0.2   <span class="comment"># meta</span></span><br><span class="line">ping -c 2 172.25.0.3   <span class="comment"># storage</span></span><br><span class="line">ping -c 2 172.25.0.5   <span class="comment"># client</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端节点</span></span><br><span class="line">docker <span class="built_in">exec</span> -it beegfs-client bash</span><br><span class="line"><span class="comment"># 先安装工具</span></span><br><span class="line">apt update</span><br><span class="line">apt install -y iputils-ping net-tools vim build-essential gdb wget curl</span><br><span class="line"><span class="comment"># ping一下</span></span><br><span class="line">ping -c 2 172.25.0.2   <span class="comment"># meta</span></span><br><span class="line">ping -c 2 172.25.0.3   <span class="comment"># storage</span></span><br><span class="line">ping -c 2 172.25.0.4   <span class="comment"># client</span></span><br></pre></td></tr></table></figure><h3 id="5-逐个容器安装BeeGFS并启动节点"><a href="#5-逐个容器安装BeeGFS并启动节点" class="headerlink" title="5 逐个容器安装BeeGFS并启动节点"></a>5 逐个容器安装BeeGFS并启动节点</h3><p>1️⃣ 管理节点 <code>mgmtd</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.beegfs.io/release/beegfs_8.1/dists/focal/amd64/beegfs-mgmtd_8.1.0_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /data/mgmtd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;storeMgmtdDirectory=/data/mgmtd&quot;</span> &gt; /etc/beegfs/beegfs-mgmtd.conf</span><br><span class="line"></span><br><span class="line">/opt/beegfs/sbin/beegfs-mgmtd --init=<span class="literal">true</span> --log-target=stderr --log-level=info</span><br><span class="line">/opt/beegfs/sbin/beegfs-mgmtd --log-target=stderr  --log-level=info  --auth-disable=<span class="literal">true</span>  --tls-disable=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20251009114047133.png" alt="image-20251009114047133"></p><p>2️⃣ 元数据节点 <code>meta</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.beegfs.io/release/beegfs_8.1/dists/focal/amd64/beegfs-meta_8.1.0_amd64.deb</span><br><span class="line"></span><br><span class="line">dpkg -i beegfs-meta_8.1.0_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /data/meta</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;storeMetaDirectory=/data/meta&quot;</span> &gt; /etc/beegfs/beegfs-meta.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;connInterfaces=eth0&quot;</span> &gt;&gt; /etc/beegfs/beegfs-meta.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;sysMgmtdHost=&lt;MGMT_NODE_IP&gt;&quot;</span> &gt;&gt; /etc/beegfs/beegfs-meta.conf</span><br></pre></td></tr></table></figure><p>3️⃣ 存储节点 <code>storage</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.beegfs.io/release/beegfs_8.1/dists/focal/amd64/beegfs-storage_8.1.0_amd64.deb</span><br><span class="line"></span><br><span class="line">dpkg -i beegfs-storage_8.1.0_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /data/storage</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;storeStorageDirectory=/data/storage&quot;</span> &gt; /etc/beegfs/beegfs-storage.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;connInterfaces=eth0&quot;</span> &gt;&gt; /etc/beegfs/beegfs-storage.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;sysMgmtdHost=&lt;MGMT_NODE_IP&gt;&quot;</span> &gt;&gt; /etc/beegfs/beegfs-storage.conf</span><br></pre></td></tr></table></figure><p>4️⃣  客户节点 <code>client</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.beegfs.io/release/beegfs_8.1/dists/focal/amd64/beegfs-client_8.1.0_all.deb</span><br><span class="line"></span><br><span class="line">dpkg -i beegfs-client_8.1.0_all.deb</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;sysMgmtdHost=172.25.0.2&quot;</span> &gt; /etc/beegfs/beegfs-client.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;connInterfaces=eth0&quot;</span> &gt;&gt; /etc/beegfs/beegfs-client.conf</span><br></pre></td></tr></table></figure><p>到这里宣告失败了，在docker容器中部署beegfs实在太难了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;BeeGFS 学习笔记&lt;/center&gt;&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;通过实践的方式学习BeeGFS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一-在虚拟机中通过docker容器搭建beegfs集群&quot;&gt;&lt;a href=&quot;#一-在虚</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>总结与思考</title>
    <link href="https://leeway2zc.top/2025/09/26/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/"/>
    <id>https://leeway2zc.top/2025/09/26/%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/</id>
    <published>2025-09-26T23:55:08.000Z</published>
    <updated>2025-10-11T06:45:07.918Z</updated>
    
    <content type="html"><![CDATA[<h1><center>总结与思考</center></h1><h2 id="关于存储方向技术栈的学习-25-9-26"><a href="#关于存储方向技术栈的学习-25-9-26" class="headerlink" title="关于存储方向技术栈的学习  25&#x2F;9&#x2F;26"></a>关于存储方向技术栈的学习  25&#x2F;9&#x2F;26</h2><p>​这段时间一直在学习网络编程方面的知识，主要是通过一本名为《Linux高性能服务器编程》的书在学，从9&#x2F;22到今天一共学了5天，学了一半学到了第九章 I&#x2F;O 复用，我发现通过一本书来学习技术确实很好，因为这足够全面，里面会介绍很多我不知道但是很经典的知识，例如TCP&#x2F;UDP协议、三次握手建立连接，四次握手断开连接、网络体系等，虽然说这些和后面提到的使用 socket API 建立服务器程序关系不大，但了解这些底层的知识对于以后 troubleshoot 可能会有很大的帮助。扯远了，这里主要聊一聊学习网络编程这个技术的一些心得体会。</p><p>​这本书出版的比较早了，是13年的书了，但直到今天上面的程序依然是能在 linux 虚拟机中运行的，书中的程序我是通过 virtual box 中的 linux 系统上的 docker 容器模拟服务器节点和客户端节点跑的，只需要用 docker 容器设置好节点的路由即可让这两个节点 ping 通。在学习这本书的过程中，从一开始的 socket API 到后面的服务器模型、网络模型，直到现在学的这个 I&#x2F;O 复用讲关于使用 select、poll、epoll 实现程序同时管理多个 I&#x2F;O 请求，我发现其实里面真正实用的包括代码和 API 函数只占内容的很小一部分，也就是说用到实践的话，参考的东西并不很多，可能这是技术书籍的一个通病，也可以说是缺点吧，就是为了售价更高而加入了很多概念以扩充页数，但真正用于实践的内容并不多。但仔细一看又能发现这些内容虽然说只是一个概念性的东西或者说一个说明性的东西，但是这些内容确实和后面的代码有关，不看又感觉少点什么心里不安，但假设我不看这些，只了解 API 函数，知道这些函数的作用，然后去看代码，也是能看懂的，因为程序代码本来就主要是靠这些 API 函数实现的，所以你知道这 API 函数怎么使用，那么你就能写代码，正所谓 C++ 程序等于语法+API。</p><p>​说了这么多，其实是想说，我应该改变这种学习技术的思维方式，不应该总想着跟紧作者的思路，每一段每一行都读懂作者要表达的意思，但事实上，现在理解的意思过一段时间就会忘，更重要的是，有时我为了理解作者这句话要表达的意思，对这句话中不明白的部分去查资料，花费了大量的时间，结果到了程序代码部分，由于脑袋里装了太多太多的知识，反而难以想起这 API 函数的使用方法，导致看代码时要一直翻到前面讲 API 的部分，以至于花了大量的时间，结果实践的部分花的时间太少反而没学会怎么用。堪称雨露均沾适得其反，总的来说，就是没有抓住书中重点，或者说没有自己的目标，不知道自己看这段内容的时候是为了什么，只知道看懂每一句话。</p><p>​事实上，”懂”其实是一个很主观的事情，只是对句话的一个认可，一个心理上的接受的感觉，如果是这句话中出现了没见过的名词，那么看懂这句话还有点意义，至少建立了对这个名词的心智模型，知道了不知道的事情。无论怎么说，每句话都读懂是很费时间的，有时你读懂它了之后，下一分钟就忘记了，但你为了读懂这句话花了10分钟，这就没什么必要了，其实我认为，真正的懂，不是在于感觉，而是在于使用，前者能称得上是理解，后者应该要说掌握。</p><p>​掌握才是最重要的，这提升了人的主观能动性能力，讲了这么多，写的也有点累了，逻辑走到这里其实可以盖棺定论了，对于今天讨论的”关于技术的学习”，其实我是在探讨，如何快速的学习技术知识，以便于能迅速上手进行开发。为了学习网络编程，能编写高性能服务器程序，我选择了一本书来看，但是我看的实在太慢，5天只看了一半，每天从早上8点看到下午5点半，只看了180来页，看到现在也是勉强能写点网络小程序，让两个能 ping 通的节点能够发送数据和接受数据了，但这个进度还是太缓慢了，任何知识离不开反复的学习，我想早点结束这本书的学习，以便于开展笔记总结工作，以及系统的复习一遍从而真正掌握初步的网络编程能力，于是今天进行了一波反思与总结，探讨这本书学习过程中学习方法的缺陷。</p><p>​其实就是要学会抓重点，对于书中可以掌握的内容，要重点集中时间去学习，什么是可以掌握的内容？就是说可以用于实践，需要动手操作的内容，毕竟这本书是一本技术相关的书籍，它的价值就是教会你实践网络编程，而至于书中只能理解不能指导实践的内容，其实没必要太专注的去看，过一遍就好。这是一种新的学习方式了，同样这也是一种可以掌握的内容，学会之后必然学习的很快。但先要学会区分什么是掌握性内容，什么是理解性内容，以及克服自己对每段话都必须理解必须接受的一个心理需要，我想这一点应该是最难的。</p><p>​最后谈一谈关于 API 函数的学习吧，以 epoll_wait 这个函数为例，它的函数原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>​首先要知道这个函数的作用，这个函数用来将 epfd 这一内核事件表中的就绪事件取出来，存放到 events 中，从而知道哪些 fd 可以操作了。先知道这个 API 的一个作用，或者说知道这个 API 的上下文。然后是关于这个函数的参数说明：</p><ul><li><code>epfd</code>：<code>epoll_create</code> 或 <code>epoll_create1</code> 返回的 <strong>epoll 实例文件描述符</strong>。</li><li><code>events</code>：用户态传入的 <code>struct epoll_event</code> 数组，用于存放内核返回的就绪事件。</li><li><code>maxevents</code>：<code>events</code> 数组的大小，必须大于 0。</li><li><code>timeout</code>：<ul><li><code>&gt; 0</code>：等待的毫秒数，超时返回。</li><li><code>= 0</code>：立即返回，非阻塞。</li><li><code>= -1</code>：无限等待，直到有事件发生。</li></ul></li></ul><p>以及返回值：</p><ul><li><code>&gt; 0</code>：返回就绪的文件描述符数量。</li><li><code>= 0</code>：超时。</li><li><code>-1</code>：出错（例如信号中断 <code>EINTR</code>）。</li></ul><p>最后写一下使用流程，基本上的框架就是：</p><ol><li><p>写函数原型，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">然后下面写参数说明，格式如上</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>写基本使用流程，例如：</p></li></ol><p><code>epoll_wait</code> 一般配合 <code>epoll_ctl</code> 使用，流程是：</p><ol><li><p><strong>创建 epoll 实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> epfd = epoll_create1(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>添加要监听的 fd（socket、文件等）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN;   <span class="comment">// 监听可读事件</span></span><br><span class="line">ev.data.fd = listenfd;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);</span><br></pre></td></tr></table></figure></li><li><p><strong>等待事件发生</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[1024];</span></span><br><span class="line"><span class="type">int</span> nfds = epoll_wait(epfd, events, <span class="number">1024</span>, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>处理就绪事件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">    <span class="type">int</span> fd = events[i].data.fd;</span><br><span class="line">    <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">        <span class="comment">// fd 可读</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">        <span class="comment">// fd 可写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最好给出一个示例代码，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    addr.sin_port = htons(PORT);</span><br><span class="line">    bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    listen(listenfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> epfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = listenfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> nfds = epoll_wait(epfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == listenfd) &#123;</span><br><span class="line">                <span class="type">int</span> connfd = accept(listenfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                ev.events = EPOLLIN;</span><br><span class="line">                ev.data.fd = connfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> n = read(events[i].data.fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    close(events[i].data.fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    write(events[i].data.fd, buf, n); <span class="comment">// echo</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最好还有注意事项，例如：</p><ol><li><p><code>events</code> 是由内核写入的，<strong>调用前不用初始化</strong>。</p></li><li><p><code>maxevents</code> 要合理设置，通常和 <code>events</code> 数组大小相同。</p></li><li><p>如果 <code>timeout = -1</code>，进程会一直阻塞直到有事件发生。</p></li><li><p>处理事件时要小心：</p><p><strong>LT 模式</strong>：没读完&#x2F;写完的数据，下次还会触发。</p><p><strong>ET 模式</strong>：必须一次性读&#x2F;写到 <code>EAGAIN</code>，否则数据可能丢失。</p></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;总结与思考&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;关于存储方向技术栈的学习-25-9-26&quot;&gt;&lt;a href=&quot;#关于存储方向技术栈的学习-25-9-26&quot; class=&quot;headerlink&quot; title=&quot;关于存储方向技术栈的学习  25&amp;#x</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MLPerf使用</title>
    <link href="https://leeway2zc.top/2025/09/20/MLPerf%E4%BD%BF%E7%94%A8/"/>
    <id>https://leeway2zc.top/2025/09/20/MLPerf%E4%BD%BF%E7%94%A8/</id>
    <published>2025-09-20T11:19:28.000Z</published>
    <updated>2025-10-11T06:45:07.918Z</updated>
    
    <content type="html"><![CDATA[<h1><center>MLPerf 学习</center></h1><blockquote><p>MLPerf 是一个业界标准的机器学习性能基准套件（benchmark suite）</p></blockquote><blockquote><p>它的目标是让不同硬件平台（CPU&#x2F;GPU&#x2F;TPU&#x2F;ASIC）、框架（TensorFlow、PyTorch 等）和系统在 <strong>统一的工作负载</strong> 下进行公平的对比，从而衡量不同硬件&#x2F;系统在标准ML任务上的性能</p></blockquote><h2 id="一-MLPerf-概念"><a href="#一-MLPerf-概念" class="headerlink" title="一  MLPerf 概念"></a>一  MLPerf 概念</h2><ul><li><p>定位：类似于CPU中的SPEC，存储中的fio，MLPerf是机器学习中的基准测试。</p></li><li><p>作用：旨在对硬件、软件和服务的训练和推理性能进行无偏评估。</p></li><li><p>MLPerf 主要解决的问题：</p><ol><li><p>硬件对比</p><ul><li><p>比如：NVIDIA A100 vs H100、Intel CPU vs AMD CPU、Google TPU vs Habana Gaudi</p></li><li><p>大家都跑同样的模型（ResNet-50、BERT、DLRM 等），就能公平比较性能。</p></li></ul></li><li><p>系统优化对比</p><ul><li><p>不只是 GPU&#x2F;TPU，还包括 <strong>存储、网络、分布式训练框架、编译优化器</strong> 等。</p></li><li><p>比如 NCCL vs OneCCL，PyTorch vs TensorFlow，InfiniBand vs Ethernet。</p></li></ul></li><li><p>统一标准</p><ul><li><p>和 SPEC（CPU）、TPC（数据库性能）类似，MLPerf 是 ML 领域的统一标尺。</p></li><li><p>结果要符合精度门槛（accuracy target）、固定数据集和 batch size，保证公平。</p></li></ul></li></ol></li><li><p>基准测试类别</p><ul><li>MLPerf Training：Training基准套件测量系统训练模型达到目标质量指标的速度。<ul><li>MLPerf Training HPC</li></ul></li><li><strong>MLPerf Inference</strong>：Inference基准套件测量系统处理输入和使用训练模型生成结果的速度。<ul><li>MLPerf Inference Datacenter</li><li>MLPerf Inference Edge</li><li>MLPerf Inference Mobile</li><li>MLPerf Inference Tiny</li></ul></li><li><strong>MLPerf Storage</strong>：MLPerf存储基准测试套件测量存储系统在训练模型时提供训练数据的速度。</li><li>MLPerf Client：用于评估大型语言模型（LLMs）和其他 AI 工作负载在个人计算机上的性能——从笔记本电脑和台式机到工作站。通过模拟真实世界的 AI 任务，它提供了清晰的指标，以便了解系统处理生成性 AI 工作负载的能力。</li><li>MLPerf Automotive：用于测量旨在用于汽车的计算机性能，包括高级驾驶辅助系统&#x2F;自动驾驶（ADAS&#x2F;AD）和车载信息娱乐（IVI）嵌入式系统。主要的关键绩效指标是延迟，因为汽车系统是实时的，且通常需要功能安全。</li><li>AlgoPerf Training Algorithms：算法基准测试衡量通过更改基础训练算法（例如优化器或超参数）来提高神经网络模型训练速度，以达到给定的目标性能。</li><li>AlLuminate：AILuminate基准评估一般聊天机器人生成AI系统的安全性，以帮助指导开发，告知购买者和消费者，并支持标准机构和政策制定者。</li></ul></li><li><p>测试结果基础概念：</p><ul><li><p>Queries(查询)：指的是一个 推理请求，即向模型提交一个输入数据（例如一张图片、一段文本）并获取模型输出的过程。查询（Query） &#x3D; 输入数据 + 推理任务。</p><blockquote><p>每个查询通常包括</p></blockquote><ul><li>输入数据：例如一张图片、一段音频、一段文本</li><li>模型推理：将输入数据传递给模型，运行推理</li><li>输出结果：模型生成的预测结果（例如分类标签、生成文本）</li></ul></li><li><p>QPS(Queries Per Second)：系统每秒能够处理多少个查询（推理请求）</p><blockquote><p>QPS 描述的是 推理应用 的性能指标，而不是模型本身的指标。它衡量的是整个推理系统的吞吐量</p></blockquote><ul><li>如果 QPS &#x3D; 100，表示系统每秒可以处理 100 个推理请求</li><li>如果 QPS &#x3D; 50，表示系统每秒可以处理 50 个推理请求。</li><li>这个值越高越好，表明系统能够在单位时间内处理更多请求</li></ul></li><li><p>Mean(Mean Latency，平均延迟)：表示系统处理一个任务（查询&#x2F;推理请求）平均需要多长时间</p><ul><li>MEAN 越低，说明系统处理任务的速度越快。</li></ul></li></ul></li><li><p>测试场景类别：</p><ul><li><p>SingleStream(单流)：模拟单个用户推理请求的场景</p><blockquote><p>每次处理 一个输入数据（例如一张图片、一段文本）， 且 输入数据是逐张&#x2F;逐条处理的。<br>举个例子，有100张图片，一个图片执行一次查询，每个图片逐张执行一次查询，总共执行100次。</p></blockquote><ul><li>测试目标： 评估系统处理 单个任务（&#x2F;查询） 的速度（延迟）</li><li>关键指标：延迟（Latency）</li><li>适用场景：对延迟敏感的应用，例如，实时图像分类，实时语音识别，自动驾驶中的实时目标检测</li></ul></li><li><p>MultiStream(多流)：模拟多个用户同时请求的场景</p><blockquote><p>每个用户请求都是独立执行的。相当于多个 SingleStream 加在一起，但多个请求会同时并发执行<br>类似于OS单个进程和多个进程</p></blockquote><ul><li>测试目标： 评估系统在同时处理多个并发请求 时的性能</li><li>关键指标： 吞吐量（Throughput）&amp; 延迟（Latency）</li><li>适用场景：对吞吐量和延迟都有要求的应用，例如，多用户语音助手，多摄像头监控系统</li></ul></li><li><p>Offline(离线)：模拟单用户批量处理的场景</p><blockquote><p>系统一次性处理大量输入数据（例如一批图片、一段长文本）来执行一次查询（推理请求）<br>由于模型一般地都支持一次性输入多个数据来执行一次查询，所以离线模式研究多个输入下模型的处理能力，这个瓶颈就在QPS<br>举个例子，有100张图片，给模型一次输入20张，然后模型一次推理后，输出20张的结果，然后进入下一个批处理周期，直到处理完成</p></blockquote><ul><li>测试目标：评估系统处理 大量任务 的能力（吞吐量）</li><li>关键指标： 吞吐量（Throughput）</li><li>适用场景：对吞吐量要求高、对延迟不敏感的应用，例如，批量图像处理，大规模文本生成，离线数据分析</li></ul></li><li><p>Server(服务器)：模拟服务器端推理的场景</p><blockquote><p>系统需要同时处理多个并发请求，并在规定时间内返回结果</p></blockquote><ul><li>关键指标： 吞吐量（Throughput）&amp; 延迟（Latency）</li><li>适用场景：服务器端推理应用，例如，云端的图像分类服务，在线的语音识别服务，实时推荐系统</li></ul></li></ul></li></ul><h2 id="二-MLPerf-使用流程"><a href="#二-MLPerf-使用流程" class="headerlink" title="二  MLPerf 使用流程"></a>二  MLPerf 使用流程</h2><h3 id="1-MLPerf-Inference"><a href="#1-MLPerf-Inference" class="headerlink" title="1 MLPerf Inference"></a>1 MLPerf Inference</h3><blockquote><p>测试计算机视觉中图像分类和检测的性能</p></blockquote><p><strong>测试环境：</strong></p><ol><li>机器：Google Colab</li><li>基准模型：mobilenet、resnet50</li><li>模型框架：onnx</li><li>场景：视觉vision（图像分类）</li><li>数据集：fakeimagent</li></ol><p><strong>测试步骤：</strong></p><ol><li><p>克隆MLPerf Inference项目库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/mlperf/inference.git</span><br><span class="line"><span class="built_in">cd</span> inference/vision/classification_and_detection</span><br><span class="line">import os</span><br><span class="line">root = os.getcwd()</span><br></pre></td></tr></table></figure></li><li><p>安装必要的依赖库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python3-dev</span><br><span class="line">apt-get install cmake</span><br><span class="line">pip install  pytest</span><br><span class="line">pip install  numpy</span><br><span class="line">pip install  scipy</span><br><span class="line">pip install  pybind11</span><br><span class="line">pip install onnxruntime pycocotools opencv-python</span><br></pre></td></tr></table></figure></li><li><p>执行安装脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../../loadgen; CFLAGS=<span class="string">&quot;-std=c++14&quot;</span> python setup.py develop; <span class="built_in">cd</span> &#123;root&#125;</span><br><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure><p>安装成功应该在最后会显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Using /usr/local/lib/python3.12/dist-packages</span><br><span class="line">Finished processing dependencies for mlperf-inference==0.1.0</span><br></pre></td></tr></table></figure></li><li><p>下载模型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载 mobilenet 模型</span></span><br><span class="line">wget -q https://zenodo.org/record/3157894/files/mobilenet_v1_1.0_224.onnx</span><br><span class="line"><span class="comment"># mobilenet 为 resnet50 模型的轻量级模型，以降低模型复杂性和计算负担</span></span><br><span class="line"><span class="comment"># 下载 resnet50 模型</span></span><br><span class="line">wget -q https://zenodo.org/record/2592612/files/resnet50_v1.onnx</span><br></pre></td></tr></table></figure><blockquote><p>其他模块链接地址<a href="https://github.com/mlcommons/inference/tree/master/vision/classification_and_detection">https://github.com/mlcommons/inference/tree/master/vision/classification_and_detection</a></p></blockquote></li><li><p>下载数据集</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本测试中，使用 MLPerf 提供的 tools/make_fake_imagenet.sh 工具创建一个假装为 imagenet 的小型假数据集</span></span><br><span class="line">bash ./tools/make_fake_imagenet.sh</span><br><span class="line"><span class="comment"># 运行上述命令后，将在 /vision/classification_and_detection 文件夹中创建一个 fakeimagenet 文件夹，里面包含 val 文件夹和 val_map.txt 文件，val 文件夹中存放着 8 张假的图像数据集</span></span><br><span class="line"><span class="comment"># 通常需要下载 imagenet2012/valiation 进行图像分类，或下载 coco2017/valiation 进行对象检测</span></span><br></pre></td></tr></table></figure><blockquote><p>其他数据集的链接和说明地址<a href="https://github.com/mlcommons/inference/tree/master/vision/classification_and_detection">https://github.com/mlcommons/inference/tree/master/vision/classification_and_detection</a></p></blockquote></li><li><p>添加环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">os.environ[&#x27;MODEL_DIR&#x27;] = root</span><br><span class="line">os.environ[&#x27;DATA_DIR&#x27;] = os.path.join(root, &quot;fake_imagenet&quot;)</span><br></pre></td></tr></table></figure><p>对于 mlperf 提交的查询数、时间、延迟和百分位数，一般默认使用的设置。这个测试收中参考了官方教程，传递了一些额外的选项来让测试进展得更快。 run_local.sh 将查找环境变量 EXTRA_OPS 并将其添加到参数中。 还可以在命令行中添加其他参数。 以下选项将基准测试的运行时间限制为 10 秒，并添加准确性报告。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.environ[&#x27;EXTRA_OPS&#x27;] =&quot;--time 10 --max-latency 0.2&quot;</span><br></pre></td></tr></table></figure></li><li><p>把 <code>remove_initializer_from_input.py</code> 文件放到 <code>classification_and_detection</code> 文件夹</p></li></ol><blockquote><p>文件链接地址为<a href="https://github.com/microsoft/onnxruntime/blob/main/tools/python/remove_initializer_from_input.py">https://github.com/microsoft/onnxruntime/blob/main/tools/python/remove_initializer_from_input.py</a></p></blockquote><ol start="8"><li><p>执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python remove_initializer_from_input.py --input ./mobilenet_v1_1.0_224.onnx --output ./mobilenet_v1_1.0_224.onnx</span><br></pre></td></tr></table></figure></li><li><p>再运行基准测试(mobilenet模型)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run_local.sh onnxruntime mobilenet cpu --scenario SingleStream</span><br></pre></td></tr></table></figure><blockquote><p><code>--scenario &#123;SingleStream,MultiStream,Server,Offline&#125;</code> 选择要测试基准的场景</p></blockquote></li></ol><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250919091351616.png" alt="image-20250919091351616"></p><ol start="8"><li><p>输出结果保存在 output 文件夹中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> ./output/onnxruntime-cpu/mobilenet</span><br></pre></td></tr></table></figure></li></ol><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250919091526148.png" alt="image-20250919091526148" style="zoom:50%;" /><ol start="8"><li><p>测试结果存储在 <code>mlperf_log_summary.txt</code> 文件中，可查看该日志文件中的内容获取测试结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ./output/onnxruntime-cpu/mobilenet/mlperf_log_summary.txt</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结：</strong></p><ul><li><p>主要步骤：</p><ol><li>安装MLPerf inference库和必要的依赖</li><li>下载模型</li><li>下载数据集</li><li>执行基准测试</li></ol></li><li><p>基准测试应用程序使用 shell 脚本来简化命令行选项，用户可以选择后端、模型和设备</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">!./run_local.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">usage: ./run_local.sh [tf|onnxruntime|pytorch|tflite|tvm-onnx|tvm-pytorch|tvm-tflite] [resnet50|mobilenet|ssd-mobilenet|ssd-resnet34|retinanet] [cpu|gpu] --scenario [SingleStream|MultiStream|Offline|Server]</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">后端是 [tf|onnxruntime|pytorch|tflite|tvm-onnx|tvm-pytorch] 之一</span><br><span class="line">模型是 [resnet50|retinanet|mobilenet|ssd-mobilenet|ssd-resnet34] 之一</span><br><span class="line">设备是 [cpu|gpu] 之一</span><br><span class="line">场景是 [SingleStream|MultiStream|Offline|Server] 之一</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><ol><li>基本信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SUT name : PySUT</span><br><span class="line">Scenario : SingleStream</span><br><span class="line">Mode     : PerformanceOnly</span><br></pre></td></tr></table></figure><ul><li><strong>SUT name</strong>：System Under Test（被测系统）的名字，这里叫 <code>PySUT</code></li><li><strong>Scenario</strong>：运行场景，这里是 <strong>SingleStream</strong>（模拟一条推理请求流）</li><li><strong>Mode</strong>：运行模式，这里是 <strong>PerformanceOnly</strong>，说明只测性能，不测精度</li></ul><hr><ol start="2"><li>结果摘要</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">90.0th percentile latency (ns) : 20354752</span><br><span class="line">Result is : VALID</span><br><span class="line">  Min duration satisfied : Yes</span><br><span class="line">  Min queries satisfied : Yes</span><br><span class="line">  Early stopping satisfied: Yes</span><br></pre></td></tr></table></figure><ul><li><strong>90.0th percentile latency (ns)</strong>：90 分位延迟，也就是 90% 的请求在 20,354,752 纳秒（约 20.3 ms）以内完成</li><li><strong>Result is : VALID</strong>：说明结果合规</li><li><strong>Min duration satisfied</strong>：测试时间达到最低要求</li><li><strong>Min queries satisfied</strong>：推理请求数量达到最低要求</li><li><strong>Early stopping satisfied</strong>：启用了早停机制，判定结果有效</li></ul><hr><ol start="3"><li>Early Stopping（早停机制）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Early Stopping Result:</span><br><span class="line"> * Processed at least 64 queries (659).</span><br><span class="line"> * Would discard 47 highest latency queries.</span><br><span class="line"> * Early stopping 90.0th percentile estimate: 20960121</span><br><span class="line"> * Not enough queries processed for 99.0th percentile</span><br><span class="line">   early stopping estimate (would need to process at</span><br><span class="line">   least 662 total queries).</span><br></pre></td></tr></table></figure><ul><li><strong>Processed at least 64 queries (659)</strong>：实际处理了 659 次推理请求，超过最低 64 次的要求</li><li><strong>Would discard 47 highest latency queries</strong>：早停算法会丢掉最慢的 47 个请求，再估计分位数</li><li><strong>Early stopping 90.0th percentile estimate</strong>：估算的 90% 分位延迟是 20,960,121 ns（≈20.96 ms）</li><li><strong>Not enough queries for 99%</strong>：没有足够请求数（需要 ≥662），所以没法估算 99% 分位</li></ul><hr><ol start="4"><li>性能统计</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPS w/ loadgen overhead         : 65.75</span><br><span class="line">QPS w/o loadgen overhead        : 65.82</span><br></pre></td></tr></table></figure><ul><li><strong>QPS w&#x2F; loadgen overhead</strong>：带上 MLPerf LoadGen（负载生成器）的开销后，每秒处理 65.75 个请求</li><li><strong>QPS w&#x2F;o loadgen overhead</strong>：纯粹推理请求处理速度，每秒 65.82 个请求</li></ul><p>二者接近，说明 LoadGen 对性能影响不大。</p><hr><ol start="5"><li>延迟分布</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Min latency (ns)                : 11783153   (~11.8 ms)</span><br><span class="line">Max latency (ns)                : 26771548   (~26.8 ms)</span><br><span class="line">Mean latency (ns)               : 15193210   (~15.2 ms)</span><br><span class="line">50.00 percentile latency (ns)   : 13654569   (~13.7 ms)</span><br><span class="line">90.00 percentile latency (ns)   : 20354752   (~20.4 ms)</span><br><span class="line">95.00 percentile latency (ns)   : 21623462   (~21.6 ms)</span><br><span class="line">97.00 percentile latency (ns)   : 22250577   (~22.3 ms)</span><br><span class="line">99.00 percentile latency (ns)   : 23239962   (~23.2 ms)</span><br><span class="line">99.90 percentile latency (ns)   : 26771548   (~26.8 ms)</span><br></pre></td></tr></table></figure><ul><li><strong>Min latency</strong>：最快的一次推理 ≈ 11.8 ms</li><li><strong>Max latency</strong>：最慢的一次推理 ≈ 26.8 ms</li><li><strong>Mean latency</strong>：平均 ≈ 15.2 ms</li><li><strong>50% 分位</strong>：一半请求低于 ≈ 13.7 ms</li><li><strong>90% 分位</strong>：90% 请求低于 ≈ 20.4 ms（这是主要考核指标）</li><li><strong>95%&#x2F;97%&#x2F;99%&#x2F;99.9% 分位</strong>：高百分位延迟，反映尾部性能（越低越好）</li></ul><hr><ol start="6"><li>总结</li></ol><ul><li>系统 <strong>SingleStream 延迟中位数 ~13.7 ms，90% 分位 ~20.3 ms</strong></li><li>吞吐量大概 <strong>65 QPS</strong></li><li>结果 <strong>VALID</strong>，性能合格</li><li>延迟分布没有太大的长尾，尾延迟（99%）约 23 ms</li></ul><h3 id="2-MLPerf-Storage"><a href="#2-MLPerf-Storage" class="headerlink" title="2 MLPerf Storage"></a>2 MLPerf Storage</h3><blockquote><p>测试存储系统在训练模型时提供训练数据的速度</p></blockquote><p>测试步骤：</p><ol><li><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install python3-pip python3-venv libopenmpi-dev openmpi-common</span><br><span class="line">python3.10 -m venv ~/.venvs/mlpstorage</span><br><span class="line"><span class="built_in">source</span> ~/.venvs/mlpstorage/bin/activate</span><br><span class="line">python3 -m pip install --upgrade pip</span><br><span class="line">git <span class="built_in">clone</span> -b v2.0 https://github.com/mlcommons/storage.git</span><br><span class="line"><span class="built_in">cd</span> storage</span><br><span class="line">pip3 install -e . -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></li><li><p>计算training datasize</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250919170809174.png" alt="image-20250919170809174"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如</span></span><br><span class="line">mlpstorage training datasize -m unet3d --client-host-memory-in-gb 128 --max-accelerators 16 --num-client-hosts 2 --accelerator-type a100  --results-dir ~/mlps-results</span><br><span class="line"><span class="comment"># 计算在两台各有128 GB内存的客户端机器上运行的unet3d模型的最小数据集大小，总共模拟了8个A100加速器</span></span><br></pre></td></tr></table></figure></li><li><p>生成 training data </p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250919170859168.png" alt="image-20250919170859168"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如，其中IP1和IP2是两个节点，一个是主机节点一个是客户端节点，在主机上执行命令即可</span></span><br><span class="line">mlpstorage training datagen --hosts IP1,IP2 --model unet3d --num-processes 8 --data-dir /mnt/unet3d_data --param dataset.num_files_train=56000</span><br><span class="line"><span class="comment"># 生成56,000个unet3d工作负载的训练数据，将其放入unet3d_data目录，使用8个并行作业分布在2个节点上</span></span><br></pre></td></tr></table></figure></li><li><p>运行 Trainning 测试</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250919171547618.png" alt="image-20250919171547618"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如</span></span><br><span class="line">mlpstorage training run --hosts 10.117.61.121,10.117.61.165 --num-client-hosts 2 --client-host-memory-in-gb 64 --num-accelerators 2 --accelerator-type h100 --model unet3d  --data-dir unet3d_data --results-dir unet3d_results    --param dataset.num_files_train=400</span><br><span class="line"><span class="comment"># 使用位于 unet3d_data 目录中的数据，对 unet3d 工作负载进行基准测试，使用2个分布在2个客户端主机上的 H100 加速器（IP 地址为 10.117.61.121 和 10.117.61.165），并将结果保存到 unet3d_results 目录中</span></span><br></pre></td></tr></table></figure></li><li><p>查看测试结果</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250919171720452.png" alt="image-20250919171720452"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如，这个脚本必须在主机节点(launcher client host)上运行</span></span><br><span class="line">mlpstorage reports reportgen --out-dir ./results</span><br><span class="line"><span class="comment"># 将结果保存在results目录下</span></span><br></pre></td></tr></table></figure></li></ol><p>单机测试：使用U-Net3D模型，至少需要1张A100或H100</p><ol><li><p>计算数据大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mlpstorage training datasize --model unet3d --client-host-memory-in-gb 32 --num-client-hosts 1 --max-accelerators 1 --accelerator-type h100</span><br><span class="line"><span class="comment"># --client-host-memory-in-gb 是指主机可用内存大小</span></span><br><span class="line"><span class="comment"># --num-client-hosts 是指节点数量，因为是单机测试所以设置为1</span></span><br><span class="line"><span class="comment"># --max-accelerators 是指可用的计算卡数量</span></span><br><span class="line"><span class="comment"># --accelerator-type 可选a100或h100</span></span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250920104100306.png" alt="image-20250920104100306"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果说明</span></span><br><span class="line"><span class="comment">// 1.文件数量要求</span></span><br><span class="line">RESULT: Minimum file count dictated by <span class="number">500</span> step requirement of given accelerator count and batch size.</span><br><span class="line">RESULT: Number of training files: <span class="number">3500</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">500 step requirement: MLPerf规定训练必须至少运行500个步骤（steps）</span></span><br><span class="line"><span class="comment">3500个文件: 基于1张A100 GPU的批处理大小和500步要求计算出的最小文件数</span></span><br><span class="line"><span class="comment">这确保有足够的数据让训练跑满500个iteration</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 2.存储需求</span></span><br><span class="line">RESULT: Total disk space required <span class="keyword">for</span> training: <span class="number">477.86</span> GB</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">总共需要约478 GB的磁盘空间</span></span><br><span class="line"><span class="comment">平均每个文件大小：478 GB ÷ 3500 ≈ 140 MB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 3.数据组织</span></span><br><span class="line">RESULT: Number of training subfolders: <span class="number">0</span></span><br><span class="line"><span class="comment">/* 所有文件将放在同一个目录下，不使用子文件夹结构 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>生成训练数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mlpstorage training datagen --hosts 127.0.0.1 --num-processes 8 --model unet3d --data-dir unet3d_data --results-dir unet3d_results  --param dataset.num_files_train=500</span><br><span class="line"><span class="comment"># --num-processes 是指使用的处理器数量，越多生成的越快，用lscpu看有多少个cpu数量</span></span><br><span class="line"><span class="comment"># dataset.num_files_train 是指训练文件数量</span></span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250920103834291.png" alt="image-20250920103834291"></p></li><li><p>运行测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mlpstorage training run --hosts 127.0.0.1 --num-client-hosts 1 --client-host-memory-in-gb 32 --num-accelerators 1 --accelerator-type a100 --model unet3d  --data-dir unet3d_data --results-dir unet3d_results --param dataset.num_files_train=500 --allow-run-as-root</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250920104942998.png" alt="image-20250920104942998"><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250920105039197.png" alt="image-20250920105039197"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果说明</span></span><br><span class="line"><span class="comment">// 1. 配置验证结果</span></span><br><span class="line">ERROR: INVALID: [INVALID] Insufficient number of training <span class="title function_">files</span> </span><br><span class="line"><span class="params">(Parameter: dataset.num_files_train, Expected: &gt;= <span class="number">3500</span>, Actual: <span class="number">500</span>)</span></span><br><span class="line">- 状态: 配置无效（INVALID）</span><br><span class="line">- 原因: 文件数量不足，需要至少3500个文件</span><br><span class="line">- 影响: 结果不能用于正式MLPerf提交，但测试依然运行</span><br><span class="line"><span class="comment">// 2. 运行模式</span></span><br><span class="line">WARNING: Running the benchmark without verification <span class="keyword">for</span> open or closed configurations. </span><br><span class="line">These results are not valid <span class="keyword">for</span> submission.</span><br><span class="line">- 在非验证模式下运行</span><br><span class="line">- 结果仅用于性能测试，不符合MLPerf提交标准</span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能指标分析</span></span><br><span class="line"><span class="comment">// 1. 训练配置</span></span><br><span class="line">Max steps per epoch: 71 = <span class="number">1</span> * <span class="number">500</span> / <span class="number">7</span> / <span class="number">1</span> (samples per file * num files / batch size / comm size)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 每个epoch步数: 71步 (500个文件 ÷ 7 batch size = 71步)</span></span><br><span class="line"><span class="comment">- 运行了5个epochs: 总共355步</span></span><br><span class="line"><span class="comment">- 每步时间: 约0.637秒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 2. 关键性能指标</span></span><br><span class="line">Training Accelerator Utilization [AU] (%): <span class="number">30.48</span>%</span><br><span class="line">train_au_meet_expectation: fail</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GPU利用率 (AU - Accelerator Utilization)</span></span><br><span class="line"><span class="comment">- 平均GPU利用率: 30.48%</span></span><br><span class="line"><span class="comment">- 状态: 失败 - GPU利用率过低</span></span><br><span class="line"><span class="comment">- 问题: 存储I/O成为瓶颈，GPU等待数据</span></span><br><span class="line"><span class="comment">吞吐量表现</span></span><br><span class="line"><span class="comment">Training Throughput (samples/second): 3.30</span></span><br><span class="line"><span class="comment">Training I/O Throughput (MB/second): 461.55</span></span><br><span class="line"><span class="comment">- 训练吞吐量: 3.30 样本/秒</span></span><br><span class="line"><span class="comment">- I/O吞吐量: 461.55 MB/秒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能问题分析</span></span><br><span class="line"><span class="comment">// 1. GPU利用率低的原因</span></span><br><span class="line">Epoch <span class="number">1</span><span class="number">-5</span> AU范围: <span class="number">29.81</span>% - <span class="number">31.42</span>%</span><br><span class="line">平均计算时间: <span class="number">0.6368</span>±<span class="number">0.0034</span>秒/步</span><br><span class="line">- 存储I/O瓶颈: GPU经常等待数据加载</span><br><span class="line">- 数据管道效率低: 数据预处理跟不上GPU消耗速度</span><br><span class="line"><span class="comment">// 2. 系统资源警告</span></span><br><span class="line">[WARNING] Running DLIO with <span class="number">4</span> threads <span class="keyword">for</span> I/O but core available <span class="number">2</span> are insufficient </span><br><span class="line">and can lead to lower performance.</span><br><span class="line">- CPU核心不足: 只有<span class="number">2</span>个可用核心，但需要<span class="number">4</span>个I/O线程</span><br><span class="line">- 建议: 增加CPU资源或减少I/O线程数</span><br><span class="line"><span class="comment">// 3. 数据集问题</span></span><br><span class="line">[WARNING] Number of files <span class="keyword">for</span> training in unet3d_data/unet3d/train (<span class="number">830</span>) is more than <span class="title function_">requested</span> <span class="params">(<span class="number">500</span>)</span>. </span><br><span class="line">A subset of files will be used</span><br><span class="line">- 实际生成了830个文件，但只使用了500个</span><br><span class="line">- 建议清理多余文件或使用完整数据集</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查点和模型信息</span></span><br><span class="line">Model size: 0.000010 GB</span><br><span class="line">Total checkpoint size: 0.000010 GB</span><br><span class="line">Checkpoint save time: 0.0059 s</span><br><span class="line">Checkpoint throughput: 0.0016 GB/s</span><br><span class="line">- 模型很小（仅10KB），主要瓶颈在数据I/O</span><br><span class="line">- 检查点保存速度正常</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结果状态</span></span><br><span class="line">- ✅ 功能性成功: 训练流程正常运行</span><br><span class="line">- ✅ 数据加载正常: 数据读取和训练循环工作正常  </span><br><span class="line">- ❌ 性能不达标: GPU利用率过低 <span class="params">(<span class="number">30</span>% vs 期望的&gt;<span class="number">80</span>%)</span></span><br><span class="line">- ❌ 配置不合规: 文件数量不符合MLPerf规范</span><br><span class="line">- ❌ 资源不足: CPU资源不足影响I/O性能</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;MLPerf 学习&lt;/center&gt;&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;MLPerf 是一个业界标准的机器学习性能基准套件（benchmark suite）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;它的目标是让不同硬件</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VScode连接虚拟机</title>
    <link href="https://leeway2zc.top/2025/09/17/VScode%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://leeway2zc.top/2025/09/17/VScode%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2025-09-17T10:16:48.000Z</published>
    <updated>2025-10-11T06:45:07.918Z</updated>
    
    <content type="html"><![CDATA[<h1><center> 通过Remote-SSH插件连接虚拟机 </center></h1><p>主机环境：</p><ul><li>操作系统：WIN10专业版22H2</li><li>vscode版本：vscode2025 | 1.102.2</li><li>虚拟机软件：VirtualBox</li></ul><p>虚拟机环境：</p><ul><li>系统版本：ubuntu20.04</li><li>内核版本：5.15.0</li><li>架构：x86_64</li></ul><blockquote><p>如果不一样应该也没关系</p></blockquote><h2 id="1-虚拟机安装-SSH-服务"><a href="#1-虚拟机安装-SSH-服务" class="headerlink" title="1  虚拟机安装 SSH 服务"></a>1  虚拟机安装 SSH 服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install openssh-server</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> ssh</span><br><span class="line"><span class="built_in">sudo</span> systemctl start ssh</span><br></pre></td></tr></table></figure><blockquote><p>安装完成之后需要检查看是否启动ssh服务成功</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep ssh</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250917103002105.png" alt="image-20250917103002105"></p><blockquote><p>ssh-agent表示ssh-client启动，sshd表示ssh-server启动了，这两个是必须有的</p></blockquote><h2 id="2-配置VirtualBox"><a href="#2-配置VirtualBox" class="headerlink" title="2  配置VirtualBox"></a>2  配置VirtualBox</h2><blockquote><p>为了让vscode能连接上虚拟机，必须设置端口转发规则</p></blockquote><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250917103400917.png" alt="image-20250917103400917"></p><blockquote><p>或者修改连接方式为桥接网卡，据说这样可以直接将虚拟机和主机置于同一个局域网，但我没有试过</p></blockquote><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250917103546423.png" alt="image-20250917103546423"></p><h2 id="3-主机VScode安装Remote-SSH"><a href="#3-主机VScode安装Remote-SSH" class="headerlink" title="3  主机VScode安装Remote-SSH"></a>3  主机VScode安装Remote-SSH</h2><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250917103725725.png" alt="image-20250917103725725"></p><h2 id="4-查看虚拟机ip地址"><a href="#4-查看虚拟机ip地址" class="headerlink" title="4  查看虚拟机ip地址"></a>4  查看虚拟机ip地址</h2><blockquote><p>使用 ip a 查看</p></blockquote><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250917103932476.png" alt="image-20250917103932476"></p><blockquote><p>127.0.0.1 就是虚拟机的ip地址了，vscode使用这个来连接到虚拟机</p></blockquote><h2 id="5-vscode连接到虚拟机"><a href="#5-vscode连接到虚拟机" class="headerlink" title="5  vscode连接到虚拟机"></a>5  vscode连接到虚拟机</h2><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250917104211942.png" alt="image-20250917104211942"></p><blockquote><p>输入enter确认后就是确定操作系统以及输入密码了</p></blockquote><p>如果使用NAT模式，则输入 ssh -p 22 root@ip地址</p><h2 id="6-设置免密登录"><a href="#6-设置免密登录" class="headerlink" title="6  设置免密登录"></a>6  设置免密登录</h2><ol><li>设置虚拟机的ssh配置文件允许免密登录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用vim /etc/ssh/sshd_config 设置下面两条语句</span></span><br><span class="line">PasswordAuthentication <span class="built_in">yes</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250917111005551.png" alt="image-20250917111005551"><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250917111021391.png" alt="image-20250917111021391"></p><ol start="2"><li><p>在主机生成SSH密钥</p><ol><li>使用 git bash 输入<code>ssh-keygen -t rsa -b 4096 -C &quot;vscode-ssh&quot;</code>然后一路回车</li><li>这时 <code>C:\Users\Administrator\.ssh</code> 下面会有两个文件</li></ol><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250917111344580.png" alt="image-20250917111344580"></p><ol start="3"><li>说明密钥生成成功</li></ol></li><li><p>在虚拟机上生成SSH密钥</p></li></ol><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250917111524924.png" alt="image-20250917111524924"></p><ol start="4"><li>重启一下 ssh</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart ssh</span><br></pre></td></tr></table></figure><ol start="4"><li>在主机的 git bash 中使用 <code>ssh-copy-id</code> 上传公钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub -p 子系统端口号 name@ip</span><br></pre></td></tr></table></figure><blockquote><p>这里的name还有ip要和vscode的ssh config文件中的一致</p></blockquote><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250917111713683.png" alt="image-20250917111713683"></p><blockquote><p>这样虚拟机中就有了主机的公钥信息了</p></blockquote><ol start="5"><li>在vscode中设置本机的公钥信息</li></ol><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250917111818587.png" alt="image-20250917111818587"></p><ol start="6"><li>下次使用vscode远程连接就能直接登录了</li></ol><h2 id="7-可能出现的问题"><a href="#7-可能出现的问题" class="headerlink" title="7  可能出现的问题"></a>7  可能出现的问题</h2><h3 id="case-1：输入的密码是正确的密码但是重复提示输入密码"><a href="#case-1：输入的密码是正确的密码但是重复提示输入密码" class="headerlink" title="case 1：输入的密码是正确的密码但是重复提示输入密码"></a>case 1：输入的密码是正确的密码但是重复提示输入密码</h3><blockquote><p>这种情况是因为虚拟机中的ssh配置文件没有设置允许密码登录</p></blockquote><ol><li><p>打开ssh配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></li><li><p>确保以下两行没有被注释（前面不要有 <code>#</code>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin <span class="built_in">yes</span>         <span class="comment"># 如果你用 root 登录</span></span><br><span class="line">PasswordAuthentication <span class="built_in">yes</span>  <span class="comment"># 允许密码登录</span></span><br></pre></td></tr></table></figure></li><li><p>如果上面两行没有找到或者只找到一行，自己添加在里面也是可以的</p></li></ol><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250917104852593.png" alt="image-20250917104852593"><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250917104829435.png" alt="image-20250917104829435"></p><ol start="4"><li><p>添加完成保存并关闭vim，然后重启 SSH</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart ssh</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt; 通过Remote-SSH插件连接虚拟机 &lt;/center&gt;&lt;/h1&gt;

&lt;p&gt;主机环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统：WIN10专业版22H2&lt;/li&gt;
&lt;li&gt;vscode版本：vscode2025 | 1.102.2&lt;/li&gt;
&lt;li&gt;虚拟机</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>工作日志</title>
    <link href="https://leeway2zc.top/2025/09/02/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"/>
    <id>https://leeway2zc.top/2025/09/02/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/</id>
    <published>2025-09-02T17:10:32.000Z</published>
    <updated>2025-10-11T06:45:07.918Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f9adba68b6dcea7e8d043be4f60303b6bc46708418198a222cb5e9b69f6066fc">7c867ed6dfc672493dd19bd696750ebb08864f4f65cfa5da32f65b554b36d9f7e5c01895813b3196272a28bded8c193f9a3699192b835c24225e3a0a8eb835279e5372025472675e68f9eece081bae76ab8a830b06c56be4b75d8570c6c792090f5239528b7e68b6642794fbe5700b93be12cfd8733dfa4e1bfe69c812c5b1496be321064e41355054fb9572c22ea617d62f20a0cf607602e3fb580866dd1a2031f6b0028ce1a1fca049b85b1f9f748c8bacead1e8e87771ceb8b67c12d465128501e430a5989ae2660befa115417879aacfd6aa01606b3d8e02c74358d31d7d04c05bacb423880967fb427df46535f84696e2be85eca48d0f0afe10ccd773e91e236533f033db0f323acb950fb9bd5083b38484fc9d9eda32f6ce7182a52ed3343066942ed809e2cb3c489cc9090bcc69a2cc716180b20b79ce6dc2f0dae604f583e9b6760d7cda329435a6595a7165ac32662405d65f9a54ad26e2d24194eea6765305a592db4339e6f6dfdde442bf4157cd6f0759bb057f7cbb430a8f3b1a28e6f960010f5fcbed0ff99510a3ffe20807d61564eb0de8e4cd91bd2dcb7a31ded1dfe1ce517513f9c3683ed906c9062ceb0ac4c18a00e8f8221a4ef680db74ca21584a28350abdd318e253e3176eb0cc7bc4b6f262dbd193c63cf615347c2a806c83728aa5bc98847793c710a9212b6daab4f6aafd45eee17496b46cec7ad5de0ac9bdbf6ede315ef1c38d49d6000500bedb71e548ebfcd908dd5e8544660549e336fa177c62e15a9421736adec32e7baa00baf22ed7e196b980a6f83dc86b5f5577707601cab67f02daa98c431ea92619bd67d06b26a7eb0bf189d65779715a596af20471fa1bfea8ea34a2e9a3b952049d5e7cc26edc7bf1b237b236801fa63653155e7450980dcfdb147567c75a7d7a07ce1ddb6c9adc770191341c4724431834d35a94e4e2e9ef99f0ae0b8648a807bf201091becf6877b04c39cfd3071e6f3a5f0d9d63985e4d669753807a53f0dec5af2b39ac64c3931de5a2b004242c3ba657233d9c1eff0c9686374d4844bd768d205c2fe41ffabe20986ae8e8f98536197f727688fc0d9390162716621ccf0b1962fdc960559fad45cef3474de519e4abc72dae6579b9e86ff6be63b84d555640ad3343b4f5e9ebdb8d216ff8c1a46e5d01bd5f3402640c0f8b159436f44764fa5e13a8b55e2c3f079beaff5e3022a21c1d92855fe898eb6bf15bd2213030463f32fb52016e27f32b1851aade539cc9e7c8de1447ae93dc128a598ebf8e6293c8a78a0a09cb634753f9697b3acc86a5fb714361f889185bbdbc6726030cc78fc23bdc2fa99d183f18bec79cd63c96e38dd70d6fb42d5a6d3615d8c587cba8193731f9a11ad20ed63ed25c129f7f492eafa3d427dd77b07a4861476744f93df26349ec845de2439c6fc02d2d3519fca482ec53f5184c9f278f80b941e9a2fc42e4b5245056e0a3487c5e2718f5ba2895f98d873d3ada935998a757ad0a7ed524fb3107ca3fcb4f16a69be4f3f7ac3dd4507c8bd0da6b3d10b81086e830c5e824d9e89f7e094d1df3cfaeea128dcfa02908e5a4e9682ecc9f1f06f7cddc6c69d7c6bb65380d725d6601cd3013d9014475ce959b1ed6cca7524d5d403b8a45f3992a33f46a106f0d26c725124c1b38bb5fae1d353c37cf056ec6971cdded8afa810b9c7c10703af460a29aa4dc81d7de7a485be12f3230eac1fd3a71c0af3d7ef429badf940212bcd0ca48a548d0ddf10a90512c59352e7348ab73256bc89534f0b0b7cc061c79fcf9ae7dd0b0b037a537207f5bd1845dc05bd9109a403a5e217627985cb2688a570f552f3ffe61bf55f10f64e418c41e629dc080cdb937c1429ca1fd35052783ff2147bff6d3045d8de41e66bfef727a0ecdf2a49c481be72c1187374095052f59dbdff1343f955dd616b75255275f716bfe9a6de45155b92234941288315bd84e73fb480b29da6e01ccf36e2771ccf49753c8088dd4624184b42ea21bacc0a96ce9ae51e9b218647b56474edb96678021cb80de06d31991afe533359d70d1a25a278ac56165661087c07a85c470a00952a4f7d38340312ac87b23e526e637c46ee57a156d38270622b526b0bdad072666dac20c3ff74383f5a9f61487082a8847c24a69806a16421c0271dcdc3bafacf96fe13e800ba43bbea87ade27ae563041283ffe2d2646d20a89c83212af7d0c26b65d4819c3f1344ab2596230180048bf714f1ee40c6771b587778f62343c8bbabc356525da4a433cf5a8673289cb7b8e06d4f30df662e71f4915af8fee000fee143c60f01678dee9512526866ff8b2a5b9fd1231a7c194913a3c516834808ffd8915bf3269c4901cc7c883a3f41caa9f4a4295deb8cb7a39364d03c2fdee7e39d2c3c893c8c122ad1391f463e0ef3a949a41a503aa506dfd68d95ab0264195a7456ce4a3315d1ae39d484671270c86d4c08ab9d60a2622a917096a5687a44f94fff699d355cd4f9e9e0870ba73588bc1ccc789eb0cead6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码访问文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是一篇加密文章，输入密码才能查看</summary>
    
    
    
    
    <category term="private" scheme="https://leeway2zc.top/tags/private/"/>
    
  </entry>
  
  <entry>
    <title>博客测试</title>
    <link href="https://leeway2zc.top/2025/08/28/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/"/>
    <id>https://leeway2zc.top/2025/08/28/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/</id>
    <published>2025-08-28T16:09:54.000Z</published>
    <updated>2025-10-11T06:45:07.918Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>111</p></blockquote><p>测试思维导图导出的svg图片是否能正常显示</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.svg" alt="Linux常用命令"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[Linux RAM Disk块设备驱动流程图]</span><br><span class="line">subgraph A1 [设备注册模块 init_module]</span><br><span class="line">    B1[调用register_blkdev&lt;br&gt;参数: MY_BLOCK_MAJOR=240, MY_BLKDEV_NAME=&#x27;mybdev&#x27;]</span><br><span class="line">    B2&#123;注册成功?&#125;</span><br><span class="line">    B3[返回错误码]</span><br><span class="line">    B4[继续初始化]</span><br><span class="line">    </span><br><span class="line">    B1 --&gt; B2</span><br><span class="line">    B2 -- 是 --&gt; B4</span><br><span class="line">    B2 -- 否 --&gt; B3</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph A2 [块设备创建模块 setup_device]</span><br><span class="line">    C1[分配设备内存: vmalloc&lt;br&gt;大小: NR_SECTORS*512=64KB]</span><br><span class="line">    C2&#123;分配成功?&#125;</span><br><span class="line">    C3[返回-ENOMEM]</span><br><span class="line">    C4[初始化tag_set&lt;br&gt;ops=my_queue_ops, nr_hw_queues=1&lt;br&gt;queue_depth=128, flags=BLK_MQ_F_SHOULD_MERGE]</span><br><span class="line">    C5[调用blk_mq_alloc_tag_set]</span><br><span class="line">    C6&#123;分配成功?&#125;</span><br><span class="line">    C7[调用blk_mq_init_queue创建请求队列]</span><br><span class="line">    C8&#123;队列创建成功?&#125;</span><br><span class="line">    C9[设置队列参数: logical_block_size=512&lt;br&gt;queuedata=dev]</span><br><span class="line">    C10[调用alloc_disk分配gendisk&lt;br&gt; minors=1]</span><br><span class="line">    C11&#123;分配成功?&#125;</span><br><span class="line">    C12[设置gendisk参数: major=240, fops=my_block_ops&lt;br&gt;queue=dev-&gt;queue, private_data=dev]</span><br><span class="line">    C13[设置磁盘容量: set_capacity=128 sectors]</span><br><span class="line">    C14[调用add_disk注册磁盘]</span><br><span class="line">    C15[返回成功]</span><br><span class="line">    </span><br><span class="line">    C1 --&gt; C2</span><br><span class="line">    C2 -- 是 --&gt; C4</span><br><span class="line">    C2 -- 否 --&gt; C3</span><br><span class="line">    C4 --&gt; C5 --&gt; C6</span><br><span class="line">    C6 -- 是 --&gt; C7 --&gt; C8</span><br><span class="line">    C6 -- 否 --&gt; C3</span><br><span class="line">    C8 -- 是 --&gt; C9 --&gt; C10 --&gt; C11</span><br><span class="line">    C8 -- 否 --&gt; C3</span><br><span class="line">    C11 -- 是 --&gt; C12 --&gt; C13 --&gt; C14 --&gt; C15</span><br><span class="line">    C11 -- 否 --&gt; C3</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph A3 [请求处理模块 request_fn_proc]</span><br><span class="line">    D1[接收请求: blk_mq_queue_data]</span><br><span class="line">    D2[获取request结构体指针]</span><br><span class="line">    D3[调用blk_mq_start_request开始处理]</span><br><span class="line">    D4&#123;是否为passthrough请求?&#125;</span><br><span class="line">    D5[打印跳过信息&lt;br&gt;调用blk_mq_end_request返回IO错误]</span><br><span class="line">    D6[打印请求信息: 位置、字节数、方向]</span><br><span class="line">    D7&#123;USE_BIO_TRANSFER==1?&#125;</span><br><span class="line">    D8[调用my_xfer_request处理bio请求]</span><br><span class="line">    D9[调用my_block_transfer处理传统请求]</span><br><span class="line">    D10[调用blk_mq_end_request返回成功]</span><br><span class="line">    </span><br><span class="line">    D1 --&gt; D2 --&gt; D3 --&gt; D4</span><br><span class="line">    D4 -- 是 --&gt; D5</span><br><span class="line">    D4 -- 否 --&gt; D6 --&gt; D7</span><br><span class="line">    D7 -- 是 --&gt; D8 --&gt; D10</span><br><span class="line">    D7 -- 否 --&gt; D9 --&gt; D10</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph A4 [bio传输处理 my_xfer_request]</span><br><span class="line">    E1[遍历bio_vec segments&lt;br&gt;使用rq_for_each_segment]</span><br><span class="line">    E2[获取sector, offset, len, direction]</span><br><span class="line">    E3[调用kmap_atomic映射页面]</span><br><span class="line">    E4[调用my_block_transfer传输数据]</span><br><span class="line">    E5[调用kunmap_atomic取消映射]</span><br><span class="line">    E6&#123;还有segment?&#125;</span><br><span class="line">    E7[完成处理]</span><br><span class="line">    </span><br><span class="line">    E1 --&gt; E2 --&gt; E3 --&gt; E4 --&gt; E5 --&gt; E6</span><br><span class="line">    E6 -- 是 --&gt; E1</span><br><span class="line">    E6 -- 否 --&gt; E7</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph A5 [数据传输 my_block_transfer]</span><br><span class="line">    F1[计算偏移量: sector*512]</span><br><span class="line">    F2&#123;偏移量+长度 &gt; 设备大小?&#125;</span><br><span class="line">    F3[直接返回]</span><br><span class="line">    F4&#123;方向为写?&#125;</span><br><span class="line">    F5[memcpy: buffer → dev_data+offset]</span><br><span class="line">    F6[memcpy: dev_data+offset → buffer]</span><br><span class="line">    </span><br><span class="line">    F1 --&gt; F2</span><br><span class="line">    F2 -- 是 --&gt; F3</span><br><span class="line">    F2 -- 否 --&gt; F4</span><br><span class="line">    F4 -- 是 --&gt; F5</span><br><span class="line">    F4 -- 否 --&gt; F6</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph A6 [资源清理模块 cleanup_module]</span><br><span class="line">    G1[调用delete_block_device]</span><br><span class="line">    G2[调用unregister_blkdev&lt;br&gt;参数: MY_BLOCK_MAJOR=240, MY_BLKDEV_NAME=&#x27;mybdev&#x27;]</span><br><span class="line">    </span><br><span class="line">    G1 --&gt; G2</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph A7 [设备删除 delete_block_device]</span><br><span class="line">    H1&#123;dev-&gt;gd存在?&#125;</span><br><span class="line">    H2[调用del_gendisk和put_disk]</span><br><span class="line">    H3&#123;dev-&gt;queue存在?&#125;</span><br><span class="line">    H4[调用blk_cleanup_queue]</span><br><span class="line">    H5&#123;dev-&gt;tag_set.tags存在?&#125;</span><br><span class="line">    H6[调用blk_mq_free_tag_set]</span><br><span class="line">    H7&#123;dev-&gt;data存在?&#125;</span><br><span class="line">    H8[调用vfree释放内存]</span><br><span class="line">    </span><br><span class="line">    H1 -- 是 --&gt; H2 --&gt; H3</span><br><span class="line">    H1 -- 否 --&gt; H3</span><br><span class="line">    H3 -- 是 --&gt; H4 --&gt; H5</span><br><span class="line">    H3 -- 否 --&gt; H5</span><br><span class="line">    H5 -- 是 --&gt; H6 --&gt; H7</span><br><span class="line">    H5 -- 否 --&gt; H7</span><br><span class="line">    H7 -- 是 --&gt; H8</span><br><span class="line">    H7 -- 否 --&gt; H9[完成清理]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">B4 --&gt; C1</span><br><span class="line">C15 --&gt; A3</span><br><span class="line">D10 --&gt; A7</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;111&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试思维导图导出的svg图片是否能正常显示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>博客升级</title>
    <link href="https://leeway2zc.top/2025/08/21/%E5%8D%9A%E5%AE%A2%E5%8D%87%E7%BA%A7/"/>
    <id>https://leeway2zc.top/2025/08/21/%E5%8D%9A%E5%AE%A2%E5%8D%87%E7%BA%A7/</id>
    <published>2025-08-21T08:40:34.000Z</published>
    <updated>2025-10-11T06:45:07.918Z</updated>
    
    <content type="html"><![CDATA[<p>现在的博客还不太完善，有很多不满意的地方，例如：</p><ol><li>有个多余的…more在文章下面</li><li>显示不了访问次数</li><li>更新后日期没变动</li><li>文章下没有标签(如果解决不了，可以尝试更换主题为Indigo)</li><li>评论区有Code 403: 访问被API域名白名单拒绝，请检查你的安全域名设置</li><li>目录显示不全</li><li>页脚不显示总访问数和访客数</li><li>页眉没有图片</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现在的博客还不太完善，有很多不满意的地方，例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有个多余的…more在文章下面&lt;/li&gt;
&lt;li&gt;显示不了访问次数&lt;/li&gt;
&lt;li&gt;更新后日期没变动&lt;/li&gt;
&lt;li&gt;文章下没有标签(如果解决不了，可以尝试更换主题为Indigo)&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>FIO 测试学习文档</title>
    <link href="https://leeway2zc.top/2025/08/12/FIO-%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/"/>
    <id>https://leeway2zc.top/2025/08/12/FIO-%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</id>
    <published>2025-08-12T17:35:35.000Z</published>
    <updated>2025-10-11T06:45:07.917Z</updated>
    
    <content type="html"><![CDATA[<h1><center>FIO测试 学习文档</center></h1><h2 id="Job-File-配置文件执行-FIO-测试"><a href="#Job-File-配置文件执行-FIO-测试" class="headerlink" title="Job File 配置文件执行 FIO 测试"></a>Job File 配置文件执行 FIO 测试</h2><blockquote><p>通过编写一个ini格式的Job File来执行FIO测试，使用fio jobfile.fio完成测试</p></blockquote><h3 id="global-常用参数以及说明"><a href="#global-常用参数以及说明" class="headerlink" title="[global] 常用参数以及说明"></a>[global] 常用参数以及说明</h3><table><thead><tr><th>参数名</th><th>取值</th><th>作用说明</th></tr></thead><tbody><tr><td><code>iodepth_batch_complete</code></td><td><code>8</code></td><td>io请求过来后，能retrieve获得的最多请求数，即当io请求提交后，取出处理的io请求数</td></tr><tr><td><code>iodepth_batch</code></td><td>16</td><td>io队列请求丢过来后，积攒到16个io请求后立即提交，一般是iodepth的值</td></tr><tr><td><code>ioengine</code></td><td><code>libaio</code></td><td>使用 Linux 的异步 I&#x2F;O 引擎（libaio），适合测试真实负载环境</td></tr><tr><td><code>rw</code></td><td><code>read</code></td><td>I&#x2F;O 模式为顺序读（sequential read），用于测试读取吞吐能力，除了read还可以取值write,rw,randread,randwrite,randrw</td></tr><tr><td><code>bs</code></td><td><code>1M</code></td><td>每次 I&#x2F;O 操作的块大小为 1MB，影响数据吞吐与 IOPS</td></tr><tr><td><code>size</code></td><td><code>10G</code></td><td>每个 job 的总 I&#x2F;O 数据量上限为 10GB（如果不是基于时间模式才生效）</td></tr><tr><td><code>time_based</code></td><td><code>1</code></td><td>启用基于时间的测试模式，不以数据总量决定测试结束</td></tr><tr><td><code>runtime</code></td><td><code>30</code></td><td>测试持续时间为 30 秒</td></tr><tr><td><code>norandommap</code></td><td><code>1</code></td><td>禁用随机 I&#x2F;O 映射表，减少运行时开销，每个块可能多次读写可能不使用</td></tr><tr><td><code>randrepeat</code></td><td><code>1</code></td><td>使用固定的随机种子，每次运行能复现相同的随机序列</td></tr><tr><td><code>group_reporting</code></td><td><code>1</code></td><td>合并组内 job 的测试结果，统一输出</td></tr><tr><td><code>iodepth</code></td><td><code>8</code></td><td>设置每个 job 的 I&#x2F;O 队列深度为 8，控制并发请求数量，线程一次提出8个I&#x2F;O请求</td></tr><tr><td><code>direct</code></td><td><code>1</code></td><td>启用 Direct I&#x2F;O，跳过文件系统缓存，直接访问存储设备</td></tr><tr><td><code>numjobs</code></td><td><code>10</code></td><td>启动 10 个并发 job，提高测试负载并模拟多线程环境</td></tr><tr><td>thread</td><td>1</td><td>使用线程创建job，适合numjobs值很大的情况，模拟多应用高并发场景，但要求测试复杂度较低，需要处理同步问题，容易崩溃</td></tr><tr><td>ramp_time</td><td>30</td><td>跑每个job之前进行的预热时间</td></tr></tbody></table><h3 id="file-常用参数以及说明"><a href="#file-常用参数以及说明" class="headerlink" title="[file] 常用参数以及说明"></a>[file] 常用参数以及说明</h3><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806111305509.png" alt="image-20250806111305509"></p><table><thead><tr><th>参数名</th><th>取值</th><th>作用说明</th></tr></thead><tbody><tr><td><code>filename</code></td><td><code>/mnt/glfs/file0</code></td><td>指定测试文件的路径，这里是挂载在 <code>/mnt/glfs/</code> 下的一个文件，通常为分布式文件系统路径</td></tr></tbody></table><h2 id="命令行格式参数与说明"><a href="#命令行格式参数与说明" class="headerlink" title="命令行格式参数与说明"></a>命令行格式参数与说明</h2><blockquote><p>通过命令行参数执行 FIO 测试，便于与shell脚本结合使用</p></blockquote><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806111755997.png" alt="image-20250806111755997"></p><p>命令行参数含义如下：</p><p><code>--filename=...</code>：测试设备，这里是多个 NVMe 磁盘。</p><p><code>--direct=1</code>：绕过文件系统缓存，直接 I&#x2F;O。</p><p><code>--norandommap</code>：防止随机访问映射（提高随机性）。</p><p><code>--rw=$&#123;k&#125;</code>：I&#x2F;O 模式，传入变量 <code>k</code>，如 <code>read</code>、<code>write</code>。</p><p><code>--ioengine=libaio</code>：使用异步 I&#x2F;O 引擎。</p><p><code>--size=10G</code>：每个 job 的 I&#x2F;O 数据大小。</p><p><code>--iodepth=8</code>：每个 job 的 I&#x2F;O 队列深度。</p><p><code>--bs=$&#123;i&#125;</code>：块大小，传入变量 <code>i</code>。</p><p><code>--group_reporting</code>：报告时合并所有 job 的结果。</p><p><code>--name=test</code>：任务名。</p><p><code>--numjobs=$&#123;j&#125;</code>：并发 job 数量。</p><p><code>--runtime=$&#123;test_time&#125;</code>：测试时间（单位为秒），变量 <code>test_time</code> 应该事先定义。</p><p><code>--output=$&#123;result_file&#125;</code>：将结果输出到指定日志文件。</p><h2 id="fio-结果解读"><a href="#fio-结果解读" class="headerlink" title="fio 结果解读"></a>fio 结果解读</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/vdb -direct=1 -iodepth 32 -thread -rw=randrw -rwmixread=70 -ioengine=libaio -bs=16k -size=2G -numjobs=10 -runtime=60 -group_reporting -name=testfio</span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">testfio: (<span class="attr">g</span>=<span class="number">0</span>): rw=randrw, bs=(R) <span class="number">16.0</span>KiB-<span class="number">16.0</span>KiB, (W) <span class="number">16.0</span>KiB-<span class="number">16.0</span>KiB, (T) <span class="number">16.0</span>KiB-<span class="number">16.0</span>KiB, ioengine=libaio, iodepth=<span class="number">32</span></span><br><span class="line">...</span><br><span class="line">fio-3.7</span><br><span class="line">Starting 10 threads</span><br><span class="line">Jobs: 8 (<span class="attr">f</span>=<span class="number">8</span>): [m(<span class="number">4</span>),_(<span class="number">1</span>),m(<span class="number">3</span>),_(<span class="number">1</span>),m(<span class="number">1</span>)][<span class="number">91.9</span>%][r=<span class="number">677</span>MiB/s,w=<span class="number">291</span>MiB/s][r=<span class="number">43.4</span>k,w=<span class="number">18.6</span>k IOPS][eta <span class="number">00</span>m:<span class="number">03</span>s]</span><br><span class="line">testfio: (<span class="attr">groupid</span>=<span class="number">0</span>, jobs=<span class="number">10</span>): err= <span class="number">0</span>: pid=<span class="number">3335</span>: Thu Sep <span class="number">24</span> <span class="number">04</span>:<span class="number">25</span>:<span class="number">36</span> <span class="number">2020</span></span><br><span class="line">   read: <span class="attr">IOPS</span>=<span class="number">26.6</span>k, BW=<span class="number">416</span>MiB/s (<span class="number">436</span>MB/s)(<span class="number">13.0</span>GiB/<span class="number">34469</span>msec)</span><br><span class="line">    slat (usec): <span class="attr">min</span>=<span class="number">2</span>, max=<span class="number">375533</span>, avg=<span class="number">40.79</span>, stdev=<span class="number">1058.36</span></span><br><span class="line">    clat (usec): <span class="attr">min</span>=<span class="number">65</span>, max=<span class="number">455661</span>, avg=<span class="number">8296.62</span>, stdev=<span class="number">12218.78</span></span><br><span class="line">     lat (usec): <span class="attr">min</span>=<span class="number">76</span>, max=<span class="number">455669</span>, avg=<span class="number">8338.53</span>, stdev=<span class="number">12297.28</span></span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  <span class="attr">1.00th</span>=[   <span class="number">955</span>],  <span class="number">5.00</span>th=[  <span class="number">1745</span>], <span class="number">10.00</span>th=[  <span class="number">2245</span>], <span class="number">20.00</span>th=[  <span class="number">2868</span>],</span><br><span class="line">     | <span class="attr">30.00th</span>=[  <span class="number">3556</span>], <span class="number">40.00</span>th=[  <span class="number">4228</span>], <span class="number">50.00</span>th=[  <span class="number">4948</span>], <span class="number">60.00</span>th=[  <span class="number">5735</span>],</span><br><span class="line">     | <span class="attr">70.00th</span>=[  <span class="number">7177</span>], <span class="number">80.00</span>th=[ <span class="number">10159</span>], <span class="number">90.00</span>th=[ <span class="number">17957</span>], <span class="number">95.00</span>th=[ <span class="number">26608</span>],</span><br><span class="line">     | <span class="attr">99.00th</span>=[ <span class="number">51643</span>], <span class="number">99.50</span>th=[ <span class="number">63177</span>], <span class="number">99.90</span>th=[<span class="number">147850</span>], <span class="number">99.95</span>th=[<span class="number">189793</span>],</span><br><span class="line">     | <span class="attr">99.99th</span>=[<span class="number">287310</span>]</span><br><span class="line">   bw (  KiB/s): <span class="attr">min</span>=  <span class="number">768</span>, max=<span class="number">128736</span>, per=<span class="number">9.86</span>%, avg=<span class="number">41984.49</span>, stdev=<span class="number">31169.50</span>, samples=<span class="number">678</span></span><br><span class="line">   iops        : <span class="attr">min</span>=   <span class="number">48</span>, max= <span class="number">8046</span>, avg=<span class="number">2623.95</span>, stdev=<span class="number">1948.09</span>, samples=<span class="number">678</span></span><br><span class="line">  write: <span class="attr">IOPS</span>=<span class="number">11.4</span>k, BW=<span class="number">178</span>MiB/s (<span class="number">187</span>MB/s)(<span class="number">6149</span>MiB/<span class="number">34469</span>msec)</span><br><span class="line">    slat (usec): <span class="attr">min</span>=<span class="number">2</span>, max=<span class="number">397853</span>, avg=<span class="number">44.61</span>, stdev=<span class="number">1202.15</span></span><br><span class="line">    clat (usec): <span class="attr">min</span>=<span class="number">135</span>, max=<span class="number">455595</span>, avg=<span class="number">8322.44</span>, stdev=<span class="number">12370.30</span></span><br><span class="line">     lat (usec): <span class="attr">min</span>=<span class="number">148</span>, max=<span class="number">455605</span>, avg=<span class="number">8368.17</span>, stdev=<span class="number">12458.54</span></span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  <span class="attr">1.00th</span>=[   <span class="number">947</span>],  <span class="number">5.00</span>th=[  <span class="number">1762</span>], <span class="number">10.00</span>th=[  <span class="number">2245</span>], <span class="number">20.00</span>th=[  <span class="number">2868</span>],</span><br><span class="line">     | <span class="attr">30.00th</span>=[  <span class="number">3556</span>], <span class="number">40.00</span>th=[  <span class="number">4228</span>], <span class="number">50.00</span>th=[  <span class="number">4948</span>], <span class="number">60.00</span>th=[  <span class="number">5735</span>],</span><br><span class="line">     | <span class="attr">70.00th</span>=[  <span class="number">7177</span>], <span class="number">80.00</span>th=[ <span class="number">10290</span>], <span class="number">90.00</span>th=[ <span class="number">17957</span>], <span class="number">95.00</span>th=[ <span class="number">26870</span>],</span><br><span class="line">     | <span class="attr">99.00th</span>=[ <span class="number">51643</span>], <span class="number">99.50</span>th=[ <span class="number">62653</span>], <span class="number">99.90</span>th=[<span class="number">162530</span>], <span class="number">99.95</span>th=[<span class="number">193987</span>],</span><br><span class="line">     | <span class="attr">99.99th</span>=[<span class="number">421528</span>]</span><br><span class="line">   bw (  KiB/s): <span class="attr">min</span>=  <span class="number">288</span>, max=<span class="number">53120</span>, per=<span class="number">9.86</span>%, avg=<span class="number">18002.25</span>, stdev=<span class="number">13353.37</span>, samples=<span class="number">678</span></span><br><span class="line">   iops        : <span class="attr">min</span>=   <span class="number">18</span>, max= <span class="number">3320</span>, avg=<span class="number">1125.06</span>, stdev=<span class="number">834.58</span>, samples=<span class="number">678</span></span><br><span class="line">  lat (usec)   : <span class="attr">100</span>=<span class="number">0.01</span>%, <span class="number">250</span>=<span class="number">0.01</span>%, <span class="number">500</span>=<span class="number">0.06</span>%, <span class="number">750</span>=<span class="number">0.45</span>%, <span class="number">1000</span>=<span class="number">0.62</span>%</span><br><span class="line">  lat (msec)   : <span class="attr">2</span>=<span class="number">6.00</span>%, <span class="number">4</span>=<span class="number">30.00</span>%, <span class="number">10</span>=<span class="number">42.44</span>%, <span class="number">20</span>=<span class="number">12.12</span>%, <span class="number">50</span>=<span class="number">7.23</span>%</span><br><span class="line">  lat (msec)   : <span class="attr">100</span>=<span class="number">0.88</span>%, <span class="number">250</span>=<span class="number">0.18</span>%, <span class="number">500</span>=<span class="number">0.02</span>%</span><br><span class="line">  cpu          : <span class="attr">usr</span>=<span class="number">1.74</span>%, sys=<span class="number">3.50</span>%, ctx=<span class="number">47684</span>, majf=<span class="number">0</span>, minf=<span class="number">10</span></span><br><span class="line">  IO depths    : <span class="attr">1</span>=<span class="number">0.1</span>%, <span class="number">2</span>=<span class="number">0.1</span>%, <span class="number">4</span>=<span class="number">0.1</span>%, <span class="number">8</span>=<span class="number">0.1</span>%, <span class="number">16</span>=<span class="number">0.1</span>%, <span class="number">32</span>=<span class="number">100.0</span>%, &gt;=<span class="number">64</span>=<span class="number">0.0</span>%</span><br><span class="line">     submit    : <span class="attr">0</span>=<span class="number">0.0</span>%, <span class="number">4</span>=<span class="number">100.0</span>%, <span class="number">8</span>=<span class="number">0.0</span>%, <span class="number">16</span>=<span class="number">0.0</span>%, <span class="number">32</span>=<span class="number">0.0</span>%, <span class="number">64</span>=<span class="number">0.0</span>%, &gt;=<span class="number">64</span>=<span class="number">0.0</span>%</span><br><span class="line">     complete  : <span class="attr">0</span>=<span class="number">0.0</span>%, <span class="number">4</span>=<span class="number">100.0</span>%, <span class="number">8</span>=<span class="number">0.0</span>%, <span class="number">16</span>=<span class="number">0.0</span>%, <span class="number">32</span>=<span class="number">0.1</span>%, <span class="number">64</span>=<span class="number">0.0</span>%, &gt;=<span class="number">64</span>=<span class="number">0.0</span>%</span><br><span class="line">     issued rwts: <span class="attr">total</span>=<span class="number">917210</span>,<span class="number">393510</span>,<span class="number">0</span>,<span class="number">0</span> short=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> dropped=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">     latency   : <span class="attr">target</span>=<span class="number">0</span>, window=<span class="number">0</span>, percentile=<span class="number">100.00</span>%, depth=<span class="number">32</span></span><br><span class="line"></span><br><span class="line">Run status group 0 (all jobs):</span><br><span class="line">   READ: <span class="attr">bw</span>=<span class="number">416</span>MiB/s (<span class="number">436</span>MB/s), <span class="number">416</span>MiB/s-<span class="number">416</span>MiB/s (<span class="number">436</span>MB/s-<span class="number">436</span>MB/s), io=<span class="number">13.0</span>GiB (<span class="number">15.0</span>GB), run=<span class="number">34469</span>-<span class="number">34469</span>msec</span><br><span class="line">  WRITE: <span class="attr">bw</span>=<span class="number">178</span>MiB/s (<span class="number">187</span>MB/s), <span class="number">178</span>MiB/s-<span class="number">178</span>MiB/s (<span class="number">187</span>MB/s-<span class="number">187</span>MB/s), io=<span class="number">6149</span>MiB (<span class="number">6447</span>MB), run=<span class="number">34469</span>-<span class="number">34469</span>msec</span><br><span class="line"></span><br><span class="line">Disk stats (read/write):</span><br><span class="line">  vdb: <span class="attr">ios</span>=<span class="number">914415</span>/<span class="number">392173</span>, merge=<span class="number">0</span>/<span class="number">0</span>, ticks=<span class="number">5986235</span>/<span class="number">2577115</span>, in_queue=<span class="number">7910956</span>, util=<span class="number">65.39</span>%</span><br></pre></td></tr></table></figure><p>IOPS: 每秒的输入输出量(或读写次数)，是衡量磁盘性能的主要指标之一；</p><p>Bw: 带宽，带宽是指平均每秒读写的数据量。在同样的延时指标下，增加并发可以提高吞吐量。</p><blockquote><p>存储性能的好坏，需要IOPS、延迟、带宽三者结合来看</p></blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slat (usec): <span class="attr">min</span>=<span class="number">2</span>, max=<span class="number">397853</span>, avg=<span class="number">44.61</span>, stdev=<span class="number">1202.15</span></span><br><span class="line">clat (usec): <span class="attr">min</span>=<span class="number">135</span>, max=<span class="number">455595</span>, avg=<span class="number">8322.44</span>, stdev=<span class="number">12370.30</span></span><br><span class="line">lat (usec): <span class="attr">min</span>=<span class="number">148</span>, max=<span class="number">455605</span>, avg=<span class="number">8368.17</span>, stdev=<span class="number">12458.54</span></span><br></pre></td></tr></table></figure><p>I&#x2F;O延迟包括三种：slat，clat，lat：关系是 lat &#x3D; slat + clat；</p><ul><li>slat 表示fio submit某个I&#x2F;O的延迟；</li><li>clat 表示fio complete某个I&#x2F;O的延迟；</li><li>lat 表示从fio将请求提交给内核，再到内核完成这个I&#x2F;O为止所需要的时间；</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lat (usec)   : <span class="attr">100</span>=<span class="number">0.01</span>%, <span class="number">250</span>=<span class="number">0.01</span>%, <span class="number">500</span>=<span class="number">0.06</span>%, <span class="number">750</span>=<span class="number">0.45</span>%, <span class="number">1000</span>=<span class="number">0.62</span>%</span><br><span class="line">lat (msec)   : <span class="attr">2</span>=<span class="number">6.00</span>%, <span class="number">4</span>=<span class="number">30.00</span>%, <span class="number">10</span>=<span class="number">42.44</span>%, <span class="number">20</span>=<span class="number">12.12</span>%, <span class="number">50</span>=<span class="number">7.23</span>%</span><br><span class="line">lat (msec)   : <span class="attr">100</span>=<span class="number">0.88</span>%, <span class="number">250</span>=<span class="number">0.18</span>%, <span class="number">500</span>=<span class="number">0.02</span>%</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这组数据表明lat(latency：延迟 )的分布；有0.01%的request延迟&lt;100us，有0.01%的 100us &lt; request lat &lt; 250us，有0.06%的 250us &lt; request lat &lt; 500us，以此类推；</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpu          : <span class="attr">usr</span>=<span class="number">1.74</span>%, sys=<span class="number">3.50</span>%, ctx=<span class="number">47684</span>, majf=<span class="number">0</span>, minf=<span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>usr：表示用户空间进程；</li><li>sys：表示内核空间进程；</li><li>因为上下文切换导致的主要和次要页面失败的用户&#x2F;系统 CPU使用百分比。因为测试被配置的使用直接IO，因此有很少的页面失败：</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IO depths    : <span class="attr">1</span>=<span class="number">0.1</span>%, <span class="number">2</span>=<span class="number">0.1</span>%, <span class="number">4</span>=<span class="number">0.1</span>%, <span class="number">8</span>=<span class="number">0.1</span>%, <span class="number">16</span>=<span class="number">0.1</span>%, <span class="number">32</span>=<span class="number">0.1</span>%, &gt;=<span class="number">64</span>=<span class="number">99.9</span>%</span><br></pre></td></tr></table></figure><ul><li>iodepth设置用来控制在任何时间有多少IO分发给系统。这完全是应用方面的，意味着它和设备的IO队列做不同的事情，iodepth设置为1因此IO深度在100%的时间里一直是一个1；</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Run status group 0 (all jobs):</span><br><span class="line">   READ: <span class="attr">bw</span>=<span class="number">416</span>MiB/s (<span class="number">436</span>MB/s), <span class="number">416</span>MiB/s-<span class="number">416</span>MiB/s (<span class="number">436</span>MB/s-<span class="number">436</span>MB/s), io=<span class="number">13.0</span>GiB (<span class="number">15.0</span>GB), run=<span class="number">34469</span>-<span class="number">34469</span>msec</span><br><span class="line">  WRITE: <span class="attr">bw</span>=<span class="number">178</span>MiB/s (<span class="number">187</span>MB/s), <span class="number">178</span>MiB/s-<span class="number">178</span>MiB/s (<span class="number">187</span>MB/s-<span class="number">187</span>MB/s), io=<span class="number">6149</span>MiB (<span class="number">6447</span>MB), run=<span class="number">34469</span>-<span class="number">34469</span>msec</span><br></pre></td></tr></table></figure><ul><li>bw&#x3D;这组进程的总带宽，每个线程的带宽（设置了numjobs&gt;1这里会很明显）；</li><li>io&#x3D;这组总io大小；</li><li>线程的最小和最大时间；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Disk stats (read/write):</span><br><span class="line">  vdb: ios=914415/392173, merge=0/0, ticks=5986235/2577115, in_queue=7910956, util=65.39%</span><br></pre></td></tr></table></figure><ul><li>ios：读&#x2F;写 I&#x2F;O 次数</li><li>merge：合并的请求数</li><li>ticks：花在 I&#x2F;O 上的时间（ms）</li><li>in_queue：请求在队列里的时间（ms）</li><li>util：磁盘利用率（100% 说明磁盘一直在忙）</li></ul><h3 id="四个关键参数"><a href="#四个关键参数" class="headerlink" title="四个关键参数"></a>四个关键参数</h3><p><strong>bw（带宽）</strong></p><ul><li>顺序 I&#x2F;O 时：带宽是核心指标（HPC 大文件通常看 GB&#x2F;s）</li><li>随机 I&#x2F;O 时：带宽 + IOPS 结合看</li><li>判断合理性 → 和硬件理论上限比，例如 NVMe 单盘顺序写可达 3.5GB&#x2F;s，集群可叠加。</li></ul><p><strong>iops</strong></p><ul><li>小块随机 I&#x2F;O 的核心指标</li><li>HPC 元数据测试或数据库场景才特别看这个</li><li>和理论值比：NVMe 可到 700k IOPS（4KB 随机读），集群按并行度成倍增加。</li></ul><p><strong>延迟（slat &#x2F; clat &#x2F; lat）</strong></p><ul><li><code>slat</code> &#x3D; 提交延迟（fio 发出请求到内核调度的时间）</li><li><code>clat</code> &#x3D; 完成延迟（存储设备处理时间）</li><li><code>lat</code> &#x3D; 总延迟（两者之和）</li><li>重点看 <strong>平均值</strong> 和 <strong>高百分位数</strong>（如 99.99th）</li><li>判断合理性 → HPC 顺序 I&#x2F;O 延迟在 ms 级是正常，小块随机 NVMe 应在 100µs~1ms 内。</li></ul><p><strong>百分位延迟</strong></p><ul><li>HPC 场景需要看尾延迟（tail latency），因为并行任务很怕极端慢请求。</li><li>如果 99.99% 延迟明显高于平均值很多，说明系统在高并发下有抖动问题。</li></ul><h3 id="影响四个关键参数的主要-fio-参数"><a href="#影响四个关键参数的主要-fio-参数" class="headerlink" title="影响四个关键参数的主要 fio 参数"></a>影响四个关键参数的主要 fio 参数</h3><table><thead><tr><th>指标</th><th>关键影响参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>带宽 (bw)</strong></td><td><code>bs</code>（块大小）、<code>iodepth</code>、<code>numjobs</code>、<code>rw</code>（读写模式）</td><td>大块顺序 I&#x2F;O 通过较大 <code>bs</code> 和 <code>iodepth</code> 来提升吞吐；<code>numjobs</code> 多进程并发可叠加带宽。</td></tr><tr><td><strong>IOPS</strong></td><td><code>bs</code>、<code>iodepth</code>、<code>numjobs</code>、<code>rw</code></td><td>小块随机 I&#x2F;O 依赖更深队列 (<code>iodepth</code>) 和更多并发 (<code>numjobs</code>) 才能达到高 IOPS。</td></tr><tr><td><strong>延迟 (slat, clat, lat)</strong></td><td><code>iodepth</code>、<code>rw</code>, <code>ioengine</code></td><td><code>iodepth</code> 增大会带来排队延迟；<code>ioengine</code>（如 libaio vs sync）影响请求提交和完成方式，影响延迟。</td></tr><tr><td><strong>百分位延迟</strong></td><td>同上 + <code>iodepth_batch_complete</code>, <code>rate_iops</code>, <code>rate</code></td><td>控制批量完成和速率限制参数会影响尾延迟表现，调节请求节奏，避免峰值拥塞。</td></tr></tbody></table><h3 id="HPC-分布式存储系统中影响这四指标的因素"><a href="#HPC-分布式存储系统中影响这四指标的因素" class="headerlink" title="HPC 分布式存储系统中影响这四指标的因素"></a>HPC 分布式存储系统中影响这四指标的因素</h3><p><strong>硬件相关</strong></p><ul><li>存储介质类型：NVMe SSD、HDD、持久内存（PMEM）等带宽和延迟天差地别。</li><li>网络带宽和延迟：分布式存储中，网络往往成为瓶颈，影响总体带宽和延迟。</li><li>缓存策略：客户端缓存、服务器端缓存会降低实际 I&#x2F;O 延迟，提高带宽。</li></ul><p><strong>软件&#x2F;协议相关</strong></p><ul><li>并行访问算法：<ul><li>文件分条（striping）、条带大小（stripe size）</li><li>数据复制策略（副本数、纠删码参数）</li><li>并发调度策略（请求合并、重排）</li></ul></li><li>I&#x2F;O 协议栈：<ul><li>NFS, SMB, Lustre, BeeGFS 等协议处理效率和并发能力差异</li><li>TCP&#x2F;IP 堆栈优化，RDMA 等低延迟传输方式</li></ul></li><li>负载均衡：<ul><li>多客户端多请求分配到不同存储节点，均衡访问才能保持带宽和低延迟。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>指标</th><th>HPC存储影响因素（示例）</th><th>典型调优建议</th></tr></thead><tbody><tr><td><strong>bw</strong></td><td>硬件带宽、网络带宽、并发数、条带大小</td><td>大块顺序读写，提升 <code>bs</code>、<code>iodepth</code>、<code>numjobs</code></td></tr><tr><td><strong>iops</strong></td><td>NVMe能力、并行请求数、负载均衡</td><td>增加随机小块 <code>iodepth</code> 和 <code>numjobs</code>，用异步 <code>ioengine</code></td></tr><tr><td><strong>延迟</strong></td><td>协议栈效率、存储介质响应时间、队列长度</td><td>适当控制 <code>iodepth</code>，避免队列过深导致排队延迟</td></tr><tr><td><strong>尾延迟</strong></td><td>突发负载、缓存失效、网络抖动</td><td>使用 <code>iodepth_batch_complete</code> 等批量参数，限速避免过载</td></tr></tbody></table><h2 id="读写混合测试（randrw）的具体流程"><a href="#读写混合测试（randrw）的具体流程" class="headerlink" title="读写混合测试（randrw）的具体流程"></a>读写混合测试（<code>randrw</code>）的具体流程</h2><p>举例<code>randrw</code> + <code>iodepth=16</code> + <code>numjobs=1</code>：</p><ul><li><strong>准备阶段</strong><ul><li>fio打开目标文件 <code>/tmp/testfile</code>，文件大小100M。</li><li>根据<code>bs=4k</code>，文件被切成约 25,600 个块（100M&#x2F;4k）。</li></ul></li><li><strong>执行阶段</strong><ul><li>fio的单线程循环：<ul><li>它随机选择一个块（因为是<code>randrw</code>，随机读写）。</li><li>根据<code>rwmixread=70</code>，它有70%概率选择读，30%概率选择写。</li><li>提交一个异步I&#x2F;O请求到操作系统（通过<code>libaio</code>）。</li></ul></li><li>同时，它不会等第一个请求完成就停住，而是会继续提交请求，直到挂起的请求数达到<code>iodepth=16</code>。</li><li>当某个I&#x2F;O完成，线程会收到通知，然后提交下一个请求，保持挂起请求数量稳定在16左右。</li></ul></li><li><strong>总结</strong><ul><li>这样，fio的单线程模拟了一个深队列、高并发的I&#x2F;O负载。</li><li>存储设备能同时处理多个请求，提高吞吐量。</li><li>fio收集带宽、IOPS、延迟等指标，反映设备在这种负载下的表现。</li></ul></li></ul><h2 id="示例-FIO-代码仓库"><a href="#示例-FIO-代码仓库" class="headerlink" title="示例 FIO 代码仓库"></a>示例 FIO 代码仓库</h2><ol><li><p><a href="https://github.com/storpool/fio-tests">The StorPool FIO Test Suite</a>  这个仓库提供基于FIO的块存储性能测试脚本，专为分布式存储系统（如StorPool集群）设计，支持在HPC环境中运行多节点测试。包括预定义的测试模板，适用于随机&#x2F;顺序读写基准，适合分布式块存储的性能评估。仓库中有template目录下的.fio配置文件模板。</p></li><li><p><a href="https://github.com/axboe/fio">axboe&#x2F;fio仓库（FIO官方仓库</a>  FIO工具的官方GitHub仓库，examples&#x2F;目录下有大量通用FIO job文件示例。虽然不是专为HPC分布式存储设计，但许多配置（如SSD或NVMe测试）可以修改用于分布式环境（如在HPC集群的多节点并行运行）。例如，ssd-steady.fio适用于高性能存储基准，可结合MPI或脚本实现分布式测试。</p></li><li><p><a href="https://github.com/distributed-system-analysis/pbench">distributed-system-analysis&#x2F;pbench仓库</a>  pbench工具集中的FIO基准脚本，专为存储性能测试设计，支持HPC环境下的自动化测试，包括随机&#x2F;顺序工作负载和统计计算。适用于分布式系统，如在集群中测试文件系统I&#x2F;O。文档中描述了如何配置FIO参数以模拟HPC场景。</p></li><li><p><a href="https://github.com/ls1intum/storage-benchmarking">ls1intum&#x2F;storage-benchmarking仓库</a>  使用FIO测试容器化环境中的I&#x2F;O性能，适用于分布式存储系统（如Kubernetes集群中的HPC应用）。仓库提供预定义的job配置，适合基准测试分布式存储的性能比较。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;FIO测试 学习文档&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;Job-File-配置文件执行-FIO-测试&quot;&gt;&lt;a href=&quot;#Job-File-配置文件执行-FIO-测试&quot; class=&quot;headerlink&quot; title=&quot;Job File 配</summary>
      
    
    
    
    <category term="存储测试教程" scheme="https://leeway2zc.top/categories/%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="存储测试教程" scheme="https://leeway2zc.top/tags/%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核实验流程笔记</title>
    <link href="https://leeway2zc.top/2025/08/11/Linux%E5%86%85%E6%A0%B8%E5%AE%9E%E9%AA%8C%E6%B5%81%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://leeway2zc.top/2025/08/11/Linux%E5%86%85%E6%A0%B8%E5%AE%9E%E9%AA%8C%E6%B5%81%E7%A8%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2025-08-11T17:04:55.000Z</published>
    <updated>2025-10-11T06:45:07.918Z</updated>
    
    <content type="html"><![CDATA[<h1><center>OS2 内核编程和驱动程序开发实验</center></h1><blockquote><p>基于布加勒斯特理工大学自动控制与计算机学院计算机科学与工程系的 “操作系统2” 课程</p></blockquote><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h3><ul><li>主机：在win10上使用oracle virtualbox创建的 ubuntu 20.04 作为上位机，用于编辑模块源代码、编译模块、将模块应用到操作系统上等</li><li>虚拟机：通过Docker配置虚拟机模拟OS内核，在ubuntu 20.04上直接使用，通过脚本运行完成内核模块代码测试</li></ul><h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><blockquote><p>若提示用户没有sudo权限，使用<code>su -</code>切换到 root 用户即可，密码是虚拟机设置镜像时自己设置的，一般就是开机密码</p></blockquote><ol><li><p>在ubuntu 20.04中安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加 Docker 官方 GPG 密钥</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \</span><br><span class="line">    <span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加 Docker 软件源</span></span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> \</span></span><br><span class="line"><span class="string">  signed-by=/etc/apt/keyrings/docker.gpg] \</span></span><br><span class="line"><span class="string">  https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | \</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 更新 apt 并安装 Docker</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 启动并设置开机启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure></li><li><p>在ubuntu 20.04中安装必需软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y flex bison build-essential gcc-multilib libncurses5-dev \</span><br><span class="line">qemu-system-x86 qemu-system-arm python3 minicom</span><br></pre></td></tr></table></figure></li><li><p>创建一个脚本文件并编辑如下内容，随后运行脚本</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ $(<span class="built_in">id</span> -u) != <span class="string">&quot;0&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Please run as root (or use sudo)&quot;</span></span><br><span class="line">   <span class="built_in">exit</span> 1 </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#================================= CONSTANTS =================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"></span><br><span class="line">RED=<span class="string">&#x27;\033[0;31m&#x27;</span></span><br><span class="line">NC=<span class="string">&#x27;\033[0m&#x27;</span></span><br><span class="line"></span><br><span class="line">DEFAULT_IMAGE_NAME=<span class="string">&quot;so2/so2-assignments&quot;</span></span><br><span class="line">DEFAULT_TAG=<span class="string">&#x27;latest&#x27;</span></span><br><span class="line">DEFAULT_REGISTRY=<span class="string">&#x27;gitlab.cs.pub.ro:5050&#x27;</span></span><br><span class="line">SO2_WORKSPACE=<span class="string">&quot;/linux/tools/labs&quot;</span></span><br><span class="line">SO2_VOLUME=<span class="string">&quot;SO2_DOCKER_VOLUME&quot;</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#=================================== UTILS ===================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">LOG_INFO</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[<span class="subst">$(date +%FT%T)</span>] [INFO] <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">LOG_FATAL</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[<span class="subst">$(date +%FT%T)</span>] [<span class="variable">$&#123;RED&#125;</span>FATAL<span class="variable">$&#123;NC&#125;</span>] <span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print_help</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;local.sh docker interactive [--privileged]&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;      --privileged - run a privileged container. This allows the use of KVM (if available)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;      --allow-gui - run the docker such that it can open GUI apps&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">docker_interactive</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> full_image_name=<span class="string">&quot;<span class="variable">$&#123;DEFAULT_REGISTRY&#125;</span>/<span class="variable">$&#123;DEFAULT_IMAGE_NAME&#125;</span>:<span class="variable">$&#123;DEFAULT_TAG&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">local</span> executable=<span class="string">&quot;/bin/bash&quot;</span></span><br><span class="line">    <span class="built_in">local</span> registry=<span class="variable">$&#123;DEFAULT_REGISTRY&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> [[ <span class="variable">$#</span> -gt 0 ]]; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        --privileged)</span><br><span class="line">            privileged=--privileged</span><br><span class="line">            ;;</span><br><span class="line">        --allow-gui)</span><br><span class="line">            allow_gui=<span class="literal">true</span></span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            print_help</span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ $(docker images -q <span class="variable">$full_image_name</span> 2&gt; /dev/null) == <span class="string">&quot;&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        docker pull <span class="variable">$full_image_name</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ! docker volume inspect <span class="variable">$SO2_VOLUME</span> &gt;/dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Volume <span class="variable">$SO2_VOLUME</span> does not exist.&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Creating it&quot;</span></span><br><span class="line">docker volume create <span class="variable">$SO2_VOLUME</span></span><br><span class="line"><span class="built_in">local</span> vol_mount=$(docker inspect <span class="variable">$SO2_VOLUME</span> | grep -i mountpoin | <span class="built_in">cut</span> -d : -f2 | <span class="built_in">cut</span> -d, -f1)</span><br><span class="line"><span class="built_in">chmod</span> 777 -R <span class="variable">$vol_mount</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The /linux directory is made persistent within the <span class="variable">$SO2_VOLUME</span>:&quot;</span></span><br><span class="line">    docker inspect <span class="variable">$SO2_VOLUME</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$allow_gui</span>; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO: remove this after you change sdl to gtk in qemu-runqemu.sh</span></span><br><span class="line"> docker run <span class="variable">$privileged</span> --<span class="built_in">rm</span> -it --cap-add=NET_ADMIN --device /dev/net/tun:/dev/net/tun \</span><br><span class="line">        -v <span class="variable">$SO2_VOLUME</span>:/linux \</span><br><span class="line">        --workdir <span class="string">&quot;<span class="variable">$SO2_WORKSPACE</span>&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$full_image_name</span>&quot;</span> sed <span class="string">&quot;s+\$&#123;QEMU_DISPLAY:-\&quot;sdl\&quot;+\$&#123;QEMU_DISPLAY:-\&quot;gtk\&quot;+g&quot;</span> -i /linux/tools/labs/qemu/run-qemu.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># wsl</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cat</span> /proc/version | grep -i microsoft &amp;&gt; /dev/null ; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">export</span> DISPLAY=<span class="string">&quot;<span class="subst">$(ip r show default | awk &#x27;&#123;print $3&#125;&#x27;)</span>:0.0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$DISPLAY</span> == <span class="string">&quot;&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Error: Something unexpected happend. The environment var DISPLAY is not set. Consider setting it with&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\texport DISPLAY=&lt;dispaly&gt;&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> xauth_var=$(<span class="built_in">echo</span> $(xauth info | grep Auth | <span class="built_in">cut</span> -d: -f2))</span><br><span class="line">        docker run --privileged --<span class="built_in">rm</span> -it \</span><br><span class="line">        --net=host --<span class="built_in">env</span>=<span class="string">&quot;DISPLAY&quot;</span> --volume=<span class="string">&quot;<span class="variable">$&#123;xauth_var&#125;</span>:/root/.Xauthority:rw&quot;</span> \</span><br><span class="line">        -v <span class="variable">$SO2_VOLUME</span>:/linux \</span><br><span class="line">        --workdir <span class="string">&quot;<span class="variable">$SO2_WORKSPACE</span>&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$full_image_name</span>&quot;</span> <span class="string">&quot;<span class="variable">$executable</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        docker run <span class="variable">$privileged</span> --<span class="built_in">rm</span> -it --cap-add=NET_ADMIN --device /dev/net/tun:/dev/net/tun \</span><br><span class="line">        -v <span class="variable">$SO2_VOLUME</span>:/linux \</span><br><span class="line">        --workdir <span class="string">&quot;<span class="variable">$SO2_WORKSPACE</span>&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$full_image_name</span>&quot;</span> <span class="string">&quot;<span class="variable">$executable</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">docker_main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;interactive&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">        docker_interactive <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;docker&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    docker_main <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;-h&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;--help&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    print_help</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    print_help</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在终端运行脚本</span></span><br><span class="line"><span class="built_in">sudo</span> bash ./local.sh docker interactive --privileged</span><br></pre></td></tr></table></figure><blockquote><p>显示如下内容时说明配置成功</p></blockquote><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250804165404202.png" alt="image-20250804165404202" style="zoom:67%;" /><ol start="4"><li><p>此时根目录下会出现一个目录&#x2F;linux，这是docker虚拟挂载出来的，只有执行脚本时才会出现这个目录。&#x2F;linux&#x2F;tools&#x2F;lab是这个docker容器的工作目录，是我们编译模块和启动虚拟机的地方。</p></li><li><p>需要两个Docker内部的终端，通过tmux(终端复用器)可以得到分离的两个终端，输入指令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$tmux</span></span><br></pre></td></tr></table></figure><p>使用ctrl+b然后shift+”可以得到水平分割的两个终端，如下所示</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/docker_tmux_VM.png" style="zoom:67%;" /><blockquote><p>使用ctrl+b然后shift+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>可以得到垂直分割的两个终端，但是不方便复制代码</mtext></mrow><annotation encoding="application/x-tex">可以得到垂直分割的两个终端，但是不方便复制代码</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">可以得到垂直分割的两个终端，但是不方便复制代码</span></span></span></span>   &gt; 使用ctrl+b然后按下 [ 可以自由浏览终端界面，方便复制粘贴代码<br>使用ctrl+b然后按下 d 可以推出tmux，但这会杀死所有tmux正在执行的进程</p></blockquote></li><li><p>配置好环境以后就可以进行试验了，将上面的窗格作为虚拟机OS2，下面的窗格作为主机Docker容器，在上面的窗格中执行以下命令即可生成骨架，开始实验</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ LABS=&lt;实验名称&gt; make skels</span><br></pre></td></tr></table></figure></li><li><p>接下来要启动虚拟机，执行 <code>make console</code> 使用 <code>root</code> 用户名登陆</p></li><li><p>我们的工作流程包括：在Docker内编写模块代码，修改Make|Kbuild文件，执行make build编译得到ko模块，然后在虚拟机中通过 <code>insmod</code> 命令将其插入到虚拟机，或者通过 <code>rmmod</code> 将其移除。</p><blockquote><p>每次构建模块无需重启虚拟机，停止虚拟机的操作是 ctrl+a，然后按下 q</p></blockquote></li><li><p>重新开始课程（删除卷并重建）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm SO2_DOCKER_VOLUME</span><br><span class="line">sudo bash ./local.sh docker interactive --privileged</span><br></pre></td></tr></table></figure></li></ol><h2 id="一-内核模块"><a href="#一-内核模块" class="headerlink" title="一  内核模块"></a>一  内核模块</h2><p>实验目标</p><ul><li>创建简单的模块</li><li>描述内核模块编译的过程</li><li>展示如何在内核中使用模块</li><li>简单的内核调试方法</li></ul><h3 id="1-内核模块的使用-加载-卸载"><a href="#1-内核模块的使用-加载-卸载" class="headerlink" title="1.内核模块的使用|加载|卸载"></a>1.内核模块的使用|加载|卸载</h3><blockquote><p>使用 make console 启动虚拟机，并完成以下任务 (正确启动虚拟机以及上位机应该是下面这个界面)</p></blockquote><ol><li>使用<code>ctrl+alt+t</code>打开一个终端，确保pwd下有文件<code>local.sh</code>，使用以下代码进入docker容器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash ./local.sh docker interactive --privileged</span><br></pre></td></tr></table></figure><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/%E4%B8%8A%E4%BD%8D%E6%9C%BA.png"  /><ol start="2"><li>在docker容器中构建骨架，编写模块代码，编译模块，然后启动虚拟机安装测试模块</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在docker容器中构建骨架，在里面编写代码</span></span><br><span class="line"><span class="comment"># 实验名称一般是skel目录下的目录路径如LABS=&quot;kernel_modules/6-cmd-mod kernel_modules/8-kprobes&quot;</span></span><br><span class="line">LABS=&lt;实验名称&gt; make skels</span><br><span class="line"><span class="comment"># 编写完成后，修改Make和Kbuild文件，使用 make build 编译得到 .ko 模块文件，就可以测试了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用tmux分离出一个终端，使用make console启动虚拟机</span></span><br><span class="line">make console <span class="comment">#使用root用户名login，效果如下，此时主机名为qemu</span></span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/xv6%E8%99%9A%E6%8B%9F%E6%9C%BA.png"></p><ul><li>加载内核模块<ol><li>在 <code>~/skels/kernel_modules</code> 目录下有很多模块目录，里面存放要完成的任务</li></ol></li></ul><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806091936889.png" alt="image-20250806091936889"></p><p>​          2. 在 <code>1-2-test-mod</code> 这个目录下，执行命令 <code>insmod hello_mod.ko</code> 完成模块加载</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806092135698.png" alt="image-20250806092135698"></p><ul><li><p>列出内核模块并检查当前模块是否存在</p><ol><li><p>使用指令 <code>lsmod</code>  查看模块是否加载成功</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806092445847.png" alt="image-20250806092445847" style="zoom:67%;" /></li></ol></li><li><p>卸载内核模块</p><ol><li>使用指令 <code>rmmod hello_mod</code> (不需要后缀) 完成模块卸载</li></ol></li><li><p>使用 <strong>dmesg</strong> 命令查看加载&#x2F;卸载内核模块时显示的消息</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806092748489.png" alt="image-20250806092748489"></p></li></ul><h3 id="2-Printk"><a href="#2-Printk" class="headerlink" title="2.Printk"></a>2.Printk</h3><blockquote><p>配置系统，使消息不直接显示在串行控制台上，只能使用 <code>dmesg</code> 命令来查看</p></blockquote><ul><li><p>使用命令 <code>echo &quot;4 4 1 7&quot; &gt; /proc/sys/kernel/printk</code> 修改打印日志行为设置</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806093723057.png" alt="image-20250806093723057"></p></li><li><p>此时再加载模块就不会显示消息在串行控制台上了</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806094004426.png" alt="image-20250806094004426"></p></li></ul><h3 id="3-错误"><a href="#3-错误" class="headerlink" title="3.错误"></a>3.错误</h3><blockquote><p>生成名为 <strong>3-error-mod</strong> 的任务的框架。编译源代码并得到相应的内核模块。</p><p>为什么会出现编译错误? <strong>提示:</strong> 这个模块与前一个模块有什么不同？</p><p>修改该模块以解决这些错误的原因，然后编译和测试该模块。</p></blockquote><ul><li><p>根据TODO提示，缺少头文件 <code>&lt;linux/module.h&gt;</code>，添加后能编译成功</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806104845849.png" alt="image-20250806104845849"></p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806104917752.png" alt="image-20250806104917752"></p></li></ul><h3 id="4-子模块"><a href="#4-子模块" class="headerlink" title="4.子模块"></a>4.子模块</h3><blockquote><p>查看 <code>4-multi-mod/</code> 目录中的 C 源代码文件 <code>mod1.c</code> 和 <code>mod2.c</code>。模块 2 仅包含模块 1 使用的函数的定义。</p><p>修改 <code>Kbuild</code> 文件，从这两个 C 源文件创建 <code>multi_mod.ko</code> 模块。</p><p>编译、复制、启动虚拟机、加载和卸载内核模块。确保消息在控制台上正确显示。</p></blockquote><ol><li><p>使用 <code>LABS=&quot;kernel_modules/4-multi-mod&quot; make skels</code> 构建骨架</p></li><li><p>在目录 <code>root@ubuntu20:/linux/tools/labs/skels/kernel_modules/4-multi-mod</code> 中修改Kbuild文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> add rules to create a multi object module</span></span><br><span class="line">obj-m = multi-mod.o</span><br><span class="line">multi-mod-y = mod1.o mod2.o</span><br></pre></td></tr></table></figure></li><li><p>然后 <code>cd /linux/tools/labs</code> 进行编译 <code>make build</code></p></li><li><p>启动虚拟机，加载和卸载 <code>multi-mod.ko</code> 模块</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806161240091.png" alt="image-20250806161240091" style="zoom:67%;" /></li></ol><h3 id="5-内核-oops"><a href="#5-内核-oops" class="headerlink" title="5.内核 oops"></a>5.内核 oops</h3><blockquote><p>学习当内核模块代码有问题导致模块插入后内核发生了错误应该怎么处理</p></blockquote><ol><li><p>使用 <code>LABS=&quot;kernel_modules/5-oops-mod&quot; make skels</code>  构建骨架</p></li><li><p>在 <code>root@ubuntu20:/linux/tools/labs/skels/kernel_modules/5-oops-mod</code> 中修改Kbuild文件，为Kbuild文件添加编译标记，使得之后在安装模块时，会出现编译过程信息，提示哪里出现了问题</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> add flags to generate debug information</span></span><br><span class="line">ccflags-y += -g</span><br><span class="line"></span><br><span class="line">obj-m = oops_mod.o</span><br></pre></td></tr></table></figure></li><li><p><code>make build</code> 进行编译，然后在虚拟机中安装模块 <code>insmod oops_mod.ko</code> 会输出很长一段编译信息，其中最重要的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 告诉我们错误的原因</span><br><span class="line">BUG: kernel NULL pointer dereference, address: 00000000</span><br><span class="line"># 告诉我们这是第一个 oops（#1）</span><br><span class="line">Oops: 0002 [#1] SMP</span><br><span class="line"># 造成错误的指令的地址，它解码了指令指针 (EIP) 的值，并指出错误出现在 my_oops_init 函数中，偏移为 d个字节</span><br><span class="line">EIP: my_oops_init+0xd/0x22 [oops_mod]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oops 代码（0002）提供了有关错误类型的信息（参见 arch/x86/include/asm/trap_pf.h ）：</span><br><span class="line"></span><br><span class="line">第 0 位 == 0 表示找不到页面，1 表示保护故障</span><br><span class="line">第 1 位 == 0 表示读取，1 表示写入</span><br><span class="line">第 2 位 == 0 表示内核模式，1 表示用户模式</span><br></pre></td></tr></table></figure></li><li><p>有了 EIP 值就可以使用 address2line 来找到出错的代码出现的位置，在主机中使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addr2line -e oops_mod.ko +0xd</span><br><span class="line">/linux/tools/labs/skels/./kernel_modules/5-oops-mod/oops_mod.c:15</span><br></pre></td></tr></table></figure><p>可以知道是 oops_mod.c 的第 15 行出现了问题</p></li><li><p>由于oops_mod.ko模块加载卡住了，所以无法正常卸载，因此要重启虚拟机才能完成卸载</p><blockquote><p>模块加载必须经过init函数以及注册exit函数</p></blockquote></li><li><p>重启虚拟机之后，删去第15行代码，重新编译以及插入模块即可完成模块的加载与卸载</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250807083857615.png" alt="image-20250807083857615" style="zoom:67%;" /></li></ol><h3 id="6-模块参数"><a href="#6-模块参数" class="headerlink" title="6.模块参数"></a>6.模块参数</h3><blockquote><p>在不修改源代码 <code>cmd_mod.c</code> 的情况下，加载内核模块以显示消息 <code>Early bird gets tired</code></p></blockquote><ul><li><p>通过命令行传递参数可以修改函数变量的值从而输出特定内容</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250807090120386.png" alt="image-20250807090120386" style="zoom: 80%;" /></li><li><p>使用命令行传递参数需要源代码满足以下条件</p><ol><li><p>变量必须是模块级别的全局变量，不能是函数内部变量，必须像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *str = <span class="string">&quot;default&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>module_param()</code> 宏声明该变量为模块参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">str：变量名</span></span><br><span class="line"><span class="comment">charp：变量类型（支持 int、charp、bool、ulong 等）</span></span><br><span class="line"><span class="comment">0：权限标志位（sysfs 中的访问权限）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">module_param(str, charp, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>模块必须使用标准 <code>init</code> &#x2F; <code>exit</code> 入口函数机制，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span> &#123; ... &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span> &#123; ... &#125;</span><br><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_exit);</span><br><span class="line"># 这样，内核在执行 insmod 时会先处理模块参数，再调用 init 函数。</span><br></pre></td></tr></table></figure></li><li><p>模块参数变量声明前不能加 <code>const</code> 因为内核需要在运行时修改它</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// ❌ 无法作为 module_param</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="7-进程信息"><a href="#7-进程信息" class="headerlink" title="7.进程信息"></a>7.进程信息</h3><blockquote><p>检查名为 <strong>7-list-proc</strong> 的任务的框架。添加代码来显示当前进程的进程 ID（ <code>PID</code> ）和可执行文件名</p></blockquote><ol><li><p>执行 <code>root@ubuntu20:/linux/tools/labs/skels/kernel_modules/7-list-proc# vim list_proc.c</code> 命令，修改 <code>list_proc.c</code> 文件源代码</p></li><li><p>在注释TO DO处添加如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> add missing headers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched/signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/* TODO/2: print current process pid and its name */</span></span><br><span class="line">pr_info(<span class="string">&quot;Current process: pid = %d; comm = %s\n&quot;</span>,</span><br><span class="line">        current-&gt;pid, current-&gt;comm);</span><br><span class="line"><span class="comment">/* TODO/3: print the pid and name of all processes */</span></span><br><span class="line">pr_info(<span class="string">&quot;\nProcess list:\n\n&quot;</span>);</span><br><span class="line">for_each_process(p)</span><br><span class="line">        pr_info(<span class="string">&quot;pid = %d; comm = %s\n&quot;</span>, p-&gt;pid, p-&gt;comm);</span><br><span class="line"><span class="comment">/* TODO/2: print current process pid and name */</span></span><br><span class="line">pr_info(<span class="string">&quot;Current process: pid = %d; comm = %s\n&quot;</span>,</span><br><span class="line">        current-&gt;pid, current-&gt;comm);</span><br></pre></td></tr></table></figure></li><li><p>编译执行得到如下输出</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250807100210962.png" alt="image-20250807100210962" style="zoom:67%;" /></li><li><p>这里得查很多资料才能知道这些代码是什么意思</p></li></ol><h3 id="8-KDB"><a href="#8-KDB" class="headerlink" title="8.KDB"></a>8.KDB</h3><blockquote><p>使用KDB(Kernel Debugger)分析堆栈找出错误代码位置|使用KDB找到模块加载的地址|在一个新窗口中使用 GDB 并根据 KDB 提供的信息查看代码(没解决)</p></blockquote><ol><li><p>在虚拟机中配置KDB使用hvc0串口 <code>echo hvc0 &gt; /sys/module/kgdboc/parameters/kgdboc</code></p></li><li><p>使用 SysRq 命令启用 KDB (<strong>Ctrl + O g</strong>)，此时进入KDB调试命令行，输入Help可查看可用KDB命令，如果出现乱码例如文字显示不出来，很多乱码挤在界面右侧，是因为minicom的换行格式有问题，按下 ctrl + A 然后按下 U(或者L)，这样会将minicom从列显示模式切换到行显示模式，此时输出即可恢复正常</p><blockquote><p> kdb&gt; “这里输入go可以继续执行内核跳出kdb调试，按回车是重新输入并执行上一个命令，按↑是显示上一个命令”</p></blockquote></li><li><p>加载 <code>hello_kdb</code> 模块。该模块在写入 <code>/proc/hello_kdb_bug</code> 文件时会模拟一个错误。使用以下命令模拟错误：<code>echo 1 &gt; /proc/hello_kdb_bug</code></p></li><li><p>运行这个命令就会发生oops错误，然后会进入KDB调试命令行，使用 <code>[0]kdb&gt; bt</code> 即可分析堆栈跟踪并确定导致错误的代码，bt输出的最下面是执行的起始处(堆栈跟踪要从后往前看)，有些行前面的 ? 是指KDB不确定这个地址偏移是否计算正确，bt输出中最重要的就是kgbd_panic、kgdb_breakpoint这两个点，这表明有函数执行之后发生了错误，可以看到kgbd_panic下面的函数是panic，panic下面的函数是dummy_func1并指明它是 hello_kdb.c文件中的函数，所以错误代码就是 hello_kdb.c 中的函数 dummy_func1 有问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">notify_die+0x4d/0x90</span><br><span class="line">exc_int3+0x5c/0x140</span><br><span class="line">handle_exception+0x140/0x140</span><br><span class="line">EIP: kgdb_breakpoint+0xe/0x20                                                         </span><br><span class="line">Code: b4 26 00 00 00 00 8d b6 00 00 00 00 31 c0 c3 8d b4 26 00 00 00 00 8d b6 00 00 00 00 3e ff8</span><br><span class="line">EAX: 0000001e EBX: c40b9e00 ECX: 00000000 EDX: 00000000</span><br><span class="line">ESI: c180e898 EDI: c1badb40 EBP: c4519e2c ESP: c4519e20                               </span><br><span class="line">DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068 EFLAGS: 00000002                         </span><br><span class="line">? exc_general_protection+0x2c0/0x2c0                                                 </span><br><span class="line">? kgdb_breakpoint+0xe/0x20                                                           </span><br><span class="line">? kgdb_panic+0x4d/0x60                                                               </span><br><span class="line">panic+0xbc/0x266                                                                     </span><br><span class="line">? dummy_func1+0x8/0x8 [hello_kdb]                                                     </span><br><span class="line">dummy_func18+0xd/0xd [hello_kdb]                                                     </span><br><span class="line">dummy_func17+0x8/0x8 [hello_kdb] </span><br></pre></td></tr></table></figure></li><li><p>使用 <code>[0]kdb&gt; lsmod</code> 可以看到模块的加载地址</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250808170413340.png" alt="image-20250808170413340"></p></li></ol><h2 id="二-内核-API"><a href="#二-内核-API" class="headerlink" title="二  内核 API"></a>二  内核 API</h2><p>实验目标：</p><ul><li><p>熟悉基本的Linux内核API</p><blockquote><p>内核是一个独立运行的实体，不能调用用户空间的任何库，所以不能使用printf、malloc、free等常见的用户控件函数</p></blockquote></li><li><p>描述内存分配机制</p></li><li><p>描述锁定机制</p></li></ul><h3 id="1-Linux-内核中的内存分配"><a href="#1-Linux-内核中的内存分配" class="headerlink" title="1.Linux 内核中的内存分配"></a>1.Linux 内核中的内存分配</h3><ul><li><code>GFP_KERNEL</code> ——使用此值可能导致当前进程被挂起。因此，它不能在中断上下文中使用。</li><li><code>GFP_ATOMIC</code> ——使用此值确保 <code>kmalloc()</code> 函数不会挂起当前进程。它可以随时使用。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *mem;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="comment">// 第一个参数是字节大小，这里是4096个字节，第二个参数是分配标志</span></span><br><span class="line">    <span class="comment">// 表示这是普通内核上下文分配，允许睡眠、可以进行内存回收</span></span><br><span class="line">mem = kmalloc(<span class="number">4096</span> * <span class="keyword">sizeof</span>(*mem), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (mem == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err_mem;</span><br><span class="line"><span class="comment">// 打印mem~mem+4096内存地址区间的所有值为字母的元素</span></span><br><span class="line">pr_info(<span class="string">&quot;chars: &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isalpha</span>(mem[i]))</span><br><span class="line">printk(<span class="string">&quot;%c &quot;</span>, mem[i]);</span><br><span class="line">&#125;</span><br><span class="line">pr_info(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_mem:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">kfree(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重点在于使用kmalloc分配内存给指针，从而能使用指针指向内存空间进行引用、操作，其实kmalloc的用法和malloc差不多</p></blockquote><h3 id="2-在原子上下文中睡眠"><a href="#2-在原子上下文中睡眠" class="headerlink" title="2.在原子上下文中睡眠"></a>2.在原子上下文中睡眠</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sched_spin_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个自旋锁变量</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line"><span class="comment">// 初始化自旋锁变量</span></span><br><span class="line">spin_lock_init(&amp;lock);</span><br><span class="line"><span class="comment">// 执行锁定，此时CPU进入中断上下文进行原语操作，即此时代码运行在由自旋锁保护的临界区域当前进程不能挂起或睡眠</span></span><br><span class="line">spin_lock(&amp;lock);</span><br><span class="line"><span class="comment">// 强制使当前进程进入睡眠，因此执行insmod时会报错</span></span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">schedule_timeout(<span class="number">5</span> * HZ);</span><br><span class="line"><span class="comment">// 释放锁定，使用自旋锁时一定注意，在spin_lock和unlock这两个函数之间不能有挂机或睡眠操作代码</span></span><br><span class="line">spin_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>学习重点在于学会使用自旋锁变量以及使用时的注意要点</p></blockquote><h3 id="3-使用内核内存"><a href="#3-使用内核内存" class="headerlink" title="3.使用内核内存"></a>3.使用内核内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> &#123;</span></span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> timestamp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti1</span>, *<span class="title">ti2</span>, *<span class="title">ti3</span>, *<span class="title">ti4</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_info *<span class="title function_">task_info_alloc</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 1/5: allocated and initialize a task_info struct */</span></span><br><span class="line"><span class="comment">// 没有使用sizeof(struct task_info)，可能是为了更好的复用，这里参考1内存分配的操作即可</span></span><br><span class="line">    ti = kmalloc(<span class="keyword">sizeof</span>(*ti), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (ti == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">ti-&gt;pid = pid;</span><br><span class="line">    <span class="comment">// jiffies 是一个全局可见变量，表示当前的时间</span></span><br><span class="line">ti-&gt;timestamp = jiffies;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">memory_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* TODO 2/1: call task_info_alloc for current pid */</span></span><br><span class="line">    <span class="comment">// current是一个可以直接使用的宏，等价于struct task_struct结构体，使用current-&gt;pid查找当前进程的PID值</span></span><br><span class="line">ti1 = task_info_alloc(current-&gt;pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/1: call task_info_alloc for parent PID */</span></span><br><span class="line"><span class="comment">// 使用current-&gt;parent查找当前进程的父进程，这里纯属背板操作，无需了解为什么</span></span><br><span class="line">    ti2 = task_info_alloc(current-&gt;parent-&gt;pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/1: call task_info alloc for next process PID */</span></span><br><span class="line">    <span class="comment">// 使用next_task(current)宏找到当前进程的下一个进程</span></span><br><span class="line">ti3 = task_info_alloc(next_task(current)-&gt;pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/1: call task_info_alloc for next process of the next process */</span></span><br><span class="line">ti4 = task_info_alloc(next_task(next_task(current))-&gt;pid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">memory_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 3/4: print ti* field values */</span></span><br><span class="line">printk(<span class="string">&quot;pid: %d, timestamp: %lu\n&quot;</span>, ti1-&gt;pid, ti1-&gt;timestamp);</span><br><span class="line">printk(<span class="string">&quot;pid: %d, timestamp: %lu\n&quot;</span>, ti2-&gt;pid, ti2-&gt;timestamp);</span><br><span class="line">printk(<span class="string">&quot;pid: %d, timestamp: %lu\n&quot;</span>, ti3-&gt;pid, ti3-&gt;timestamp);</span><br><span class="line">printk(<span class="string">&quot;pid: %d, timestamp: %lu\n&quot;</span>, ti4-&gt;pid, ti4-&gt;timestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 4/4: free ti* structures */</span></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">kfree(ti1);</span><br><span class="line">kfree(ti2);</span><br><span class="line">kfree(ti3);</span><br><span class="line">kfree(ti4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重点在于学习如何给分配了内存的变量赋值以及如何使用current宏、next_task宏找到进程PID值</p></blockquote><h3 id="4-使用内核列表"><a href="#4-使用内核列表" class="headerlink" title="4.使用内核列表"></a>4.使用内核列表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> &#123;</span></span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> timestamp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_info *<span class="title function_">task_info_alloc</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">ti = kmalloc(<span class="keyword">sizeof</span>(*ti), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (ti == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">ti-&gt;pid = pid;</span><br><span class="line">ti-&gt;timestamp = jiffies;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_info_add_to_list</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 1/2: Allocate task_info and add it to list */</span></span><br><span class="line">    <span class="comment">// 分配内存给ti变量,ti是一个task_info结构体指针，描述任务信息(这里指描述当前进程的PID和时间)</span></span><br><span class="line">ti = task_info_alloc(pid);</span><br><span class="line"><span class="comment">// 将ti添加到链表，注意list_add函数的用法，传入的是ti-&gt;list的地址和head的地址(没有使用结构体指针)</span></span><br><span class="line">    list_add(&amp;ti-&gt;<span class="built_in">list</span>, &amp;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_info_add_for_current</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Add current, parent, next and next of next to the list */</span></span><br><span class="line">task_info_add_to_list(current-&gt;pid);</span><br><span class="line">task_info_add_to_list(current-&gt;parent-&gt;pid);</span><br><span class="line">task_info_add_to_list(next_task(current)-&gt;pid);</span><br><span class="line">task_info_add_to_list(next_task(next_task(current))-&gt;pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_info_print_list</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">&quot;%s: [ &quot;</span>, msg);</span><br><span class="line">list_for_each(p, &amp;head) &#123;</span><br><span class="line">ti = list_entry(p, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line">pr_info(<span class="string">&quot;(%d, %lu) &quot;</span>, ti-&gt;pid, ti-&gt;timestamp);</span><br><span class="line">&#125;</span><br><span class="line">pr_info(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_info_purge_list</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>, *<span class="title">q</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/5: Iterate over the list and delete all elements */</span></span><br><span class="line">    <span class="comment">// 这里要注意，list_for_each_safe是一个宏而不是函数，不要加分号</span></span><br><span class="line">list_for_each_safe(p, q, &amp;head) &#123;</span><br><span class="line"><span class="comment">// list_entry是找到当前链表节点相对应的原来的结构体指针变量，即映射回去</span></span><br><span class="line">        ti = list_entry(p, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line">list_del(p);</span><br><span class="line">kfree(ti);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  知识点</p><ul><li><code>list_entry(ptr, type, member)()</code> 返回列表中包含元素 <code>ptr</code> 的类型为 <code>type</code> 的结构，该结构中具有名为 <code>member</code> 的成员。</li><li><code>list_for_each(pos, head)</code> 使用 <code>pos</code> 作为游标来迭代列表。</li><li><code>list_for_each_safe(pos, n, head)</code> 使用 <code>pos</code> 作为游标，<code>n</code> 作为临时游标来迭代列表。此宏用于从列表中删除项目。</li><li><code>list_del(struct list_head *entry)()</code> 删除属于列表的 <code>entry</code> 地址处的项目。</li><li><code>list_add(struct list_head *new, struct list_head *head)()</code> 将 <code>new</code> 指针所引用的元素添加到 <code>head</code> 指针所引用的元素之后。</li><li>使用 <code>static struct list_head head;</code> 来声明一个链表头，在使用head前进行 <code>INIT_LIST_HEAD(&amp;head);</code> </li><li><code>INIT_LIST_HEAD(struct list_head *list)()</code> 用于在进行动态分配时，通过设置链表字段 <code>next</code> 和 <code>prev</code>，来初始化链表的标记。</li></ul><h3 id="5-使用内核列表进行进程处理"><a href="#5-使用内核列表进行进程处理" class="headerlink" title="5.使用内核列表进行进程处理"></a>5.使用内核列表进行进程处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel_api\5-list-full\list-full.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_info *<span class="title function_">task_info_find_pid</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 1/5: Look for pid and return task_info or NULL if not found */</span></span><br><span class="line"><span class="comment">// 找到成员pid值等于参数pid值的链表节点ti</span></span><br><span class="line">    list_for_each(p, &amp;head) &#123;</span><br><span class="line">ti = list_entry(p, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">if</span> (ti-&gt;pid == pid)</span><br><span class="line"><span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">list_full_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/2: Ensure that at least one task is not deleted */</span></span><br><span class="line"><span class="comment">// 这里要学会使用原子操作函数atomic_set，原子操作是一种不会被打断必定执行的操作，必须使用原子变量atomic_t</span></span><br><span class="line">    ti = list_entry(head.prev, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line"><span class="type">atomic_set</span>(&amp;ti-&gt;count, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">task_info_remove_expired();</span><br><span class="line">task_info_print_list(<span class="string">&quot;after removing expired&quot;</span>);</span><br><span class="line">task_info_purge_list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一些常用的原子操作函数</p></blockquote><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2025-08-13_15-12-15.png"></p><h3 id="6-同步列表工作"><a href="#6-同步列表工作" class="headerlink" title="6.同步列表工作"></a>6.同步列表工作</h3><blockquote><p>代码相关答案可以看&#x2F;templates文件夹下的代码</p></blockquote><p>  使用DEFINE_RWLOCK(lock)定义一个读写自旋锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TODO 1: you can use either a spinlock or rwlock, define it here */</span></span><br><span class="line">DEFINE_RWLOCK(lock);</span><br></pre></td></tr></table></figure><p>  读写自旋锁中的代码涉及到的共享资源会被锁定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">write_lock(&amp;lock);</span><br><span class="line"><span class="comment">/* 临界区（critical region） */</span></span><br><span class="line">ti = task_info_find_pid(pid);</span><br><span class="line"><span class="keyword">if</span> (ti != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ti-&gt;timestamp = jiffies;</span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;ti-&gt;count);</span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> Guess why this comment was added  here */</span></span><br><span class="line">    <span class="comment">/* 临界区（critical region） */</span></span><br><span class="line">    write_unlock(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TODO 1: critical section ends here */</span></span><br><span class="line"><span class="comment">/* 临界区（critical region） */</span></span><br><span class="line">write_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">read_lock(&amp;lock);</span><br><span class="line">list_for_each(p, &amp;head) &#123;</span><br><span class="line">    ti = list_entry(p, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line">    pr_info(<span class="string">&quot;(%d, %lu) &quot;</span>, ti-&gt;pid, ti-&gt;timestamp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TODO 1: Critical section ends here */</span></span><br><span class="line">read_unlock(&amp;lock);</span><br><span class="line">pr_info(<span class="string">&quot;]\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>  简单来说，就是write_lock和write_unlock之间的代码片段当cpu在执行时会进入临界区，此时如果是write_lock，那就是只有当前的进程能写，其他的进程包括CPU都不能写，如果是read_lock，那就是所有进程都不能写，但是可以一起读</p><blockquote><p>如果代码只涉及共享资源的访问就使用read_lock，如果设计对共享资源的修改就使用write_lock，在这个例子中，由于要修改ti的时间戳和计数器，所以使用了write_lock读自旋锁，而只需要打印ti的pid和时间戳，所以使用read_lock</p></blockquote><p>  关于 <code>EXPORT_SYMBOL(name);</code> ，其作用是导出模块代码中的函数或者变量给其它模块使用，当模块代码中使用了 <code>EXPORT_SYMBOL(name);</code> 那么加载此模块后，其他模块也能使用 name 代表的函数或者变量，但有几点要求</p><ol><li>函数或变量不能是静态的，即不能使用 static 关键字</li><li>必须在函数定义或变量赋值后使用</li></ol><h3 id="7-在我们的列表模块中测试模块调用"><a href="#7-在我们的列表模块中测试模块调用" class="headerlink" title="7.在我们的列表模块中测试模块调用"></a>7.在我们的列表模块中测试模块调用</h3><p>  这一节没什么好讲的，就是一个模块依赖关系，如果模块代码使用了其他模块导出的内核符号name，则这个模块依赖于其他模块，被依赖的模块由于模块引用计数refcnt&gt;0无法卸载，所以必须先卸载依赖模块，在这个例子中就是必须先卸载 list-test 模块，然后卸载 list-sync 模块</p><p>  除此以外，如果一个模块要使用其他模块导出的内核符号(函数或者变量)，必须先extern声明这个内核符号再使用，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要使用 task_info_print_list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_info_print_list</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> <span class="comment">//被依赖模块代码</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">&quot;%s: [ &quot;</span>, msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 1: Protect list, is this read or write access? */</span></span><br><span class="line">read_lock(&amp;lock);</span><br><span class="line">list_for_each(p, &amp;head) &#123;</span><br><span class="line">ti = list_entry(p, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line">pr_info(<span class="string">&quot;(%d, %lu) &quot;</span>, ti-&gt;pid, ti-&gt;timestamp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TODO 1: Critical section ends here */</span></span><br><span class="line">read_unlock(&amp;lock);</span><br><span class="line">pr_info(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(task_info_print_list);</span><br><span class="line"><span class="comment">// 必须先 extern task_info_print_list</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">task_info_print_list</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span>; <span class="comment">//依赖模块代码</span></span><br></pre></td></tr></table></figure><blockquote><p>很多东西都是背板式的，如果每个不熟悉的符号都使用LXR或cscope去查询，会消耗大量时间而且不一定能查找正确，学习linux内核编程有如学习一个语法无比复杂的语言，与其先背下来所有单词和认识所有语法后再实践练习使用，不如先开口把最常用最实用的操作记下来，让自己变得熟练，那么以前那些晦涩难懂的知识也就比较容易理解了</p></blockquote><h2 id="三-字符设备驱动程序"><a href="#三-字符设备驱动程序" class="headerlink" title="三  字符设备驱动程序"></a>三  字符设备驱动程序</h2><p> 实验目标</p><ul><li>理解字符设备驱动程序背后的概念</li><li>理解可以在字符设备上执行的各种操作</li><li>使用等待队列进行工作</li></ul><h3 id="0-简介"><a href="#0-简介" class="headerlink" title="0.简介"></a>0.简介</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct file -linux - linux-2.6.0\include\linux\fs.h</span></span><br><span class="line"><span class="comment">// struct file_operations - linux-2.6.0\include\linux\fs.h</span></span><br><span class="line"><span class="comment">// generic_ro_fops - linux-2.6.0\include\linux\fs.h</span></span><br><span class="line"><span class="comment">// vfs_read() - linux-2.6.0\fs\read_write.c</span></span><br></pre></td></tr></table></figure><h3 id="1-注册-注销"><a href="#1-注册-注销" class="headerlink" title="1.注册&#x2F;注销"></a>1.注册&#x2F;注销</h3><ol><li>使用 <strong>mknod</strong> 创建 <strong>&#x2F;dev&#x2F;so2_cdev</strong> 字符设备节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在QUMU上使用mknod命令</span></span><br><span class="line">mknod /dev/so2_cdev c <span class="number">42</span> <span class="number">0</span></span><br><span class="line"><span class="comment">// 42是主设备号，0是此设备号，均在so2_cdev.c中定义过</span></span><br></pre></td></tr></table></figure><blockquote><p>此时只是创建了一个节点，要使用register_chrdev_region完成注册才能在&#x2F;proc&#x2F;devices中看到设备文件</p></blockquote><ol start="2"><li>实现设备的注册和注销</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TODO 1/6: register char device region for MY_MAJOR and NUM_MINORS starting at MY_MINOR */</span></span><br><span class="line">err = register_chrdev_region(MKDEV(MY_MAJOR, MY_MINOR),</span><br><span class="line">NUM_MINORS, MODULE_NAME);</span><br><span class="line"><span class="comment">/* TODO 1/1: unregister char device region, for MY_MAJOR and NUM_MINORS starting at MY_MINOR */</span></span><br><span class="line">unregister_chrdev_region(MKDEV(MY_MAJOR, MY_MINOR),NUM_MINORS);</span><br></pre></td></tr></table></figure><blockquote><p>MKDEV的意思是从主设备号MY_MAJOR开始注册次设备号MY_MINOR，注册NUM_MINORS个设备文件，如果当前主设备号下的设备文件数大于NUM_MINORS，则让主设备号＋1继续注册</p></blockquote><h3 id="2-注册一个已经注册过的主设备号"><a href="#2-注册一个已经注册过的主设备号" class="headerlink" title="2.注册一个已经注册过的主设备号"></a>2.注册一个已经注册过的主设备号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 cat proc/devices 看已有的设备文件的主设备号，然后替换掉下面的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MAJOR42</span></span><br></pre></td></tr></table></figure><blockquote><p>此时会返回错误码 -16，#define EBUSY  16   &#x2F;* Device or resource busy *&#x2F; 表示是当前设备正忙无法被注册</p></blockquote><h3 id="3-打开和关闭"><a href="#3-打开和关闭" class="headerlink" title="3.打开和关闭"></a>3.打开和关闭</h3><blockquote><p>打开和关闭字符设备文件</p></blockquote><ol><li>初始化设备</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">so2_device_data</span> &#123;</span></span><br><span class="line"><span class="comment">/* TODO 2/1: add cdev member */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="comment">/* TODO 4/2: add buffer with BUFSIZ elements */</span></span><br><span class="line"><span class="type">char</span> buffer[BUFSIZ];</span><br><span class="line"><span class="type">size_t</span> size;</span><br><span class="line"><span class="comment">/* TODO 7/2: extra members for home */</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> wq;</span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"><span class="comment">/* TODO 3/1: add atomic_t access variable to keep track if file is opened */</span></span><br><span class="line"><span class="type">atomic_t</span> access;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>为当前设备文件建立一个结构体，成员有cdev结构体，该结构体用于在系统中注册字符设备(供cdev_init和cdev_add函数使用)，字符数组buffer用于读操作，size用于指示传输数据的大小，access是一个原子变量，用于计数实现阻塞其它进程干涉，这里只需要关注 TODO 2&#x2F;1</p></blockquote><ol start="2"><li>实现打开和释放函数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在结构体定义static const struct file_operations so2_fops中</span></span><br><span class="line"><span class="comment">/* TODO 2/2: add open and release functions */</span></span><br><span class="line">.open = so2_cdev_open,</span><br><span class="line">.release = so2_cdev_release,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数so2_cdev_open中</span></span><br><span class="line"><span class="comment">/* TODO 3/1: inode-&gt;i_cdev contains our cdev struct, use container_of to obtain a pointer to so2_device_data */</span></span><br><span class="line"><span class="comment">// 获取当前设备文件的结构体</span></span><br><span class="line">data = container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> so2_device_data, cdev);</span><br><span class="line"><span class="comment">// 让file指针指向当前设备文件，实现打开</span></span><br><span class="line">file-&gt;private_data = data;</span><br></pre></td></tr></table></figure><blockquote><p>container_of 宏用于从一个结构体成员的地址反推出成员所在的结构体的首地址，用法是container_of(ptr, type, member)，在这个例子中container_of 从 inode-&gt;i_cdev（一个struct cdev 类型的指针，指向so2_device_data的成员cdev）反推出它所在的 struct so2_device_data 结构体的首地址，从而获得设备的私有数据指针 data</p></blockquote><ol start="3"><li>显示消息</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用pr_info函数，与printf类似</span></span><br></pre></td></tr></table></figure><ol start="4"><li>再次读取</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 cat /dev/so2_cdev</span></span><br></pre></td></tr></table></figure><h3 id="4-访问限制"><a href="#4-访问限制" class="headerlink" title="4.访问限制"></a>4.访问限制</h3><blockquote><p>使用原子变量限制设备访问</p></blockquote><ol><li>在设备结构体中添加 <code>atomic_t</code> 变量</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在结构体so2_device_data中</span></span><br><span class="line"><span class="comment">/* TODO 3/1: add atomic_t access variable to keep track if file is opened */</span></span><br><span class="line"><span class="type">atomic_t</span> access;</span><br></pre></td></tr></table></figure><ol start="2"><li>在模块初始化时对该变量进行初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数so2_cdev_init中</span></span><br><span class="line"><span class="comment">/* TODO 3/1: set access variable to 0, use atomic_set */</span></span><br><span class="line"><span class="type">atomic_set</span>(&amp;devs[i].access, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 这里的devs是设备文件的实例化，在设备文件结构体下有定义</span></span><br><span class="line"><span class="comment">// struct so2_device_data devs[NUM_MINORS];</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在打开函数中使用该变量限制对设备的访问。我们建议使用 <code>atomic_cmpxchg()</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数so2_cdev_open中</span></span><br><span class="line"><span class="comment">/* TODO 3/2: return immediately if access is != 0, use atomic_cmpxchg */</span></span><br><span class="line"><span class="keyword">if</span> (atomic_cmpxchg(&amp;data-&gt;access, <span class="number">0</span>, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EBUSY;</span><br></pre></td></tr></table></figure><blockquote><p>static inline int atomic_cmpxchg(atomic_t *ptr, int old, int new)<br>这个函数可以在一个原子操作中检查变量的旧值并将其设为新值，在上面的例子中，它表示如果当前的access等于旧值0就将access设为1，不等于0就不修改，无论是否发生替换，atomic_cmpxchg函数都会返回ptr指向的原始值（也就是操作之前的值）。</p></blockquote><ol start="4"><li>在释放函数中重置该变量以恢复对设备的访问权限</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数so2_cdev_release中</span></span><br><span class="line"><span class="comment">/* TODO 3/1: reset access variable to 0, use atomic_set */</span></span><br><span class="line"><span class="type">atomic_set</span>(&amp;data-&gt;access, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li>模拟休眠</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在函数so2_cdev_open中</span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">schedule_timeout(1000);</span><br></pre></td></tr></table></figure><blockquote><p><code>set_current_state(TASK_INTERRUPTIBLE);</code>把当前进程（<code>current</code>）的状态设置为可中断睡眠 (<code>TASK_INTERRUPTIBLE</code>)。在这个状态下，进程会被调度器认为是“睡着的”，直到有事件唤醒它<br><code>schedule_timeout(10 * HZ);</code>把当前进程从 CPU 调度队列里移走，并设置一个定时器，在 <code>10 * HZ</code> 个 <strong>jiffies</strong> 后唤醒它。<code>HZ</code> 是内核的时钟频率（例如在 x86 上常见是 100、250 或 1000），<code>10 * HZ</code> 表示 10 秒。如果在这段时间内进程收到信号，会提前被唤醒。</p></blockquote><h3 id="5-读操作"><a href="#5-读操作" class="headerlink" title="5.读操作"></a>5.读操作</h3><blockquote><p>在驱动程序中实现读取函数</p></blockquote><ol><li>在 <code>so2_device_data</code> 结构中保持一个缓冲区，并用 <code>MESSAGE</code> 宏的值进行初始化。缓冲区的初始化在模块的 <code>init</code> 函数中完成</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct so2_device_data</span></span><br><span class="line"><span class="comment">/* TODO 4/2: add buffer with BUFSIZ elements */</span></span><br><span class="line"><span class="type">char</span> buffer[BUFSIZ];</span><br><span class="line"><span class="type">size_t</span> size;</span><br><span class="line"><span class="comment">// static int so2_cdev_init(void)</span></span><br><span class="line"><span class="comment">/*TODO 4/2: initialize buffer with MESSAGE string */</span></span><br><span class="line"><span class="built_in">memcpy</span>(devs[i].buffer, MESSAGE, <span class="keyword">sizeof</span>(MESSAGE));</span><br><span class="line">devs[i].size = <span class="keyword">sizeof</span>(MESSAGE);</span><br></pre></td></tr></table></figure><ol start="2"><li>在读取调用时，将内核空间缓冲区的内容复制到用户空间缓冲区</li></ol><p>使用 <code>copy_to_user()</code> 函数将信息从内核空间复制到用户空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static ssize_t so2_cdev_read(file, user_buffer, size, offset)</span></span><br><span class="line"><span class="comment">// 首先定义传输的字节数to_read以及获取设备文件指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">so2_device_data</span> *<span class="title">data</span> =</span></span><br><span class="line">(<span class="keyword">struct</span> so2_device_data *) file-&gt;private_data;</span><br><span class="line"><span class="type">size_t</span> to_read = (size &gt; data-&gt;size - *offset) ? (data-&gt;size - *offset) : size;</span><br><span class="line"><span class="comment">/* TODO 4/4: Copy data-&gt;buffer to user_buffer, use copy_to_user */</span></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(user_buffer, data-&gt;buffer + *offset, to_read) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">*offset += to_read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> to_read;</span><br></pre></td></tr></table></figure><blockquote><p>需要将请求的字节数size和内部缓冲区大小data-&gt;size - *offset作比较，有可能请求的字节数要超过内部缓存区大小，从而引发错误，其实这里应该是判断 size+*offset &gt; data-&gt;size，可能为了防止越界写成了减去，注意要更新偏移参数，以便于用户达到文件内部缓冲区末尾时退出</p></blockquote><blockquote><p>读取函数so2_cdev_read调用返回的值是从内核空间缓冲区传输到用户空间缓冲区的字节数</p></blockquote><h3 id="6-写操作"><a href="#6-写操作" class="headerlink" title="6.写操作"></a>6.写操作</h3><h3 id="7-ioctl-操作"><a href="#7-ioctl-操作" class="headerlink" title="7.ioctl 操作"></a>7.ioctl 操作</h3><h3 id="8-带消息的-ioctl"><a href="#8-带消息的-ioctl" class="headerlink" title="8.带消息的 ioctl"></a>8.带消息的 ioctl</h3><h3 id="9-使用等待队列的-ioctl"><a href="#9-使用等待队列的-ioctl" class="headerlink" title="9.使用等待队列的 ioctl"></a>9.使用等待队列的 ioctl</h3><h3 id="10-O-NONBLOCK-实现"><a href="#10-O-NONBLOCK-实现" class="headerlink" title="10.O_NONBLOCK 实现"></a>10.O_NONBLOCK 实现</h3><h2 id="四-I-O访问和中断"><a href="#四-I-O访问和中断" class="headerlink" title="四  I&#x2F;O访问和中断"></a>四  I&#x2F;O访问和中断</h2><p>实验目标：</p><ul><li><p>与外围设备进行通信</p></li><li><p>实现中断处理程序</p></li><li><p>将中断与进程上下文同步</p></li></ul><p>关键词：IRQ，I&#x2F;O 端口，I&#x2F;O 地址，基地址，UART，request_region，release_region，inb，outb</p><h3 id="0-简介-1"><a href="#0-简介-1" class="headerlink" title="0.简介"></a>0.简介</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//resource - /inclue/linux/ioport.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line"><span class="type">resource_size_t</span> start;</span><br><span class="line"><span class="type">resource_size_t</span> end;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> desc;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//request_region - /inclue/linux/ioport.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request_region(start,n,name)\</span></span><br><span class="line"><span class="meta">__request_region(&amp;ioport_resource, (start), (n), (name), 0)</span></span><br><span class="line"><span class="comment">//__request_region() - /kernel/resource.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *__<span class="title">request_region</span>(<span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>,</span></span><br><span class="line"><span class="class">  <span class="title">resource_size_t</span> <span class="title">start</span>, <span class="title">resource_size_t</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">  <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, <span class="title">int</span> <span class="title">flags</span>)</span></span><br><span class="line"><span class="class">//<span class="title">request_irq</span>() - /<span class="title">include</span>/<span class="title">linux</span>/<span class="title">interrupt</span>.<span class="title">h</span></span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">inline</span> <span class="title">int</span> __<span class="title">must_check</span></span></span><br><span class="line"><span class="class"><span class="title">request_irq</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">irq</span>, <span class="title">irq_handler_t</span> <span class="title">handler</span>, <span class="title">unsigned</span> <span class="title">long</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, <span class="title">void</span> *<span class="title">dev</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//request_threaded_irq() - /kernel/irq/manage.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params"> <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br></pre></td></tr></table></figure><h3 id="实现键盘驱动程序"><a href="#实现键盘驱动程序" class="headerlink" title="实现键盘驱动程序"></a>实现键盘驱动程序</h3><p>  目标是创建一个使用键盘IRQ的驱动程序，检查传入的按键代码并将其存储在缓冲区中。通过字符设备驱动程序，用户空间可以访问该缓冲区。</p><blockquote><p>如果说上一个实验字符设备驱动程序是关于如何驱动外设如何实现物理设备的读写I&#x2F;O操作，那么这个实验是关于如何通过中断来操控外设</p></blockquote><h3 id="1-请求I-O端口"><a href="#1-请求I-O端口" class="headerlink" title="1.请求I&#x2F;O端口"></a>1.请求I&#x2F;O端口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 kbd_init 函数中</span></span><br><span class="line"><span class="comment">/* TODO 1/8: request the keyboard I/O ports */</span></span><br><span class="line"><span class="keyword">if</span> (request_region(I8042_DATA_REG+<span class="number">1</span>, <span class="number">1</span>, MODULE_NAME) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    err = -EBUSY;</span><br><span class="line">    <span class="keyword">goto</span> out_unregister;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (request_region(I8042_STATUS_REG+<span class="number">1</span>, <span class="number">1</span>, MODULE_NAME) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    err = -EBUSY;</span><br><span class="line">    <span class="keyword">goto</span> out_release_region;</span><br><span class="line">&#125;</span><br><span class="line">out_release_regions:</span><br><span class="line">release_region(I8042_STATUS_REG+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">out_release_region:</span><br><span class="line">release_region(I8042_DATA_REG+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">out_unregister:</span><br><span class="line">unregister_chrdev_region(MKDEV(KBD_MAJOR, KBD_MINOR),</span><br><span class="line"> KBD_NR_MINORS);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"><span class="comment">// 在 kbd_exit 函数中</span></span><br><span class="line"><span class="comment">/* TODO 1/2: release keyboard I/O ports */</span></span><br><span class="line">release_region(I8042_STATUS_REG+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">release_region(I8042_DATA_REG+<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><blockquote><p>请求 I&#x2F;O 端口后，可以在&#x2F;proc&#x2F;ioports中找到自己的端口号<br>如果遇到报错提示-EBUSY，可能是因为没有执行release_region或者unregister_chrdev_region，需要在init函数开头写release_region或者unregister_chrdev_region然后重新插入模块</p></blockquote><h3 id="2-中断处理例程"><a href="#2-中断处理例程" class="headerlink" title="2.中断处理例程"></a>2.中断处理例程</h3><blockquote><p>所谓中断处理例程，就是中断发生时会执行的代码功能函数，一般是xxx_interrupt_handler()</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己写的一个函数 kbd_interrupt_handle 注意类型是 irqreturn_t</span></span><br><span class="line"><span class="comment">/* TODO 2/27: implement interrupt handler */</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">kbd_interrupt_handle</span><span class="params">(<span class="type">int</span> irq_no, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 当中断发生时输出</span></span><br><span class="line">    pr_info(<span class="string">&quot;You just pressed A key!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* TODO 3: read the scancode */</span></span><br><span class="line"><span class="comment">/* TODO 3/2: interpret the scancode */</span></span><br><span class="line"><span class="comment">/* TODO 3/2: display information about the keystrokes */</span></span><br><span class="line"><span class="comment">/* TODO 3/7: store ASCII key to buffer */</span></span><br><span class="line"><span class="keyword">return</span> IRQ_NONE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 kbd_init 函数中, 注册中断处理例程，使用 request_irq</span></span><br><span class="line"><span class="comment">/* TODO 2/7: Register IRQ handler for keyboard IRQ (IRQ 1). */</span></span><br><span class="line">err = request_irq(I8042_KBD_IRQ,</span><br><span class="line">        kbd_interrupt_handle,</span><br><span class="line">        IRQF_SHARED, MODULE_NAME, &amp;devs[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">    pr_err(<span class="string">&quot;request_irq failed: %d\n&quot;</span>, err);</span><br><span class="line">    <span class="keyword">goto</span> out_release_regions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用request_irq注册中断例程后，能在&#x2F;proc&#x2F;interrupts中看到自己的中断程序 kbd</p></blockquote><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817211748806.png" alt="image-20250817211748806"></p><blockquote><p>按照“注意”的提示使用 <code>QEMU_DISPLAY=gtk make boot</code> 是无法启动成功的，因为QEMU中的Makefile指定需要下载yotco2.4版本的镜像系统，但是链接早就失效了，必须修改QEMU中的Makefile的yotco版本号为4.1才能正常下载系统镜像从而启动，如下图所示修改，如果下载的很慢或者还是下载不了，可能需要使用代理，使用clash-verge的TUN模式可以让虚拟机走代理</p></blockquote><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817211057473.png" alt="image-20250817211057473" style="zoom:67%;" /><blockquote><p>没有报错之后应该能正常启动系统，如下所示</p></blockquote><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817211345350.png" alt="image-20250817211345350" style="zoom:67%;" /><blockquote><p>但此时要退出来，因为没有在Docker内执行 <code>make copy</code>，执行前系统内是没有 <code>skels</code> 这个文件夹的</p></blockquote><p>在QEMU中按下键盘按键会触发中断例程程序，使用dmesg可以看到：</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817211707033.png" alt="image-20250817211707033" style="zoom: 80%;" /><h3 id="3-将-ASCII-键存储到缓冲区"><a href="#3-将-ASCII-键存储到缓冲区" class="headerlink" title="3.将 ASCII 键存储到缓冲区"></a>3.将 ASCII 键存储到缓冲区</h3><h4 id="读取数据存储器"><a href="#读取数据存储器" class="headerlink" title="读取数据存储器"></a>读取数据存储器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用函数 inb 读取 I/O 端口的数据，只读一个字符大小的数据(1 Byte)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u8 <span class="title function_">i8042_read_data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 val;</span><br><span class="line"><span class="comment">/* TODO 3: Read DATA register (8 bits). */</span></span><br><span class="line">val = inb(I8042_DATA_REG);  <span class="comment">// 此时读取的是寄存器中的扫描码，还需要转换才能成为ASCII码</span></span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 kbd_interrupt_handle 函数中</span></span><br><span class="line"><span class="comment">/* TODO 3: read the scancode */</span></span><br><span class="line">scancode = i8042_read_data();</span><br></pre></td></tr></table></figure><h4 id="解释扫描码"><a href="#解释扫描码" class="headerlink" title="解释扫描码"></a>解释扫描码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 kbd_interrupt_handle 函数中</span></span><br><span class="line"><span class="comment">/* TODO 3/2: interpret the scancode */</span></span><br><span class="line">pressed = is_key_press(scancode); <span class="comment">// 此函数能判断扫描码是按下键还是释放键</span></span><br><span class="line">ch = get_ascii(scancode);  <span class="comment">// 此函数能将扫描码转换为ASCII码</span></span><br><span class="line"><span class="comment">/* TODO 3/2: display information about the keystrokes */</span></span><br><span class="line">pr_info(<span class="string">&quot;IRQ %d: scancode=0x%x (%u) pressed=%d ch=%c\n&quot;</span>,</span><br><span class="line">    irq_no, scancode, scancode, pressed, ch);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_ascii</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> scancode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *row1 = <span class="string">&quot;1234567890&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *row2 = <span class="string">&quot;qwertyuiop&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *row3 = <span class="string">&quot;asdfghjkl&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *row4 = <span class="string">&quot;zxcvbnm&quot;</span>;</span><br><span class="line"></span><br><span class="line">scancode &amp;= ~SCANCODE_RELEASED_MASK;</span><br><span class="line"><span class="keyword">if</span> (scancode &gt;= <span class="number">0x02</span> &amp;&amp; scancode &lt;= <span class="number">0x0b</span>)</span><br><span class="line"><span class="keyword">return</span> *(row1 + scancode - <span class="number">0x02</span>);</span><br><span class="line"><span class="keyword">if</span> (scancode &gt;= <span class="number">0x10</span> &amp;&amp; scancode &lt;= <span class="number">0x19</span>)</span><br><span class="line"><span class="keyword">return</span> *(row2 + scancode - <span class="number">0x10</span>);</span><br><span class="line"><span class="keyword">if</span> (scancode &gt;= <span class="number">0x1e</span> &amp;&amp; scancode &lt;= <span class="number">0x26</span>)</span><br><span class="line"><span class="keyword">return</span> *(row3 + scancode - <span class="number">0x1e</span>);</span><br><span class="line"><span class="keyword">if</span> (scancode &gt;= <span class="number">0x2c</span> &amp;&amp; scancode &lt;= <span class="number">0x32</span>)</span><br><span class="line"><span class="keyword">return</span> *(row4 + scancode - <span class="number">0x2c</span>);</span><br><span class="line"><span class="keyword">if</span> (scancode == <span class="number">0x39</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (scancode == <span class="number">0x1c</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_press</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> scancode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(scancode &amp; SCANCODE_RELEASED_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将字符存储到缓冲区"><a href="#将字符存储到缓冲区" class="headerlink" title="将字符存储到缓冲区"></a>将字符存储到缓冲区</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 kbd_interrupt_handle 函数中</span></span><br><span class="line"><span class="comment">/* TODO 3/7: store ASCII key to buffer */</span></span><br><span class="line"><span class="keyword">if</span> (pressed) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kbd</span> *<span class="title">data</span> =</span> (<span class="keyword">struct</span> kbd *)dev_id; <span class="comment">// 获取设备结构体</span></span><br><span class="line"><span class="comment">// 使用自旋锁，确保共享资源缓冲区是同步访问的，需要先在init函数中初始化</span></span><br><span class="line">    spin_lock(&amp;data-&gt;lock); </span><br><span class="line">    <span class="comment">// 读取字符，将 I/O 端口的字符读取到设备缓冲区中，以便于用户空间读取</span></span><br><span class="line">    put_char(data, ch);</span><br><span class="line">    spin_unlock(&amp;data-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 kbd_init 函数中</span></span><br><span class="line"><span class="comment">/* TODO 3: initialize spinlock */</span></span><br><span class="line">spin_lock_init(&amp;devs[<span class="number">0</span>].lock);</span><br><span class="line"><span class="comment">// put_char 函数定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_char</span><span class="params">(<span class="keyword">struct</span> kbd *data, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果缓冲区中的字符数量大于缓冲区的容量，则丢弃当前读取的字符</span></span><br><span class="line"><span class="keyword">if</span> (data-&gt;count &gt;= BUFFER_SIZE)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// put-&gt;idx指向缓冲区下一个写入位置的索引</span></span><br><span class="line">data-&gt;buf[data-&gt;put_idx] = c;</span><br><span class="line">    <span class="comment">// 更新索引</span></span><br><span class="line">data-&gt;put_idx = (data-&gt;put_idx + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">data-&gt;count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-读取缓冲区"><a href="#4-读取缓冲区" class="headerlink" title="4.读取缓冲区"></a>4.读取缓冲区</h3><blockquote><p>为了访问键盘记录器的数据，我们需要将其发送到用户空间。我们将使用 <em>&#x2F;dev&#x2F;kbd</em> 字符设备来实现这一点。当从该设备读取数据时，我们将从内核空间的缓冲区中获取按键数据</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 get_char() 从缓冲区中读取一个字符，并使用 put_user() 将其存储到用户缓冲区中</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">get_char</span><span class="params">(<span class="type">char</span> *c, <span class="keyword">struct</span> kbd *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* TODO 4/6: get char from buffer; update count and get_idx */</span></span><br><span class="line"><span class="keyword">if</span> (data-&gt;count &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果缓冲区中的字符数量大于0，则读取字符</span></span><br><span class="line">*c = data-&gt;buf[data-&gt;get_idx];</span><br><span class="line">data-&gt;get_idx = (data-&gt;get_idx + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">data-&gt;count--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 kbd_read 函数中</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">kbd_read</span><span class="params">(<span class="keyword">struct</span> file *file,  <span class="type">char</span> __user *user_buffer,</span></span><br><span class="line"><span class="params"><span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kbd</span> *<span class="title">data</span> =</span> (<span class="keyword">struct</span> kbd *) file-&gt;private_data;</span><br><span class="line"><span class="type">size_t</span> read = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* TODO 4/18: read data from buffer */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">bool</span> more = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (size--) &#123;</span><br><span class="line">        <span class="comment">// 在读取函数中，使用 spin_lock_irqsave() 和 spin_unlock_irqrestore() 进行加锁</span></span><br><span class="line">spin_lock_irqsave(&amp;data-&gt;lock, flags);</span><br><span class="line">more = get_char(&amp;ch, data);</span><br><span class="line"><span class="comment">// 原子上下文中不允许访问用户空间</span></span><br><span class="line">        spin_unlock_irqrestore(&amp;data-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (!more)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 关键的一句在这，使用put_user函数将字符存储到用户缓存区</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(ch, user_buffer++))  <span class="comment">// 参数是ch(字符)和user_buffer(传入的用户缓冲区)</span></span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">read++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了测试是否成功实现了从键盘这一物理设备驱动程序的中断中实现数据读取，应该先使用<code>mknod</code>创建<code>/dev/kbd</code>字符设备驱动程序，正如在<code>kbd_init</code>函数中注册字符驱动设备文件的函数 <code>register_chrdev_region</code> 中的参数一样，要使用同样的<code>KBD_MAJOR</code>和<code>MODULE_NAME</code>以及<code>KBD_MINOR</code>，也就是 <code>42</code>、<code>kbd</code>、<code>0</code>，使用命令 <code>mknod /dev/kbd c 42 0</code> 在QEMU中创建设备驱动文件kbd，构建复制和启动QEMU，加载模块后，能在<code>/proc/devices</code>中看到自己的设备文件<code>42 kbd</code>，最后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 cat /dev/kbd 读取缓冲区中的数据吧，因为 cat 是用户空间使用的命令，因此此时应该显示</span></span><br></pre></td></tr></table></figure><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817214906662.png" alt="image-20250817214906662" style="zoom: 80%;" /><h3 id="5-重置缓冲区"><a href="#5-重置缓冲区" class="headerlink" title="5.重置缓冲区"></a>5.重置缓冲区</h3><blockquote><p>使用 <code>echo &quot;clear&quot; &gt; /dev/kbd</code> 将数据写入设备</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 reset_buffer</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">reset_buffer</span><span class="params">(<span class="keyword">struct</span> kbd *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* TODO 5/3: reset count, put_idx, get_idx */</span></span><br><span class="line">data-&gt;count = <span class="number">0</span>;</span><br><span class="line">data-&gt;put_idx = <span class="number">0</span>;</span><br><span class="line">data-&gt;get_idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当写操作发生时，应该执行...</span></span><br><span class="line"><span class="comment">/* TODO 5/12: add write operation and reset the buffer */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">kbd_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *user_buffer,</span></span><br><span class="line"><span class="params"> <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kbd</span> *<span class="title">data</span> =</span> (<span class="keyword">struct</span> kbd *) file-&gt;private_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;data-&gt;lock, flags);</span><br><span class="line">reset_buffer(data);</span><br><span class="line">spin_unlock_irqrestore(&amp;data-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加写操作</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">kbd_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = kbd_open,</span><br><span class="line">.release = kbd_release,</span><br><span class="line">.read = kbd_read,</span><br><span class="line"><span class="comment">/* TODO 5: add write operation */</span></span><br><span class="line">.write = kbd_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时执行命令 <code>echo &quot;clear&quot; &gt; /dev/kbd</code> 会让缓冲区清空</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817215433645.png" alt="image-20250817215433645" style="zoom:80%;" /><h2 id="五-延迟工作"><a href="#五-延迟工作" class="headerlink" title="五  延迟工作"></a>五  延迟工作</h2><p>实验目标</p><ul><li>理解延迟工作（即在稍后时间执行的代码）</li><li>实现使用延迟工作的常见任务</li><li>理解延迟工作的同步特性</li></ul><blockquote><p>关键词：softirq、tasklet、struct tasklet_struct、下半部处理程序、jiffies、HZ、timer、struct timer_list、spin_lock_bh、spin_unlock_bh、workqueue、struct work_struct、内核线程、events&#x2F;x</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 LABS=<span class="string">&quot;deferred_work&quot;</span> make skels 构建骨架</span><br></pre></td></tr></table></figure><h3 id="0-简介-2"><a href="#0-简介-2" class="headerlink" title="0.简介"></a>0.简介</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jiffies：全局变量，保存了自系统启动以来经过的&quot;时钟节拍数&quot;，每次时钟中断触发时，内核会把它加1，类型为unsigned long，用于时间比较和定时。</span><br><span class="line">时间换算：秒数 = jiffies / HZ</span><br><span class="line">HZ宏：内核每秒时钟中断数</span><br><span class="line"><span class="bullet">-</span> x86 每秒中断1000次</span><br><span class="line"><span class="bullet">-</span> ARM/嵌入式可能100或250次</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">timer_list 是内核定时器机制的核心结构体</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line"><span class="comment">/* 把定时器挂到全局定时器链表/红黑树上的节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">entry</span>;</span></span><br><span class="line"><span class="comment">/* 超时时间点（以 jiffies 为单位） */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> expires;</span><br><span class="line"><span class="comment">/* 回调函数指针 */</span></span><br><span class="line"><span class="type">void</span> (*function)(<span class="keyword">struct</span> timer_list *);</span><br><span class="line"><span class="comment">/* 回调函数参数（新内核用 from_timer() 宏来获取） */</span></span><br><span class="line">u32 flags;</span><br><span class="line"><span class="comment">/* 调试和统计字段略 */</span></span><br><span class="line">&#125;;</span><br><span class="line">timer_list负责在延迟时间expires到时把work_struct放进wrokqueue</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_bh()会获取一个自旋锁，保证多cpu并发访问的互斥性，并且关闭本地软中断的下半部处理</span><br></pre></td></tr></table></figure><h3 id="1-定时器"><a href="#1-定时器" class="headerlink" title="1.定时器"></a>1.定时器</h3><blockquote><p>创建一个简单的内核模块，在模块的内核加载后的第 <em>TIMER_TIMEOUT</em> 秒显示一条消息</p></blockquote><ol><li>创建骨架 <code>LABS=&quot;deferred_work&quot; make skels</code></li><li>在timer.c文件中修改</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.初始化一个timer</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">timer_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">pr_info(<span class="string">&quot;[timer_init] Init module\n&quot;</span>);</span><br><span class="line"><span class="comment">/* TODO 1: initialize timer */</span></span><br><span class="line">timer_setup(&amp;timer, timer_handler, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* TODO 1: schedule timer for the first time */</span></span><br><span class="line">mod_timer(&amp;timer, jiffies + TIMER_TIMEOUT * HZ);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.在定时器处理程序中打印信息</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_handler</span><span class="params">(<span class="keyword">struct</span> timer_list *tl)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* TODO 1/4: print a message */</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> nseconds;</span><br><span class="line">nseconds += TIMER_TIMEOUT;</span><br><span class="line">pr_info(<span class="string">&quot;[timer_handler] nseconds = %d\n&quot;</span>, nseconds);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.注销定时器</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">timer_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">pr_info(<span class="string">&quot;[timer_exit] Exit module\n&quot;</span>);</span><br><span class="line"><span class="comment">/* TODO 1: cleanup; make sure the timer is not running after we exit */</span></span><br><span class="line">del_timer_sync(&amp;timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250903153027875.png" alt="image-20250903153027875"></p><h3 id="2-周期性定时器"><a href="#2-周期性定时器" class="headerlink" title="2.周期性定时器"></a>2.周期性定时器</h3><blockquote><p>修改前面的模块，使消息每隔 TIMER_TIMEOUT 秒显示一次</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在定时器处理程序中，递归调用处理程序</span></span><br><span class="line"><span class="comment">/* TODO 2: rechedule timer */</span></span><br><span class="line">mod_timer(tl, jiffies + TIMER_TIMEOUT * HZ);</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250903153503385.png" alt="image-20250903153503385"></p><h3 id="3-使用-ioctl-控制定时器"><a href="#3-使用-ioctl-控制定时器" class="headerlink" title="3.使用 ioctl 控制定时器"></a>3.使用 ioctl 控制定时器</h3><blockquote><p>在从用户空间接收到 ioctl 调用后的第 N 秒显示有关当前进程的信息，N作为 ioctl 参数传递</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.在设备文件结构体中添加定时器字段</span></span><br><span class="line"><span class="comment">/* TODO 1: add timer */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.实现定时器处理程序</span></span><br><span class="line"><span class="comment">/* TODO 1/44: implement timer handler */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">my_data</span> =</span> from_timer(my_data, tl, timer);</span><br><span class="line">pr_info(<span class="string">&quot;[timer_handler] pid = %d, comm = %s\n&quot;</span>,</span><br><span class="line">    current-&gt;pid, current-&gt;comm);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.在中断程序中，实现定时器调度和取消定时器</span></span><br><span class="line"><span class="keyword">case</span> MY_IOCTL_TIMER_SET:</span><br><span class="line">    <span class="comment">/* TODO 1: schedule timer */</span></span><br><span class="line">    mod_timer(&amp;my_data-&gt;timer, jiffies + arg * HZ);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> MY_IOCTL_TIMER_CANCEL:</span><br><span class="line">    <span class="comment">/* TODO 1: cancel timer */</span></span><br><span class="line">    del_timer(&amp;my_data-&gt;timer);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.初始化一个定时器</span></span><br><span class="line"><span class="comment">/* TODO 1: Initialize timer. */</span></span><br><span class="line">timer_setup(&amp;dev.timer, timer_handler, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.注销定时器</span></span><br><span class="line"><span class="comment">/* TODO 1: Cleanup: make sure the timer is not running after exiting. */</span></span><br><span class="line">del_timer_sync(&amp;dev.timer);</span><br></pre></td></tr></table></figure><ul><li>使用kernel&#x2F;下的makenode脚本注册设备字符文件，然后插入模块</li><li>在user&#x2F;下执行 <code>./test s 3</code> 在三秒后启用定时器</li></ul><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250903161654957.png" alt="image-20250903161654957"></p><ul><li>执行 <code>./test c</code> 停用定时器</li></ul><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250903161731535.png" alt="image-20250903161731535"></p><h3 id="4-阻塞操作"><a href="#4-阻塞操作" class="headerlink" title="4.阻塞操作"></a>4.阻塞操作</h3><blockquote><p>在定时器处理程序中执行阻塞操作，由于定时器处理程序运行在中断上下文中，所以当执行阻塞操作时，会发生OOPS错误</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.为了区分定时器处理程序中的功能，在设备结构体中添加flag字段</span></span><br><span class="line"><span class="comment">/* TODO 2: add flag */</span></span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"><span class="comment">// 2.在定时器处理程序中，为不同的flag设置不同的功能</span></span><br><span class="line"><span class="comment">/* TODO 2/38: check flags: TIMER_TYPE_SET or TIMER_TYPE_ALLOC */</span></span><br><span class="line"><span class="keyword">switch</span> (my_data-&gt;flag) &#123;</span><br><span class="line"><span class="keyword">case</span> TIMER_TYPE_SET:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TIMER_TYPE_ALLOC:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ALLOC_IO_DIRECT</span></span><br><span class="line">alloc_io();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.设置不同参数下的中断程序标志</span></span><br><span class="line"><span class="keyword">case</span> MY_IOCTL_TIMER_SET:</span><br><span class="line">    <span class="comment">/* TODO 2: set flag */</span></span><br><span class="line">    my_data-&gt;flag = TIMER_TYPE_SET;</span><br><span class="line"><span class="keyword">case</span> MY_IOCTL_TIMER_ALLOC:</span><br><span class="line">    <span class="comment">/* TODO 2/2: set flag and schedule timer */</span></span><br><span class="line">    my_data-&gt;flag = TIMER_TYPE_ALLOC;</span><br><span class="line">    mod_timer(&amp;my_data-&gt;timer, jiffies + arg * HZ);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 4.初始化设备flag标志位</span></span><br><span class="line"><span class="comment">/* TODO 2: Initialize flag. */</span></span><br><span class="line">dev.flag = TIMER_TYPE_NONE;</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250903164345594.png" alt="image-20250903164345594"></p><h3 id="5-工作队列"><a href="#5-工作队列" class="headerlink" title="5.工作队列"></a>5.工作队列</h3><blockquote><p>使用工作队列调用alloc_io()，即在定时器处理程序中安排一个工作项。工作项处理程序在进程上下文中运行</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.在设备结构体中添加工作项字段</span></span><br><span class="line"><span class="comment">/* TODO 3: add work */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.定义工作项处理程序</span></span><br><span class="line"><span class="comment">/* TODO 3/4: define work handler */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_handler</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">alloc_io();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.执行工作项</span></span><br><span class="line"><span class="comment">/* TODO 3: schedule work */</span></span><br><span class="line">schedule_work(&amp;my_data-&gt;work);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.初始化工作项</span></span><br><span class="line"><span class="comment">/* TODO 3: Initialize work. */</span></span><br><span class="line">INIT_WORK(&amp;dev.work, work_handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.注销工作项</span></span><br><span class="line"><span class="comment">/* TODO 3: Cleanup: make sure the work handler is not scheduled. */</span></span><br><span class="line">flush_scheduled_work();</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250904084842901.png" alt="image-20250904084842901"></p><h3 id="6-内核线程"><a href="#6-内核线程" class="headerlink" title="6.内核线程"></a>6.内核线程</h3><blockquote><p>创建一个显示当前进程标识符的内核线程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.初始化等待队列和标志位</span></span><br><span class="line"><span class="comment">/* TODO/4: init the waitqueues and flags */</span></span><br><span class="line">init_waitqueue_head(&amp;wq_stop_thread);</span><br><span class="line"><span class="type">atomic_set</span>(&amp;flag_stop_thread, <span class="number">0</span>);</span><br><span class="line">init_waitqueue_head(&amp;wq_thread_terminated);</span><br><span class="line"><span class="type">atomic_set</span>(&amp;flag_thread_terminated, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建和开始内核线程</span></span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> create and start the kernel thread */</span></span><br><span class="line">kthread_run(my_thread_f, <span class="literal">NULL</span>, <span class="string">&quot;%skthread%d&quot;</span>, <span class="string">&quot;my&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.定义线程处理函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_thread_f</span><span class="params">(<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">pr_info(<span class="string">&quot;[my_thread_f] Current process id is %d (%s)\n&quot;</span>,</span><br><span class="line">current-&gt;pid, current-&gt;comm);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 4.等待命令去移除在等待队列中的模块</span></span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> Wait for command to remove module on wq_stop_thread queue. */</span></span><br><span class="line">wait_event_interruptible(wq_stop_thread,<span class="type">atomic_read</span>(&amp;flag_stop_thread) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.设置标志位标记内核线程结束</span></span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> set flag to mark kernel thread termination */</span></span><br><span class="line"><span class="type">atomic_set</span>(&amp;flag_thread_terminated, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.拉起中断，通知其他进程可以上来了</span></span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> notify the unload process that we have exited */</span></span><br><span class="line">wake_up_interruptible(&amp;wq_thread_terminated);</span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">&quot;[my_thread_f] Exiting\n&quot;</span>);</span><br><span class="line">do_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.线程退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">kthread_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* TODO/2: notify the kernel thread that its time to exit */</span></span><br><span class="line"><span class="type">atomic_set</span>(&amp;flag_stop_thread, <span class="number">1</span>);</span><br><span class="line">wake_up_interruptible(&amp;wq_stop_thread);</span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> wait for the kernel thread to exit */</span></span><br><span class="line">wait_event_interruptible(wq_thread_terminated, <span class="type">atomic_read</span>(&amp;flag_thread_terminated) != <span class="number">0</span>);</span><br><span class="line">pr_info(<span class="string">&quot;[kthread_exit] Exit module\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250904091929236.png" alt="image-20250904091929236"></p><h2 id="六-块设备驱动程序"><a href="#六-块设备驱动程序" class="headerlink" title="六  块设备驱动程序"></a>六  块设备驱动程序</h2><p>实验目标：</p><ul><li>了解 Linux 中 I&#x2F;O 子系统的行为</li><li>在块设备的结构和函数上进行实际操作</li><li>通过解决练习，掌握块设备的 API 使用基础技能</li></ul><h3 id="0-简介-3"><a href="#0-简介-3" class="headerlink" title="0.简介"></a>0.简介</h3><table><thead><tr><th>符号</th><th>定义位置（头文件）</th><th>简要说明</th></tr></thead><tbody><tr><td><code>struct bio</code></td><td><code>&lt;linux/bio.h&gt;</code></td><td>块 I&#x2F;O 的基本结构，包含 bio_vec 数组等</td></tr><tr><td><code>struct bio_vec</code></td><td><code>&lt;linux/bio.h&gt;</code></td><td>I&#x2F;O segment 描述：页面、偏移量、长度</td></tr><tr><td><code>bio_for_each_segment</code></td><td><code>&lt;linux/bio.h&gt;</code>（宏）</td><td>遍历 bio 中每个 segment 的迭代宏</td></tr><tr><td><code>struct gendisk</code></td><td><code>&lt;linux/genhd.h&gt;</code></td><td>通用磁盘结构，代表块设备抽象</td></tr><tr><td><code>struct block_device_operations</code></td><td><code>&lt;linux/blkdev.h&gt;</code></td><td>块设备操作函数集合</td></tr><tr><td><code>struct request</code></td><td><code>&lt;linux/blkdev.h&gt;</code></td><td>块 I&#x2F;O 请求结构，含多个 bio</td></tr></tbody></table><h3 id="1-块设备"><a href="#1-块设备" class="headerlink" title="1.块设备"></a>1.块设备</h3><blockquote><p>创建一个内核模块，允许你注册或者取消注册块设备</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.在初始化函数中注册块设备</span></span><br><span class="line"><span class="comment">/* TODO 1/5: register block device */</span></span><br><span class="line">err = register_blkdev(MY_BLOCK_MAJOR, MY_BLKDEV_NAME);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;register_blkdev: unable to register\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.在卸载函数中注销块设备</span></span><br><span class="line"><span class="comment">/* TODO 1/1: unregister block device */</span></span><br><span class="line">unregister_blkdev(MY_BLOCK_MAJOR, MY_BLKDEV_NAME);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.定义设备号和设备名</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_BLOCK_MAJOR240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_BLKDEV_NAME<span class="string">&quot;mybdev&quot;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里只是注册块设备，还没有创建块设备，只是告诉内核这里有块设备</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250904161600953.png" alt="image-20250904161600953"></p><h3 id="2-磁盘注册"><a href="#2-磁盘注册" class="headerlink" title="2.磁盘注册"></a>2.磁盘注册</h3><blockquote><p>添加与驱动程序关联的硬盘，填充请求函数以处理请求</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.完善请求处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">blk_status_t</span> <span class="title function_">my_block_request</span><span class="params">(<span class="keyword">struct</span> blk_mq_hw_ctx *hctx,</span></span><br><span class="line"><span class="params">     <span class="type">const</span> <span class="keyword">struct</span> blk_mq_queue_data *bd)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">rq</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_block_dev</span> *<span class="title">dev</span> =</span> hctx-&gt;<span class="built_in">queue</span>-&gt;queuedata;</span><br><span class="line"><span class="comment">/* TODO 2: get pointer to request */</span></span><br><span class="line">rq = bd-&gt;rq;</span><br><span class="line"><span class="comment">/* TODO 2: start request processing. */</span></span><br><span class="line">blk_mq_start_request(rq);</span><br><span class="line"><span class="comment">/* TODO 2/5: check fs request. Return if passthrough. */</span></span><br><span class="line"><span class="keyword">if</span> (blk_rq_is_passthrough(rq)) &#123;</span><br><span class="line">printk(KERN_NOTICE <span class="string">&quot;Skip non-fs request\n&quot;</span>);</span><br><span class="line">blk_mq_end_request(rq, BLK_STS_IOERR);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TODO 2/6: print request information */</span></span><br><span class="line">printk(KERN_LOG_LEVEL</span><br><span class="line"><span class="string">&quot;request received: pos=%llu bytes=%u &quot;</span></span><br><span class="line"><span class="string">&quot;cur_bytes=%u dir=%c\n&quot;</span>,</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) blk_rq_pos(rq),</span><br><span class="line">blk_rq_bytes(rq), blk_rq_cur_bytes(rq),</span><br><span class="line">rq_data_dir(rq) ? <span class="string">&#x27;W&#x27;</span> : <span class="string">&#x27;R&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_BIO_TRANSFER == 1</span></span><br><span class="line"><span class="comment">/* TODO 6/1: process the request by calling my_xfer_request */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/* TODO 3/3:process the request by calling my_block_transfer */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/1: end request successfully */</span></span><br><span class="line">blk_mq_end_request(rq, BLK_STS_OK);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> BLK_STS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.在初始化函数中创建块设备</span></span><br><span class="line"><span class="comment">/* TODO 2/3: create block device using create_block_device */</span></span><br><span class="line">err = create_block_device(&amp;g_dev);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* TODO 2/1: unregister block device in case of an error */</span></span><br><span class="line">unregister_blkdev(MY_BLOCK_MAJOR, MY_BLKDEV_NAME);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.在卸载函数中删除块设备</span></span><br><span class="line"><span class="comment">/* TODO 2/1: cleanup block device using delete_block_device */</span></span><br><span class="line">delete_block_device(&amp;g_dev);</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250904165309029.png" alt="image-20250904165309029"></p><h3 id="3-RAM磁盘"><a href="#3-RAM磁盘" class="headerlink" title="3.RAM磁盘"></a>3.RAM磁盘</h3><blockquote><p>创建一个 RAM 磁盘：对设备的请求将导致在一个内存区域中进行读写操作</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_block_transfer</span><span class="params">(<span class="keyword">struct</span> my_block_dev *dev, <span class="type">sector_t</span> sector,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">char</span> *buffer, <span class="type">int</span> dir)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> offset = sector * KERNEL_SECTOR_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for read/write beyond end of block device */</span></span><br><span class="line"><span class="keyword">if</span> ((offset + len) &gt; dev-&gt;size)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 3/4: read/write to dev buffer depending on dir */</span></span><br><span class="line"><span class="keyword">if</span> (dir == <span class="number">1</span>)<span class="comment">/* write */</span></span><br><span class="line"><span class="built_in">memcpy</span>(dev-&gt;data + offset, buffer, len);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">memcpy</span>(buffer, dev-&gt;data + offset, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TODO 3/3: process the request by calling my_block_transfer */</span></span><br><span class="line">my_block_transfer(dev, blk_rq_pos(rq),</span><br><span class="line">          blk_rq_bytes(rq),</span><br><span class="line">          bio_data(rq-&gt;bio), rq_data_dir(rq));</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250905091140376.png" alt="image-20250905091140376"></p><h3 id="4-从磁盘读取数据"><a href="#4-从磁盘读取数据" class="headerlink" title="4.从磁盘读取数据"></a>4.从磁盘读取数据</h3><blockquote><p>从内核直接读取 <code>PHYSICAL_DISK_NAME</code> 磁盘（<code>/dev/vdb</code>）的数据。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TODO 4/3: fill bio (bdev, sector, direction) */</span></span><br><span class="line">bio-&gt;bi_disk = bdev-&gt;bd_disk;</span><br><span class="line">bio-&gt;bi_iter.bi_sector = <span class="number">0</span>;</span><br><span class="line">bio-&gt;bi_opf = dir;</span><br><span class="line"><span class="comment">/* TODO 4/3: submit bio and wait for completion */</span></span><br><span class="line">printk(KERN_LOG_LEVEL <span class="string">&quot;[send_test_bio] Submiting bio\n&quot;</span>);</span><br><span class="line">submit_bio_wait(bio);</span><br><span class="line">printk(KERN_LOG_LEVEL <span class="string">&quot;[send_test_bio] Done bio\n&quot;</span>);</span><br><span class="line"><span class="comment">/* TODO 4/3: read data (first 3 bytes) from bio buffer and print it */</span></span><br><span class="line">buf = kmap_atomic(page);</span><br><span class="line">printk(KERN_LOG_LEVEL <span class="string">&quot;read %02x %02x %02x\n&quot;</span>, buf[<span class="number">0</span>], buf[<span class="number">1</span>], buf[<span class="number">2</span>]);</span><br><span class="line">kunmap_atomic(buf);</span><br><span class="line"><span class="comment">/* TODO 4/5: get block device in exclusive mode */</span></span><br><span class="line">bdev = blkdev_get_by_path(name, FMODE_READ | FMODE_WRITE | FMODE_EXCL, THIS_MODULE);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(bdev)) &#123;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;blkdev_get_by_path\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TODO 4/1: put block device */</span></span><br><span class="line">blkdev_put(bdev, FMODE_READ | FMODE_WRITE | FMODE_EXCL);</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250905092023588.png" alt="image-20250905092023588"></p><h3 id="5-将数据写入磁盘"><a href="#5-将数据写入磁盘" class="headerlink" title="5.将数据写入磁盘"></a>5.将数据写入磁盘</h3><blockquote><p>在磁盘上写入消息（<code>BIO_WRITE_MESSAGE</code>）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TODO 5/5: write message to bio buffer if direction is write */</span></span><br><span class="line"><span class="keyword">if</span> (dir == REQ_OP_WRITE) &#123;</span><br><span class="line">    buf = kmap_atomic(page);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, BIO_WRITE_MESSAGE, <span class="built_in">strlen</span>(BIO_WRITE_MESSAGE));</span><br><span class="line">    kunmap_atomic(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">relay_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* TODO 5/1: send test write bio */</span></span><br><span class="line">send_test_bio(phys_bdev, REQ_OP_WRITE);</span><br><span class="line">close_disk(phys_bdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250905093238273.png" alt="image-20250905093238273"></p><h3 id="6-在struct-bio级别处理请求队列中的请求"><a href="#6-在struct-bio级别处理请求队列中的请求" class="headerlink" title="6.在struct bio级别处理请求队列中的请求"></a>6.在struct bio级别处理请求队列中的请求</h3><blockquote><p>处理来自请求队列中所有 <code>struct bio</code> 结构的所有 <code>struct bio_vec</code> 结构（也称为段）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TODO 6/0: use bios for read/write requests */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USE_BIO_TRANSFER1</span></span><br><span class="line"><span class="comment">/* TODO 6/10: iterate segments */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> <span class="title">bvec</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">req_iterator</span> <span class="title">iter</span>;</span></span><br><span class="line">rq_for_each_segment(bvec, req, iter) &#123;</span><br><span class="line">    <span class="type">sector_t</span> sector = iter.iter.bi_sector;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> offset = bvec.bv_offset;</span><br><span class="line">    <span class="type">size_t</span> len = bvec.bv_len;</span><br><span class="line">    <span class="type">int</span> dir = bio_data_dir(iter.bio);</span><br><span class="line">    <span class="type">char</span> *buffer = kmap_atomic(bvec.bv_page);</span><br><span class="line">    printk(KERN_LOG_LEVEL <span class="string">&quot;%s: buf %8p offset %lu len %u dir %d\n&quot;</span>, __func__, buffer, offset, len, dir);</span><br><span class="line">    <span class="comment">/* TODO 6/3: copy bio data to device buffer */</span></span><br><span class="line">    my_block_transfer(dev, sector, len, buffer + offset, dir);</span><br><span class="line">    kunmap_atomic(buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TODO 6/1: process the request by calling my_xfer_request */</span></span><br><span class="line">my_xfer_request(dev, rq);</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250905100157263.png" alt="image-20250905100157263"></p><h2 id="七-文件系统驱动程序-第一部分"><a href="#七-文件系统驱动程序-第一部分" class="headerlink" title="七  文件系统驱动程序(第一部分)"></a>七  文件系统驱动程序(第一部分)</h2><p>实验目标：</p><ul><li>了解 Linux 中虚拟文件系统（VFS）的知识，理解有关“inode”、“dentry”、“文件”、“超级块”和数据块的概念。</li><li>理解在 VFS 内挂载文件系统的过程。</li><li>了解各种文件系统类型，并理解具有物理支持（在磁盘上）和没有物理支持的文件系统之间的区别。</li></ul><h3 id="1-注册和注销myfs文件系统"><a href="#1-注册和注销myfs文件系统" class="headerlink" title="1.注册和注销myfs文件系统"></a>1.注册和注销myfs文件系统</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">myfs_mount</span><span class="params">(<span class="keyword">struct</span> file_system_type *fs_type,</span></span><br><span class="line"><span class="params"><span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *dev_name, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* TODO 1/1: call superblock mount function */</span></span><br><span class="line"><span class="keyword">return</span> mount_nodev(fs_type, flags, data, myfs_fill_super);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TODO 1/6: define file_system_type structure */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">myfs_fs_type</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.name= <span class="string">&quot;myfs&quot;</span>,</span><br><span class="line">.mount= myfs_mount,</span><br><span class="line">.kill_sb= kill_litter_super,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* TODO 1/1: register */</span></span><br><span class="line">err = register_filesystem(&amp;myfs_fs_type);</span><br><span class="line"><span class="comment">/* TODO 1/1: unregister */</span></span><br><span class="line">unregister_filesystem(&amp;myfs_fs_type);</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250908093600392.png" alt="image-20250908093600392"></p><h3 id="2-完成myfs超级块填充"><a href="#2-完成myfs超级块填充" class="headerlink" title="2.完成myfs超级块填充"></a>2.完成myfs超级块填充</h3><blockquote><p>为了能够挂载文件系统，我们需要填充其超级块的字段，即类型为 <code>struct super_block</code> 的通用 VFS 结构，从而完成文件系统超级块的初始化</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TODO 2/4: define super_operations structure */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">myfs_ops</span> =</span> &#123;</span><br><span class="line">.statfs= simple_statfs,</span><br><span class="line">.drop_inode= generic_drop_inode,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* TODO 2/5: fill super_block</span></span><br><span class="line"><span class="comment"> *   - blocksize, blocksize_bits</span></span><br><span class="line"><span class="comment"> *   - magic</span></span><br><span class="line"><span class="comment"> *   - super operations</span></span><br><span class="line"><span class="comment"> *   - maxbytes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sb-&gt;s_maxbytes = MAX_LFS_FILESIZE;</span><br><span class="line">sb-&gt;s_blocksize = MYFS_BLOCKSIZE;</span><br><span class="line">sb-&gt;s_blocksize_bits = MYFS_BLOCKSIZE_BITS;</span><br><span class="line">sb-&gt;s_magic = MYFS_MAGIC;</span><br><span class="line">sb-&gt;s_op = &amp;myfs_ops;</span><br></pre></td></tr></table></figure><h3 id="3-初始化myfs根索引节点"><a href="#3-初始化myfs根索引节点" class="headerlink" title="3.初始化myfs根索引节点"></a>3.初始化myfs根索引节点</h3><blockquote><p>为了成功完成挂载操作，还需要初始化根索引节点，根索引节点是文件系统根目录（即 <code>/</code>）的索引节点。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TODO 3/3: fill inode structure</span></span><br><span class="line"><span class="comment"> *     - mode</span></span><br><span class="line"><span class="comment"> *     - uid</span></span><br><span class="line"><span class="comment"> *     - gid</span></span><br><span class="line"><span class="comment"> *     - atime,ctime,mtime</span></span><br><span class="line"><span class="comment"> *     - ino</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">inode_init_owner(inode, dir, mode);</span><br><span class="line">inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode);</span><br><span class="line">inode-&gt;i_ino = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* TODO 3/2: set inode operations for dir inodes. */</span></span><br><span class="line">inode-&gt;i_op = &amp;simple_dir_inode_operations;</span><br><span class="line">inode-&gt;i_fop = &amp;simple_dir_operations;</span><br><span class="line"><span class="comment">/* TODO 3/1: directory inodes start off with i_nlink == 2 (for &quot;.&quot; entry).</span></span><br><span class="line"><span class="comment"> * Directory link count should be incremented (use inc_nlink).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">inc_nlink(inode);</span><br></pre></td></tr></table></figure><h3 id="4-测试myfs的挂载和卸载"><a href="#4-测试myfs的挂载和卸载" class="headerlink" title="4.测试myfs的挂载和卸载"></a>4.测试myfs的挂载和卸载</h3><blockquote><p>执行脚本 <code>./test-myfs.sh</code> 测试整个功能</p></blockquote><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250908095833026.png" alt="image-20250908095833026"></p><h3 id="5-minfs"><a href="#5-minfs" class="headerlink" title="5.minfs"></a>5.minfs</h3><blockquote><p>接下来实现一个支持磁盘的文件系统</p></blockquote><h4 id="1-注册和注销minfs文件系统"><a href="#1-注册和注销minfs文件系统" class="headerlink" title="1.注册和注销minfs文件系统"></a>1.注册和注销minfs文件系统</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">minfs_mount</span><span class="params">(<span class="keyword">struct</span> file_system_type *fs_type,</span></span><br><span class="line"><span class="params"><span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *dev_name, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* TODO 1/1: call superblock mount function */</span></span><br><span class="line"><span class="keyword">return</span> mount_bdev(fs_type, flags, dev_name, data, minfs_fill_super);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">minfs_fs_type</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.name= <span class="string">&quot;minfs&quot;</span>,</span><br><span class="line"><span class="comment">/* TODO 1/3: add mount, kill_sb and fs_flags */</span></span><br><span class="line">.mount= minfs_mount,</span><br><span class="line">.kill_sb= kill_block_super,</span><br><span class="line">.fs_flags= FS_REQUIRES_DEV,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250908144034036.png" alt="image-20250908144034036"></p><h4 id="2-完善minfs超级块"><a href="#2-完善minfs超级块" class="headerlink" title="2.完善minfs超级块"></a>2.完善minfs超级块</h4><blockquote><p>为了能够挂载文件系统，你需要在 <code>minfs_fill_super</code> 函数中填充超级块（即类型为 <code>struct super_block</code> 的结构体）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode *<span class="title function_">myfs_get_inode</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="type">const</span> <span class="keyword">struct</span> inode *dir,</span></span><br><span class="line"><span class="params"><span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> new_inode(sb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!inode)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 3/3: fill inode structure</span></span><br><span class="line"><span class="comment"> *     - mode</span></span><br><span class="line"><span class="comment"> *     - uid</span></span><br><span class="line"><span class="comment"> *     - gid</span></span><br><span class="line"><span class="comment"> *     - atime,ctime,mtime</span></span><br><span class="line"><span class="comment"> *     - ino</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">inode_init_owner(inode, dir, mode);</span><br><span class="line">inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode);</span><br><span class="line">inode-&gt;i_ino = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 5/1: Init i_ino using get_next_ino */</span></span><br><span class="line">inode-&gt;i_ino = get_next_ino();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 6/1: Initialize address space operations. */</span></span><br><span class="line">inode-&gt;i_mapping-&gt;a_ops = &amp;minfs_aops;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(mode)) &#123;</span><br><span class="line"><span class="comment">/* TODO 3/2: set inode operations for dir inodes. */</span></span><br><span class="line">inode-&gt;i_op = &amp;simple_dir_inode_operations;</span><br><span class="line">inode-&gt;i_fop = &amp;simple_dir_operations;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 5/1: use myfs_dir_inode_operations for inode</span></span><br><span class="line"><span class="comment"> * operations (i_op).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">inode-&gt;i_op = &amp;minfs_dir_inode_operations;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 3/1: directory inodes start off with i_nlink == 2 (for &quot;.&quot; entry).</span></span><br><span class="line"><span class="comment"> * Directory link count should be incremented (use inc_nlink).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">inc_nlink(inode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 6/4: Set file inode and file operations for regular files</span></span><br><span class="line"><span class="comment"> * (use the S_ISREG macro).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (S_ISREG(mode)) &#123;</span><br><span class="line">inode-&gt;i_op = &amp;minfs_file_inode_operations;</span><br><span class="line">inode-&gt;i_fop = &amp;minfs_file_operations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">minfs_fill_super</span><span class="params">(<span class="keyword">struct</span> super_block *s, <span class="type">void</span> *data, <span class="type">int</span> silent)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">minfs_sb_info</span> *<span class="title">sbi</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">minfs_super_block</span> *<span class="title">ms</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">root_inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">root_dentry</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line"><span class="type">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">sbi = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> minfs_sb_info), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!sbi)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">s-&gt;s_fs_info = sbi;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set block size for superblock. */</span></span><br><span class="line"><span class="keyword">if</span> (!sb_set_blocksize(s, MINFS_BLOCK_SIZE))</span><br><span class="line"><span class="keyword">goto</span> out_bad_blocksize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/3: Read block with superblock. It&#x27;s the first block on</span></span><br><span class="line"><span class="comment"> * the device, i.e. the block with the index 0. This is the index</span></span><br><span class="line"><span class="comment"> * to be passed to sb_bread().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">bh = sb_bread(s, MINFS_SUPER_BLOCK);</span><br><span class="line"><span class="keyword">if</span> (bh == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> out_bad_sb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/1: interpret read data as minfs_super_block */</span></span><br><span class="line">ms = (<span class="keyword">struct</span> minfs_super_block *) bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/2: check magic number with value defined in minfs.h. jump to out_bad_magic if not suitable */</span></span><br><span class="line"><span class="keyword">if</span> (ms-&gt;magic != MINFS_MAGIC)</span><br><span class="line"><span class="keyword">goto</span> out_bad_magic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/2: fill super_block with magic_number, super_operations */</span></span><br><span class="line">s-&gt;s_magic = MINFS_MAGIC;</span><br><span class="line">s-&gt;s_op = &amp;minfs_ops;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/2: Fill sbi with rest of information from disk superblock</span></span><br><span class="line"><span class="comment"> * (i.e. version).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sbi-&gt;version = ms-&gt;version;</span><br><span class="line">sbi-&gt;imap = ms-&gt;imap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocate root inode and root dentry */</span></span><br><span class="line"><span class="comment">/* TODO 2/0: use myfs_get_inode instead of minfs_iget */</span></span><br><span class="line">root_inode = myfs_get_inode(s, MINFS_ROOT_INODE, S_IFDIR | S_IRWXU | S_IRGRP |</span><br><span class="line">S_IXGRP | S_IROTH | S_IXOTH);</span><br><span class="line"><span class="keyword">if</span> (!root_inode)</span><br><span class="line"><span class="keyword">goto</span> out_bad_inode;</span><br><span class="line"></span><br><span class="line">root_dentry = d_make_root(root_inode);</span><br><span class="line"><span class="keyword">if</span> (!root_dentry)</span><br><span class="line"><span class="keyword">goto</span> out_iput;</span><br><span class="line">s-&gt;s_root = root_dentry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Store superblock buffer_head for further use. */</span></span><br><span class="line">sbi-&gt;sbh = bh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_iput:</span><br><span class="line">iput(root_inode);</span><br><span class="line">out_bad_inode:</span><br><span class="line">printk(LOG_LEVEL <span class="string">&quot;bad inode\n&quot;</span>);</span><br><span class="line">out_bad_magic:</span><br><span class="line">printk(LOG_LEVEL <span class="string">&quot;bad magic number\n&quot;</span>);</span><br><span class="line">brelse(bh);</span><br><span class="line">out_bad_sb:</span><br><span class="line">printk(LOG_LEVEL <span class="string">&quot;error reading buffer_head\n&quot;</span>);</span><br><span class="line">out_bad_blocksize:</span><br><span class="line">printk(LOG_LEVEL <span class="string">&quot;bad block size\n&quot;</span>);</span><br><span class="line">s-&gt;s_fs_info = <span class="literal">NULL</span>;</span><br><span class="line">kfree(sbi);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250908153002651.png" alt="image-20250908153002651"></p><blockquote><p>挂载成功</p></blockquote><h4 id="3-创建和销毁minfs索引节点"><a href="#3-创建和销毁minfs索引节点" class="headerlink" title="3.创建和销毁minfs索引节点"></a>3.创建和销毁minfs索引节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode *<span class="title function_">minfs_alloc_inode</span><span class="params">(<span class="keyword">struct</span> super_block *s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 3/4: Allocate minfs_inode_info. */</span></span><br><span class="line">mii = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> minfs_inode_info), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (mii == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 3/1: init VFS inode in minfs_inode_info */</span></span><br><span class="line">inode_init_once(&amp;mii-&gt;vfs_inode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;mii-&gt;vfs_inode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">minfs_destroy_inode</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* TODO 3/1: free minfs_inode_info */</span></span><br><span class="line">kfree(container_of(inode, <span class="keyword">struct</span> minfs_inode_info, vfs_inode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-初始化minfs根索引节点"><a href="#4-初始化minfs根索引节点" class="headerlink" title="4.初始化minfs根索引节点"></a>4.初始化minfs根索引节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TODO 4/2: Read block with inodes. It&#x27;s the second block on</span></span><br><span class="line"><span class="comment"> * the device, i.e. the block with the index 1. This is the index</span></span><br><span class="line"><span class="comment"> * to be passed to sb_bread().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!(bh = sb_bread(s, MINFS_INODE_BLOCK)))</span><br><span class="line">    <span class="keyword">goto</span> out_bad_sb;</span><br><span class="line"><span class="comment">/* TODO 4/1: Get inode with index ino from the block. */</span></span><br><span class="line">mi = ((<span class="keyword">struct</span> minfs_inode *) bh-&gt;b_data) + ino;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 4/6: fill VFS inode */</span></span><br><span class="line">inode-&gt;i_mode = mi-&gt;mode;</span><br><span class="line">i_uid_write(inode, mi-&gt;uid);</span><br><span class="line">i_gid_write(inode, mi-&gt;gid);</span><br><span class="line">inode-&gt;i_size = mi-&gt;size;</span><br><span class="line">inode-&gt;i_blocks = <span class="number">0</span>;</span><br><span class="line">inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = current_time(inode);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 4/2: Fill dir inode operations. */</span></span><br><span class="line">inode-&gt;i_op = &amp;simple_dir_inode_operations;</span><br><span class="line">inode-&gt;i_fop = &amp;simple_dir_operations;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 4/1: Directory inodes start off with i_nlink == 2.</span></span><br><span class="line"><span class="comment"> * (use inc_link) */</span></span><br><span class="line">inc_nlink(inode);</span><br><span class="line"><span class="comment">/* TODO 4/1: uncomment after the minfs_inode is initialized */</span></span><br><span class="line">mii-&gt;data_block = mi-&gt;data_block;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free resources. */</span></span><br><span class="line"><span class="comment">/* TODO 4/1: uncomment after the buffer_head is initialized */</span></span><br><span class="line">brelse(bh);</span><br><span class="line"><span class="comment">//brelse(bh);</span></span><br><span class="line">unlock_new_inode(inode);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">minfs_ops</span> =</span> &#123;</span><br><span class="line">.statfs= simple_statfs,</span><br><span class="line">.put_super= minfs_put_super,</span><br><span class="line"><span class="comment">/* TODO 4/2: add alloc and destroy inode functions */</span></span><br><span class="line">.alloc_inode= minfs_alloc_inode,</span><br><span class="line">.destroy_inode= minfs_destroy_inode,</span><br><span class="line"><span class="comment">/* TODO 7/1:= set write_inode function. */</span></span><br><span class="line">.write_inode= minfs_write_inode,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-minfs挂载和卸载的测试"><a href="#5-minfs挂载和卸载的测试" class="headerlink" title="5.minfs挂载和卸载的测试"></a>5.minfs挂载和卸载的测试</h4><blockquote><p>验证文件系统是否已挂载</p></blockquote><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250908154050862.png" alt="image-20250908154050862"></p><blockquote><p>挂载成功</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;OS2 内核编程和驱动程序开发实验&lt;/center&gt;&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;基于布加勒斯特理工大学自动控制与计算机学院计算机科学与工程系的 “操作系统2” 课程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;环境配置&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="内核教程" scheme="https://leeway2zc.top/categories/%E5%86%85%E6%A0%B8%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="内核教程" scheme="https://leeway2zc.top/tags/%E5%86%85%E6%A0%B8%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>上传博客的教程</title>
    <link href="https://leeway2zc.top/2025/08/10/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%95%99%E7%A8%8B/"/>
    <id>https://leeway2zc.top/2025/08/10/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%95%99%E7%A8%8B/</id>
    <published>2025-08-10T20:26:31.000Z</published>
    <updated>2025-10-11T06:45:07.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以后写文章的流程"><a href="#以后写文章的流程" class="headerlink" title="以后写文章的流程"></a><strong>以后写文章的流程</strong></h2><ol><li><code>npx hexo new post &quot;文章标题&quot;</code></li><li>编辑 <code>source/_posts/文章标题.md</code></li><li><code>git add . &amp;&amp; git commit -m &quot;update post&quot; &amp;&amp; git push</code></li><li>等 1~2 分钟，GitHub Pages 自动更新</li></ol><h2 id="在其他设备上推送博客的流程"><a href="#在其他设备上推送博客的流程" class="headerlink" title="在其他设备上推送博客的流程"></a>在其他设备上推送博客的流程</h2><ol><li><p>安装git、node.js、npm</p><blockquote><p>使用git -v, node -v, npm -v检查是否安装成功</p></blockquote></li><li><p>选择一个目录打开 git bash，执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/Leeway2ZC/hexo-blog.git</span></span><br></pre></td></tr></table></figure></li><li><p>进入仓库目录 <code>cd hexo-blog</code></p></li><li><p>安装项目依赖 <code>npm install</code></p></li><li><p>在Git中设置本地用户名和邮箱</p><ul><li><p>配置全局Git用户名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Leeway2ZC&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>配置全局Git邮箱</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;leeway2zc@gmail.com&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>然后就可以按照上面的流程写文章啦</p></li></ol><h2 id="关于修改添加测试博客功能"><a href="#关于修改添加测试博客功能" class="headerlink" title="关于修改添加测试博客功能"></a>关于修改添加测试博客功能</h2><blockquote><p>参考hexo官方教程<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p></blockquote><p>使用git退回上一个提交版本(将源码分支和网站都退回到上个版本)：</p><ol><li><code>git log --oneline </code> # 找到上一个版本的 commit ID</li><li><code>git reset --hard &lt;commit-id&gt;</code> # 找到上一个版本的 commit ID</li><li><code>git push origin main --force</code> # 推送（覆盖远端）</li></ol><p>更改主题时，使用git在本地先进行测试，然后推送博客更新</p><ol><li><p><code>git branch</code>  # 查看当前分支</p></li><li><p><code>git checkout -b test-theme</code> # 创建并切换到测试分支</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这一步做了两件事，此时的 `test-theme` 是完全跟 `main` 一样的，只是互不影响</span><br><span class="line"></span><br><span class="line">1. 从 `main` 复制当前代码</span><br><span class="line">2. 切换到新分支 `test-theme`</span><br></pre></td></tr></table></figure></li><li><p>在测试分支修改主题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你在这个分支上可以随便改主题、调整配置、改文章。</span><br><span class="line">如果改坏了，直接删掉这个分支就行，main 分支不受影响。</span><br></pre></td></tr></table></figure></li><li><p>本地测试，在test-theme分支中运行 <code>npx hexo server</code> 浏览效果</p></li><li><p>确认没问题后合并到main</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge test-theme</span><br></pre></td></tr></table></figure></li><li><p>推送到远程（更新博客）<code>git push origin main</code></p></li><li><p>如果发现问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git branch -D test-theme</span><br></pre></td></tr></table></figure><p>直接删除分支，一切回到切换主题前</p></li></ol><h2 id="关于配置图床"><a href="#关于配置图床" class="headerlink" title="关于配置图床"></a>关于配置图床</h2><ol><li>安装PicGo</li><li>配置PicGo<ol><li>使用ini文件设置腾讯云Cos</li><li>设置Server修改监听端口与Typora保持一致</li></ol></li><li>配置Typora<ol><li>修改偏好设置中的图像</li><li>修改为上传图片，上传服务更改为PicGo</li><li>验证图片上传选项</li></ol></li></ol><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250811005047923.png" alt="image-20250811005047923" style="zoom:50%;" /><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>如果在另一台设备上做了修改，那么写文章前先要拉取最新代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><p>从而确保代码库是最新的，避免冲突</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;以后写文章的流程&quot;&gt;&lt;a href=&quot;#以后写文章的流程&quot; class=&quot;headerlink&quot; title=&quot;以后写文章的流程&quot;&gt;&lt;/a&gt;&lt;strong&gt;以后写文章的流程&lt;/strong&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;npx hexo new post</summary>
      
    
    
    
    
    <category term="教程" scheme="https://leeway2zc.top/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="https://leeway2zc.top/2025/08/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>https://leeway2zc.top/2025/08/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</id>
    <published>2025-08-10T18:50:13.000Z</published>
    <updated>2025-10-11T06:45:07.918Z</updated>
    
    <content type="html"><![CDATA[<p>这是我的第一篇博客，以后会记录很多学习笔记，还有很多值得记录的事情。</p><p>不能总是等到失去才发现错过了什么，要时刻记录确保不会遗忘。以此怀念我的爷爷，愿您在天堂不再有苦痛，再见时希望您过的安详。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是我的第一篇博客，以后会记录很多学习笔记，还有很多值得记录的事情。&lt;/p&gt;
&lt;p&gt;不能总是等到失去才发现错过了什么，要时刻记录确保不会遗忘。以此怀念我的爷爷，愿您在天堂不再有苦痛，再见时希望您过的安详。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
