<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeeWay</title>
  
  <subtitle>李海云</subtitle>
  <link href="https://leeway2zc.top/atom.xml" rel="self"/>
  
  <link href="https://leeway2zc.top/"/>
  <updated>2025-08-21T00:52:53.145Z</updated>
  <id>https://leeway2zc.top/</id>
  
  <author>
    <name>David Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客升级</title>
    <link href="https://leeway2zc.top/2025/08/21/%E5%8D%9A%E5%AE%A2%E5%8D%87%E7%BA%A7/"/>
    <id>https://leeway2zc.top/2025/08/21/%E5%8D%9A%E5%AE%A2%E5%8D%87%E7%BA%A7/</id>
    <published>2025-08-21T08:40:34.000Z</published>
    <updated>2025-08-21T00:52:53.145Z</updated>
    
    <content type="html"><![CDATA[<p>现在的博客还不太完善，有很多不满意的地方，例如：</p><ol><li>有个多余的…more在文章下面</li><li>显示不了访问次数</li><li>更新后日期没变动</li><li>文章下没有标签(如果解决不了，可以尝试更换主题为Indigo)</li><li>评论区有Code 403: 访问被API域名白名单拒绝，请检查你的安全域名设置</li><li>目录显示不全</li><li>页脚不显示总访问数和访客数</li><li>页眉没有图片</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现在的博客还不太完善，有很多不满意的地方，例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有个多余的…more在文章下面&lt;/li&gt;
&lt;li&gt;显示不了访问次数&lt;/li&gt;
&lt;li&gt;更新后日期没变动&lt;/li&gt;
&lt;li&gt;文章下没有标签(如果解决不了，可以尝试更换主题为Indigo)&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++开发学习笔记</title>
    <link href="https://leeway2zc.top/2025/08/12/C++%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://leeway2zc.top/2025/08/12/C++%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-08-12T22:12:50.000Z</published>
    <updated>2025-08-21T00:52:53.145Z</updated>
    
    <content type="html"><![CDATA[<h1><center>C/C++全栈开发学习笔记</center></h1><h2 id="1-1-1-随处可见的红黑树"><a href="#1-1-1-随处可见的红黑树" class="headerlink" title="1.1.1 随处可见的红黑树"></a>1.1.1 随处可见的红黑树</h2><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250813231311627.png" alt="image-20250813231311627"></p><p>学习目标：</p><ul><li>能使用C语言实现红黑树</li><li>能记住红黑树的代码实现</li></ul><p>红黑树的性质：</p><ol><li>每个结点是红的或者黑的</li><li>根结点是黑的</li><li>每个叶子结点是黑的</li><li>如果一个结点是红的，则它的两个儿子都是黑的（不存在相邻红色）</li><li><strong>对每个结点，从该结点到其子孙结点的所有路径包含相同数目的黑节点</strong>（即黑高度相同）</li><li>最长路径长度不超过最短路径长度的2倍（2n-1，一条黑红黑红，一条全黑）</li></ol><p>红黑树的优点：插入和删除的时间复杂度优于平衡二叉搜索树，又没有二叉搜索树可能退化为链表的Bug</p><ul><li>rbTree查询元素：O(log(N))</li><li>rbTree插入元素：插入最多2次旋转，加上查询的时间O(log(N))，插入的复杂度O(log(N))</li><li>rbTree删除元素：删除最多需要3次旋转，加上查询的时间，删除的复杂度O(log(N))</li></ul><p>红黑树的应用场景</p><ol><li>c++ stl map,set（红黑树的封装）</li><li>进程调度cfs（用红黑树存储进程的集合，把调度的时间作为key，那么树的左下角时间就是最小的）</li><li>内存管理（每次使用malloc的时候都会分配一块小内存出来，那么这么块就是用红黑树来存，如何表述一段内存块呢，用开始地址+长度来表示，所以key-&gt;开始地址，val-&gt;大小）</li><li>epoll中使用红黑树管理socketfd</li><li>nginx中使用红黑树管理定时器，中序遍历第一个就是最小的定时器</li></ol><h3 id="红黑树结点的定义"><a href="#红黑树结点的定义" class="headerlink" title="红黑树结点的定义"></a><strong>红黑树结点的定义</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree_node</span> &#123;</span></span><br><span class="line">    <span class="comment">//rbtree</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> color; <span class="comment">// #define RED 0 define BLACK 1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree_node</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree_node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree_node</span> *<span class="title">right</span>;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    KEY_TYPE key; <span class="comment">// 例如 typedef int KEY_TYPE </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// value// value 的类型也是自己定义</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125; rbtree_node;</span><br></pre></td></tr></table></figure><h3 id="红黑树的定义"><a href="#红黑树的定义" class="headerlink" title="红黑树的定义"></a><strong>红黑树的定义</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rbtree</span> &#123;</span></span><br><span class="line">    <span class="comment">// 只需要一个 root 根结点</span></span><br><span class="line">    rbtree_node *root;</span><br><span class="line">    <span class="comment">// 红黑树中空结点的类型也是红黑树结点，也有left、right、parent指针</span></span><br><span class="line">    rbtree_node *nil; <span class="comment">// NULL </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>红黑树的四个难点：删除、插入、调整、左旋右旋</p></blockquote><h3 id="红黑树结点的左旋与右旋"><a href="#红黑树结点的左旋与右旋" class="headerlink" title="红黑树结点的左旋与右旋"></a><strong>红黑树结点的左旋与右旋</strong></h3><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250813231400708.png" alt="image-20250813231400708"></p><p>红黑树的左旋操作：左旋就是向左倾斜，记住要操作三条线，六个指针，分别是:</p><ul><li>x-&gt;right &#x3D; y-&gt;left | y-&gt;left-&gt;parent &#x3D; x</li><li>y-&gt;parent &#x3D; x-&gt;parent | x-&gt;parent-&gt;left&#x2F;right &#x3D; y</li><li>x-&gt;parent-&gt;left&#x2F;right &#x3D; y | y-&gt;left-&gt;parent &#x3D; x</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rbtree_left_rotate</span><span class="params">(<span class="keyword">struct</span> rbtree *T, rbtree_node *x)</span> &#123;</span><br><span class="line"><span class="comment">// 左旋只需要一个结点就能完成，引入 T 是为了判断是否为根结点或者叶子结点</span></span><br><span class="line"><span class="keyword">if</span>(x == T-&gt;nil)  <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 直接读取左旋需要的右节点</span></span><br><span class="line">rbtree_node *y = x-&gt;right;</span><br><span class="line"><span class="comment">// x到y的那条线</span></span><br><span class="line">x-&gt;right = y-&gt;left;</span><br><span class="line"><span class="keyword">if</span>(y-&gt;left != T-&gt;nil) &#123;</span><br><span class="line">y-&gt;left-&gt;parent = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x上面那条线</span></span><br><span class="line">y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;parent == T-&gt;nil) &#123;  <span class="comment">// 如果x是根节点</span></span><br><span class="line">        T-&gt;root = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;left) &#123; <span class="comment">// 否则判断x是x父节点的左结点还是右节点</span></span><br><span class="line">    x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// y到b那条线</span></span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>红黑树的右旋操作：右旋就是向右倾斜，由于左旋和右旋是完全对称的，因此在代码上可以直接替换来实现右旋</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x --&gt; y, y --&gt;x </span></span><br><span class="line"><span class="comment">// left --&gt; right, right --&gt; left</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rbtree_right_rotate</span><span class="params">(<span class="keyword">struct</span> rbtree *T, rbtree_node *y)</span> &#123;</span><br><span class="line">    <span class="comment">// NULL --&gt; T-&gt;nil</span></span><br><span class="line">    <span class="keyword">if</span> (y == T-&gt;nil) <span class="keyword">return</span> ;</span><br><span class="line">    rbtree_node *x = y-&gt;left;</span><br><span class="line"><span class="comment">// y到x的那条线</span></span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != T-&gt;nil) &#123;</span><br><span class="line">        x-&gt;right-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// y上面那条线</span></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == T-&gt;nil) &#123;</span><br><span class="line">        T-&gt;root = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;right) &#123;</span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// x到b那条线</span></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意红黑树的左旋右旋代码执行顺序</p></blockquote><h3 id="红黑树插入结点后的调整"><a href="#红黑树插入结点后的调整" class="headerlink" title="红黑树插入结点后的调整"></a><strong>红黑树插入结点后的调整</strong></h3><blockquote><p>当插入一个结点时，有时要对红黑树进行调整，包括变色和左旋右旋以及回溯这三个操作</p></blockquote><p>CASE 1：父节点是爷结点的左子树 且 叔结点是红色的</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250813234540234.png" alt="image-20250813234540234" style="zoom:67%;" /><blockquote><p>无需旋转，只需要将父节点和叔结点变黑，将爷结点变红，然后令z指向爷结点即回溯调整</p></blockquote><p>CASE 2：父节点是叶结点的左子树的情况 且 叔结点是红色 以及 当前结点是右孩子</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250813235352684.png" alt="image-20250813235352684" style="zoom:67%;" /><blockquote><p>此时需要先旋转变为第三种情况，然后按照第三种情况处理，即让当前结点指向其父结点并进行一次左旋</p></blockquote><p>CASE 3：父节点是祖父结点的左子树 且 叔节点是黑色的 以及 当前结点是左孩子</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250813235727547.png" alt="image-20250813235727547" style="zoom:67%;" /><blockquote><p>此时需要先将当前结点的父节点变为黑色，以及让爷结点变为红色，然后让爷结点进行一次右旋</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rbtree_insert_fixup</span><span class="params">(rbtree *T, rbtree_node *z)</span> &#123;</span><br><span class="line"><span class="comment">// z是插入的结点，y是z的父节点，y是z的叔结点</span></span><br><span class="line">    <span class="comment">//只有当父节点是红的时需要调整，因为插入的节点必须为红，两个红色结点不能相邻</span></span><br><span class="line"><span class="keyword">while</span> (z-&gt;parent-&gt;color == RED) &#123; </span><br><span class="line"><span class="keyword">if</span> (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left) &#123;</span><br><span class="line">rbtree_node *y = z-&gt;parent-&gt;parent-&gt;right;</span><br><span class="line"><span class="keyword">if</span> (y-&gt;color == RED) &#123; <span class="comment">// 对应于CASE 1</span></span><br><span class="line">z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">y-&gt;color = BLACK;</span><br><span class="line">z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line"><span class="comment">// 回溯判断调整后是否满足红黑树条件</span></span><br><span class="line">z = z-&gt;parent-&gt;parent; <span class="comment">// z --&gt; RED</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (z == z-&gt;parent-&gt;right) &#123;  <span class="comment">// 对应于CASE 2</span></span><br><span class="line">z = z-&gt;parent;</span><br><span class="line">rbtree_left_rotate(T, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对应于CASE 3</span></span><br><span class="line">z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">rbtree_right_rotate(T, z-&gt;parent-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 而对于父节点是爷结点右子树的情况，只需要镜像替换即可</span></span><br><span class="line">             <span class="comment">// left -&gt; right, right -&gt; left</span></span><br><span class="line">rbtree_node *y = z-&gt;parent-&gt;parent-&gt;left;</span><br><span class="line"><span class="keyword">if</span> (y-&gt;color == RED) &#123;</span><br><span class="line">z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">y-&gt;color = BLACK;</span><br><span class="line">z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">z = z-&gt;parent-&gt;parent; <span class="comment">// z --&gt; RED</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (z == z-&gt;parent-&gt;left) &#123;</span><br><span class="line">z = z-&gt;parent;</span><br><span class="line">rbtree_right_rotate(T, z);</span><br><span class="line">&#125;</span><br><span class="line">z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">rbtree_left_rotate(T, z-&gt;parent-&gt;parent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">T-&gt;root-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树插入结点"><a href="#红黑树插入结点" class="headerlink" title="红黑树插入结点"></a><strong>红黑树插入结点</strong></h3><blockquote><p>插入其实很简单，不过是判断大小找到合适的插入位置</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rbtree_insert</span><span class="params">(rbtree *T, rbtree_node *z)</span> &#123;</span><br><span class="line">rbtree_node *y = T-&gt;nil;</span><br><span class="line">rbtree_node *x = T-&gt;root;</span><br><span class="line"><span class="keyword">while</span> (x != T-&gt;nil) &#123;</span><br><span class="line">y = x;</span><br><span class="line"><span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key) &#123;</span><br><span class="line">x = x-&gt;left;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &gt; x-&gt;key) &#123;</span><br><span class="line">x = x-&gt;right;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//Exist</span></span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">z-&gt;parent = y;</span><br><span class="line"><span class="keyword">if</span> (y == T-&gt;nil) &#123;</span><br><span class="line">T-&gt;root = z;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key) &#123;</span><br><span class="line">y-&gt;left = z;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">y-&gt;right = z;</span><br><span class="line">&#125;</span><br><span class="line">z-&gt;left = T-&gt;nil;</span><br><span class="line">z-&gt;right = T-&gt;nil;</span><br><span class="line">z-&gt;color = RED;</span><br><span class="line">rbtree_insert_fixup(T, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树删除结点"><a href="#红黑树删除结点" class="headerlink" title="红黑树删除结点"></a>红黑树删除结点</h3><blockquote><p>待办</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;C/C++全栈开发学习笔记&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;1-1-1-随处可见的红黑树&quot;&gt;&lt;a href=&quot;#1-1-1-随处可见的红黑树&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 随处可见的红黑树&quot;&gt;&lt;/a&gt;1.1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>FIO 测试学习文档</title>
    <link href="https://leeway2zc.top/2025/08/12/FIO-%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/"/>
    <id>https://leeway2zc.top/2025/08/12/FIO-%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</id>
    <published>2025-08-12T17:35:35.000Z</published>
    <updated>2025-08-21T00:52:53.145Z</updated>
    
    <content type="html"><![CDATA[<h1><center>FIO测试 学习文档</center></h1><h2 id="Job-File-配置文件执行-FIO-测试"><a href="#Job-File-配置文件执行-FIO-测试" class="headerlink" title="Job File 配置文件执行 FIO 测试"></a>Job File 配置文件执行 FIO 测试</h2><blockquote><p>通过编写一个ini格式的Job File来执行FIO测试，使用fio jobfile.fio完成测试</p></blockquote><h3 id="global-常用参数以及说明"><a href="#global-常用参数以及说明" class="headerlink" title="[global] 常用参数以及说明"></a>[global] 常用参数以及说明</h3><table><thead><tr><th>参数名</th><th>取值</th><th>作用说明</th></tr></thead><tbody><tr><td><code>iodepth_batch_complete</code></td><td><code>8</code></td><td>io请求过来后，能retrieve获得的最多请求数，即当io请求提交后，取出处理的io请求数</td></tr><tr><td><code>iodepth_batch</code></td><td>16</td><td>io队列请求丢过来后，积攒到16个io请求后立即提交，一般是iodepth的值</td></tr><tr><td><code>ioengine</code></td><td><code>libaio</code></td><td>使用 Linux 的异步 I&#x2F;O 引擎（libaio），适合测试真实负载环境</td></tr><tr><td><code>rw</code></td><td><code>read</code></td><td>I&#x2F;O 模式为顺序读（sequential read），用于测试读取吞吐能力，除了read还可以取值write,rw,randread,randwrite,randrw</td></tr><tr><td><code>bs</code></td><td><code>1M</code></td><td>每次 I&#x2F;O 操作的块大小为 1MB，影响数据吞吐与 IOPS</td></tr><tr><td><code>size</code></td><td><code>10G</code></td><td>每个 job 的总 I&#x2F;O 数据量上限为 10GB（如果不是基于时间模式才生效）</td></tr><tr><td><code>time_based</code></td><td><code>1</code></td><td>启用基于时间的测试模式，不以数据总量决定测试结束</td></tr><tr><td><code>runtime</code></td><td><code>30</code></td><td>测试持续时间为 30 秒</td></tr><tr><td><code>norandommap</code></td><td><code>1</code></td><td>禁用随机 I&#x2F;O 映射表，减少运行时开销，每个块可能多次读写可能不使用</td></tr><tr><td><code>randrepeat</code></td><td><code>1</code></td><td>使用固定的随机种子，每次运行能复现相同的随机序列</td></tr><tr><td><code>group_reporting</code></td><td><code>1</code></td><td>合并组内 job 的测试结果，统一输出</td></tr><tr><td><code>iodepth</code></td><td><code>8</code></td><td>设置每个 job 的 I&#x2F;O 队列深度为 8，控制并发请求数量，线程一次提出8个I&#x2F;O请求</td></tr><tr><td><code>direct</code></td><td><code>1</code></td><td>启用 Direct I&#x2F;O，跳过文件系统缓存，直接访问存储设备</td></tr><tr><td><code>numjobs</code></td><td><code>10</code></td><td>启动 10 个并发 job，提高测试负载并模拟多线程环境</td></tr><tr><td>thread</td><td>1</td><td>使用线程创建job，适合numjobs值很大的情况，模拟多应用高并发场景，但要求测试复杂度较低，需要处理同步问题，容易崩溃</td></tr><tr><td>ramp_time</td><td>30</td><td>跑每个job之前进行的预热时间</td></tr></tbody></table><h3 id="file-常用参数以及说明"><a href="#file-常用参数以及说明" class="headerlink" title="[file] 常用参数以及说明"></a>[file] 常用参数以及说明</h3><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806111305509.png" alt="image-20250806111305509"></p><table><thead><tr><th>参数名</th><th>取值</th><th>作用说明</th></tr></thead><tbody><tr><td><code>filename</code></td><td><code>/mnt/glfs/file0</code></td><td>指定测试文件的路径，这里是挂载在 <code>/mnt/glfs/</code> 下的一个文件，通常为分布式文件系统路径</td></tr></tbody></table><h2 id="命令行格式参数与说明"><a href="#命令行格式参数与说明" class="headerlink" title="命令行格式参数与说明"></a>命令行格式参数与说明</h2><blockquote><p>通过命令行参数执行 FIO 测试，便于与shell脚本结合使用</p></blockquote><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806111755997.png" alt="image-20250806111755997"></p><p>命令行参数含义如下：</p><p><code>--filename=...</code>：测试设备，这里是多个 NVMe 磁盘。</p><p><code>--direct=1</code>：绕过文件系统缓存，直接 I&#x2F;O。</p><p><code>--norandommap</code>：防止随机访问映射（提高随机性）。</p><p><code>--rw=$&#123;k&#125;</code>：I&#x2F;O 模式，传入变量 <code>k</code>，如 <code>read</code>、<code>write</code>。</p><p><code>--ioengine=libaio</code>：使用异步 I&#x2F;O 引擎。</p><p><code>--size=10G</code>：每个 job 的 I&#x2F;O 数据大小。</p><p><code>--iodepth=8</code>：每个 job 的 I&#x2F;O 队列深度。</p><p><code>--bs=$&#123;i&#125;</code>：块大小，传入变量 <code>i</code>。</p><p><code>--group_reporting</code>：报告时合并所有 job 的结果。</p><p><code>--name=test</code>：任务名。</p><p><code>--numjobs=$&#123;j&#125;</code>：并发 job 数量。</p><p><code>--runtime=$&#123;test_time&#125;</code>：测试时间（单位为秒），变量 <code>test_time</code> 应该事先定义。</p><p><code>--output=$&#123;result_file&#125;</code>：将结果输出到指定日志文件。</p><h2 id="fio-结果解读"><a href="#fio-结果解读" class="headerlink" title="fio 结果解读"></a>fio 结果解读</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=/dev/vdb -direct=1 -iodepth 32 -thread -rw=randrw -rwmixread=70 -ioengine=libaio -bs=16k -size=2G -numjobs=10 -runtime=60 -group_reporting -name=testfio</span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">testfio: (<span class="attr">g</span>=<span class="number">0</span>): rw=randrw, bs=(R) <span class="number">16.0</span>KiB-<span class="number">16.0</span>KiB, (W) <span class="number">16.0</span>KiB-<span class="number">16.0</span>KiB, (T) <span class="number">16.0</span>KiB-<span class="number">16.0</span>KiB, ioengine=libaio, iodepth=<span class="number">32</span></span><br><span class="line">...</span><br><span class="line">fio-3.7</span><br><span class="line">Starting 10 threads</span><br><span class="line">Jobs: 8 (<span class="attr">f</span>=<span class="number">8</span>): [m(<span class="number">4</span>),_(<span class="number">1</span>),m(<span class="number">3</span>),_(<span class="number">1</span>),m(<span class="number">1</span>)][<span class="number">91.9</span>%][r=<span class="number">677</span>MiB/s,w=<span class="number">291</span>MiB/s][r=<span class="number">43.4</span>k,w=<span class="number">18.6</span>k IOPS][eta <span class="number">00</span>m:<span class="number">03</span>s]</span><br><span class="line">testfio: (<span class="attr">groupid</span>=<span class="number">0</span>, jobs=<span class="number">10</span>): err= <span class="number">0</span>: pid=<span class="number">3335</span>: Thu Sep <span class="number">24</span> <span class="number">04</span>:<span class="number">25</span>:<span class="number">36</span> <span class="number">2020</span></span><br><span class="line">   read: <span class="attr">IOPS</span>=<span class="number">26.6</span>k, BW=<span class="number">416</span>MiB/s (<span class="number">436</span>MB/s)(<span class="number">13.0</span>GiB/<span class="number">34469</span>msec)</span><br><span class="line">    slat (usec): <span class="attr">min</span>=<span class="number">2</span>, max=<span class="number">375533</span>, avg=<span class="number">40.79</span>, stdev=<span class="number">1058.36</span></span><br><span class="line">    clat (usec): <span class="attr">min</span>=<span class="number">65</span>, max=<span class="number">455661</span>, avg=<span class="number">8296.62</span>, stdev=<span class="number">12218.78</span></span><br><span class="line">     lat (usec): <span class="attr">min</span>=<span class="number">76</span>, max=<span class="number">455669</span>, avg=<span class="number">8338.53</span>, stdev=<span class="number">12297.28</span></span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  <span class="attr">1.00th</span>=[   <span class="number">955</span>],  <span class="number">5.00</span>th=[  <span class="number">1745</span>], <span class="number">10.00</span>th=[  <span class="number">2245</span>], <span class="number">20.00</span>th=[  <span class="number">2868</span>],</span><br><span class="line">     | <span class="attr">30.00th</span>=[  <span class="number">3556</span>], <span class="number">40.00</span>th=[  <span class="number">4228</span>], <span class="number">50.00</span>th=[  <span class="number">4948</span>], <span class="number">60.00</span>th=[  <span class="number">5735</span>],</span><br><span class="line">     | <span class="attr">70.00th</span>=[  <span class="number">7177</span>], <span class="number">80.00</span>th=[ <span class="number">10159</span>], <span class="number">90.00</span>th=[ <span class="number">17957</span>], <span class="number">95.00</span>th=[ <span class="number">26608</span>],</span><br><span class="line">     | <span class="attr">99.00th</span>=[ <span class="number">51643</span>], <span class="number">99.50</span>th=[ <span class="number">63177</span>], <span class="number">99.90</span>th=[<span class="number">147850</span>], <span class="number">99.95</span>th=[<span class="number">189793</span>],</span><br><span class="line">     | <span class="attr">99.99th</span>=[<span class="number">287310</span>]</span><br><span class="line">   bw (  KiB/s): <span class="attr">min</span>=  <span class="number">768</span>, max=<span class="number">128736</span>, per=<span class="number">9.86</span>%, avg=<span class="number">41984.49</span>, stdev=<span class="number">31169.50</span>, samples=<span class="number">678</span></span><br><span class="line">   iops        : <span class="attr">min</span>=   <span class="number">48</span>, max= <span class="number">8046</span>, avg=<span class="number">2623.95</span>, stdev=<span class="number">1948.09</span>, samples=<span class="number">678</span></span><br><span class="line">  write: <span class="attr">IOPS</span>=<span class="number">11.4</span>k, BW=<span class="number">178</span>MiB/s (<span class="number">187</span>MB/s)(<span class="number">6149</span>MiB/<span class="number">34469</span>msec)</span><br><span class="line">    slat (usec): <span class="attr">min</span>=<span class="number">2</span>, max=<span class="number">397853</span>, avg=<span class="number">44.61</span>, stdev=<span class="number">1202.15</span></span><br><span class="line">    clat (usec): <span class="attr">min</span>=<span class="number">135</span>, max=<span class="number">455595</span>, avg=<span class="number">8322.44</span>, stdev=<span class="number">12370.30</span></span><br><span class="line">     lat (usec): <span class="attr">min</span>=<span class="number">148</span>, max=<span class="number">455605</span>, avg=<span class="number">8368.17</span>, stdev=<span class="number">12458.54</span></span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  <span class="attr">1.00th</span>=[   <span class="number">947</span>],  <span class="number">5.00</span>th=[  <span class="number">1762</span>], <span class="number">10.00</span>th=[  <span class="number">2245</span>], <span class="number">20.00</span>th=[  <span class="number">2868</span>],</span><br><span class="line">     | <span class="attr">30.00th</span>=[  <span class="number">3556</span>], <span class="number">40.00</span>th=[  <span class="number">4228</span>], <span class="number">50.00</span>th=[  <span class="number">4948</span>], <span class="number">60.00</span>th=[  <span class="number">5735</span>],</span><br><span class="line">     | <span class="attr">70.00th</span>=[  <span class="number">7177</span>], <span class="number">80.00</span>th=[ <span class="number">10290</span>], <span class="number">90.00</span>th=[ <span class="number">17957</span>], <span class="number">95.00</span>th=[ <span class="number">26870</span>],</span><br><span class="line">     | <span class="attr">99.00th</span>=[ <span class="number">51643</span>], <span class="number">99.50</span>th=[ <span class="number">62653</span>], <span class="number">99.90</span>th=[<span class="number">162530</span>], <span class="number">99.95</span>th=[<span class="number">193987</span>],</span><br><span class="line">     | <span class="attr">99.99th</span>=[<span class="number">421528</span>]</span><br><span class="line">   bw (  KiB/s): <span class="attr">min</span>=  <span class="number">288</span>, max=<span class="number">53120</span>, per=<span class="number">9.86</span>%, avg=<span class="number">18002.25</span>, stdev=<span class="number">13353.37</span>, samples=<span class="number">678</span></span><br><span class="line">   iops        : <span class="attr">min</span>=   <span class="number">18</span>, max= <span class="number">3320</span>, avg=<span class="number">1125.06</span>, stdev=<span class="number">834.58</span>, samples=<span class="number">678</span></span><br><span class="line">  lat (usec)   : <span class="attr">100</span>=<span class="number">0.01</span>%, <span class="number">250</span>=<span class="number">0.01</span>%, <span class="number">500</span>=<span class="number">0.06</span>%, <span class="number">750</span>=<span class="number">0.45</span>%, <span class="number">1000</span>=<span class="number">0.62</span>%</span><br><span class="line">  lat (msec)   : <span class="attr">2</span>=<span class="number">6.00</span>%, <span class="number">4</span>=<span class="number">30.00</span>%, <span class="number">10</span>=<span class="number">42.44</span>%, <span class="number">20</span>=<span class="number">12.12</span>%, <span class="number">50</span>=<span class="number">7.23</span>%</span><br><span class="line">  lat (msec)   : <span class="attr">100</span>=<span class="number">0.88</span>%, <span class="number">250</span>=<span class="number">0.18</span>%, <span class="number">500</span>=<span class="number">0.02</span>%</span><br><span class="line">  cpu          : <span class="attr">usr</span>=<span class="number">1.74</span>%, sys=<span class="number">3.50</span>%, ctx=<span class="number">47684</span>, majf=<span class="number">0</span>, minf=<span class="number">10</span></span><br><span class="line">  IO depths    : <span class="attr">1</span>=<span class="number">0.1</span>%, <span class="number">2</span>=<span class="number">0.1</span>%, <span class="number">4</span>=<span class="number">0.1</span>%, <span class="number">8</span>=<span class="number">0.1</span>%, <span class="number">16</span>=<span class="number">0.1</span>%, <span class="number">32</span>=<span class="number">100.0</span>%, &gt;=<span class="number">64</span>=<span class="number">0.0</span>%</span><br><span class="line">     submit    : <span class="attr">0</span>=<span class="number">0.0</span>%, <span class="number">4</span>=<span class="number">100.0</span>%, <span class="number">8</span>=<span class="number">0.0</span>%, <span class="number">16</span>=<span class="number">0.0</span>%, <span class="number">32</span>=<span class="number">0.0</span>%, <span class="number">64</span>=<span class="number">0.0</span>%, &gt;=<span class="number">64</span>=<span class="number">0.0</span>%</span><br><span class="line">     complete  : <span class="attr">0</span>=<span class="number">0.0</span>%, <span class="number">4</span>=<span class="number">100.0</span>%, <span class="number">8</span>=<span class="number">0.0</span>%, <span class="number">16</span>=<span class="number">0.0</span>%, <span class="number">32</span>=<span class="number">0.1</span>%, <span class="number">64</span>=<span class="number">0.0</span>%, &gt;=<span class="number">64</span>=<span class="number">0.0</span>%</span><br><span class="line">     issued rwts: <span class="attr">total</span>=<span class="number">917210</span>,<span class="number">393510</span>,<span class="number">0</span>,<span class="number">0</span> short=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> dropped=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">     latency   : <span class="attr">target</span>=<span class="number">0</span>, window=<span class="number">0</span>, percentile=<span class="number">100.00</span>%, depth=<span class="number">32</span></span><br><span class="line"></span><br><span class="line">Run status group 0 (all jobs):</span><br><span class="line">   READ: <span class="attr">bw</span>=<span class="number">416</span>MiB/s (<span class="number">436</span>MB/s), <span class="number">416</span>MiB/s-<span class="number">416</span>MiB/s (<span class="number">436</span>MB/s-<span class="number">436</span>MB/s), io=<span class="number">13.0</span>GiB (<span class="number">15.0</span>GB), run=<span class="number">34469</span>-<span class="number">34469</span>msec</span><br><span class="line">  WRITE: <span class="attr">bw</span>=<span class="number">178</span>MiB/s (<span class="number">187</span>MB/s), <span class="number">178</span>MiB/s-<span class="number">178</span>MiB/s (<span class="number">187</span>MB/s-<span class="number">187</span>MB/s), io=<span class="number">6149</span>MiB (<span class="number">6447</span>MB), run=<span class="number">34469</span>-<span class="number">34469</span>msec</span><br><span class="line"></span><br><span class="line">Disk stats (read/write):</span><br><span class="line">  vdb: <span class="attr">ios</span>=<span class="number">914415</span>/<span class="number">392173</span>, merge=<span class="number">0</span>/<span class="number">0</span>, ticks=<span class="number">5986235</span>/<span class="number">2577115</span>, in_queue=<span class="number">7910956</span>, util=<span class="number">65.39</span>%</span><br></pre></td></tr></table></figure><p>IOPS: 每秒的输入输出量(或读写次数)，是衡量磁盘性能的主要指标之一；</p><p>Bw: 带宽，带宽是指平均每秒读写的数据量。在同样的延时指标下，增加并发可以提高吞吐量。</p><blockquote><p>存储性能的好坏，需要IOPS、延迟、带宽三者结合来看</p></blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slat (usec): <span class="attr">min</span>=<span class="number">2</span>, max=<span class="number">397853</span>, avg=<span class="number">44.61</span>, stdev=<span class="number">1202.15</span></span><br><span class="line">clat (usec): <span class="attr">min</span>=<span class="number">135</span>, max=<span class="number">455595</span>, avg=<span class="number">8322.44</span>, stdev=<span class="number">12370.30</span></span><br><span class="line">lat (usec): <span class="attr">min</span>=<span class="number">148</span>, max=<span class="number">455605</span>, avg=<span class="number">8368.17</span>, stdev=<span class="number">12458.54</span></span><br></pre></td></tr></table></figure><p>I&#x2F;O延迟包括三种：slat，clat，lat：关系是 lat &#x3D; slat + clat；</p><ul><li>slat 表示fio submit某个I&#x2F;O的延迟；</li><li>clat 表示fio complete某个I&#x2F;O的延迟；</li><li>lat 表示从fio将请求提交给内核，再到内核完成这个I&#x2F;O为止所需要的时间；</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lat (usec)   : <span class="attr">100</span>=<span class="number">0.01</span>%, <span class="number">250</span>=<span class="number">0.01</span>%, <span class="number">500</span>=<span class="number">0.06</span>%, <span class="number">750</span>=<span class="number">0.45</span>%, <span class="number">1000</span>=<span class="number">0.62</span>%</span><br><span class="line">lat (msec)   : <span class="attr">2</span>=<span class="number">6.00</span>%, <span class="number">4</span>=<span class="number">30.00</span>%, <span class="number">10</span>=<span class="number">42.44</span>%, <span class="number">20</span>=<span class="number">12.12</span>%, <span class="number">50</span>=<span class="number">7.23</span>%</span><br><span class="line">lat (msec)   : <span class="attr">100</span>=<span class="number">0.88</span>%, <span class="number">250</span>=<span class="number">0.18</span>%, <span class="number">500</span>=<span class="number">0.02</span>%</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这组数据表明lat(latency：延迟 )的分布；有0.01%的request延迟&lt;100us，有0.01%的 100us &lt; request lat &lt; 250us，有0.06%的 250us &lt; request lat &lt; 500us，以此类推；</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpu          : <span class="attr">usr</span>=<span class="number">1.74</span>%, sys=<span class="number">3.50</span>%, ctx=<span class="number">47684</span>, majf=<span class="number">0</span>, minf=<span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>usr：表示用户空间进程；</li><li>sys：表示内核空间进程；</li><li>因为上下文切换导致的主要和次要页面失败的用户&#x2F;系统 CPU使用百分比。因为测试被配置的使用直接IO，因此有很少的页面失败：</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IO depths    : <span class="attr">1</span>=<span class="number">0.1</span>%, <span class="number">2</span>=<span class="number">0.1</span>%, <span class="number">4</span>=<span class="number">0.1</span>%, <span class="number">8</span>=<span class="number">0.1</span>%, <span class="number">16</span>=<span class="number">0.1</span>%, <span class="number">32</span>=<span class="number">0.1</span>%, &gt;=<span class="number">64</span>=<span class="number">99.9</span>%</span><br></pre></td></tr></table></figure><ul><li>iodepth设置用来控制在任何时间有多少IO分发给系统。这完全是应用方面的，意味着它和设备的IO队列做不同的事情，iodepth设置为1因此IO深度在100%的时间里一直是一个1；</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Run status group 0 (all jobs):</span><br><span class="line">   READ: <span class="attr">bw</span>=<span class="number">416</span>MiB/s (<span class="number">436</span>MB/s), <span class="number">416</span>MiB/s-<span class="number">416</span>MiB/s (<span class="number">436</span>MB/s-<span class="number">436</span>MB/s), io=<span class="number">13.0</span>GiB (<span class="number">15.0</span>GB), run=<span class="number">34469</span>-<span class="number">34469</span>msec</span><br><span class="line">  WRITE: <span class="attr">bw</span>=<span class="number">178</span>MiB/s (<span class="number">187</span>MB/s), <span class="number">178</span>MiB/s-<span class="number">178</span>MiB/s (<span class="number">187</span>MB/s-<span class="number">187</span>MB/s), io=<span class="number">6149</span>MiB (<span class="number">6447</span>MB), run=<span class="number">34469</span>-<span class="number">34469</span>msec</span><br></pre></td></tr></table></figure><ul><li>bw&#x3D;这组进程的总带宽，每个线程的带宽（设置了numjobs&gt;1这里会很明显）；</li><li>io&#x3D;这组总io大小；</li><li>线程的最小和最大时间；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Disk stats (read/write):</span><br><span class="line">  vdb: ios=914415/392173, merge=0/0, ticks=5986235/2577115, in_queue=7910956, util=65.39%</span><br></pre></td></tr></table></figure><ul><li>ios：读&#x2F;写 I&#x2F;O 次数</li><li>merge：合并的请求数</li><li>ticks：花在 I&#x2F;O 上的时间（ms）</li><li>in_queue：请求在队列里的时间（ms）</li><li>util：磁盘利用率（100% 说明磁盘一直在忙）</li></ul><h3 id="四个关键参数"><a href="#四个关键参数" class="headerlink" title="四个关键参数"></a>四个关键参数</h3><p><strong>bw（带宽）</strong></p><ul><li>顺序 I&#x2F;O 时：带宽是核心指标（HPC 大文件通常看 GB&#x2F;s）</li><li>随机 I&#x2F;O 时：带宽 + IOPS 结合看</li><li>判断合理性 → 和硬件理论上限比，例如 NVMe 单盘顺序写可达 3.5GB&#x2F;s，集群可叠加。</li></ul><p><strong>iops</strong></p><ul><li>小块随机 I&#x2F;O 的核心指标</li><li>HPC 元数据测试或数据库场景才特别看这个</li><li>和理论值比：NVMe 可到 700k IOPS（4KB 随机读），集群按并行度成倍增加。</li></ul><p><strong>延迟（slat &#x2F; clat &#x2F; lat）</strong></p><ul><li><code>slat</code> &#x3D; 提交延迟（fio 发出请求到内核调度的时间）</li><li><code>clat</code> &#x3D; 完成延迟（存储设备处理时间）</li><li><code>lat</code> &#x3D; 总延迟（两者之和）</li><li>重点看 <strong>平均值</strong> 和 <strong>高百分位数</strong>（如 99.99th）</li><li>判断合理性 → HPC 顺序 I&#x2F;O 延迟在 ms 级是正常，小块随机 NVMe 应在 100µs~1ms 内。</li></ul><p><strong>百分位延迟</strong></p><ul><li>HPC 场景需要看尾延迟（tail latency），因为并行任务很怕极端慢请求。</li><li>如果 99.99% 延迟明显高于平均值很多，说明系统在高并发下有抖动问题。</li></ul><h3 id="影响四个关键参数的主要-fio-参数"><a href="#影响四个关键参数的主要-fio-参数" class="headerlink" title="影响四个关键参数的主要 fio 参数"></a>影响四个关键参数的主要 fio 参数</h3><table><thead><tr><th>指标</th><th>关键影响参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>带宽 (bw)</strong></td><td><code>bs</code>（块大小）、<code>iodepth</code>、<code>numjobs</code>、<code>rw</code>（读写模式）</td><td>大块顺序 I&#x2F;O 通过较大 <code>bs</code> 和 <code>iodepth</code> 来提升吞吐；<code>numjobs</code> 多进程并发可叠加带宽。</td></tr><tr><td><strong>IOPS</strong></td><td><code>bs</code>、<code>iodepth</code>、<code>numjobs</code>、<code>rw</code></td><td>小块随机 I&#x2F;O 依赖更深队列 (<code>iodepth</code>) 和更多并发 (<code>numjobs</code>) 才能达到高 IOPS。</td></tr><tr><td><strong>延迟 (slat, clat, lat)</strong></td><td><code>iodepth</code>、<code>rw</code>, <code>ioengine</code></td><td><code>iodepth</code> 增大会带来排队延迟；<code>ioengine</code>（如 libaio vs sync）影响请求提交和完成方式，影响延迟。</td></tr><tr><td><strong>百分位延迟</strong></td><td>同上 + <code>iodepth_batch_complete</code>, <code>rate_iops</code>, <code>rate</code></td><td>控制批量完成和速率限制参数会影响尾延迟表现，调节请求节奏，避免峰值拥塞。</td></tr></tbody></table><h3 id="HPC-分布式存储系统中影响这四指标的因素"><a href="#HPC-分布式存储系统中影响这四指标的因素" class="headerlink" title="HPC 分布式存储系统中影响这四指标的因素"></a>HPC 分布式存储系统中影响这四指标的因素</h3><p><strong>硬件相关</strong></p><ul><li>存储介质类型：NVMe SSD、HDD、持久内存（PMEM）等带宽和延迟天差地别。</li><li>网络带宽和延迟：分布式存储中，网络往往成为瓶颈，影响总体带宽和延迟。</li><li>缓存策略：客户端缓存、服务器端缓存会降低实际 I&#x2F;O 延迟，提高带宽。</li></ul><p><strong>软件&#x2F;协议相关</strong></p><ul><li>并行访问算法：<ul><li>文件分条（striping）、条带大小（stripe size）</li><li>数据复制策略（副本数、纠删码参数）</li><li>并发调度策略（请求合并、重排）</li></ul></li><li>I&#x2F;O 协议栈：<ul><li>NFS, SMB, Lustre, BeeGFS 等协议处理效率和并发能力差异</li><li>TCP&#x2F;IP 堆栈优化，RDMA 等低延迟传输方式</li></ul></li><li>负载均衡：<ul><li>多客户端多请求分配到不同存储节点，均衡访问才能保持带宽和低延迟。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>指标</th><th>HPC存储影响因素（示例）</th><th>典型调优建议</th></tr></thead><tbody><tr><td><strong>bw</strong></td><td>硬件带宽、网络带宽、并发数、条带大小</td><td>大块顺序读写，提升 <code>bs</code>、<code>iodepth</code>、<code>numjobs</code></td></tr><tr><td><strong>iops</strong></td><td>NVMe能力、并行请求数、负载均衡</td><td>增加随机小块 <code>iodepth</code> 和 <code>numjobs</code>，用异步 <code>ioengine</code></td></tr><tr><td><strong>延迟</strong></td><td>协议栈效率、存储介质响应时间、队列长度</td><td>适当控制 <code>iodepth</code>，避免队列过深导致排队延迟</td></tr><tr><td><strong>尾延迟</strong></td><td>突发负载、缓存失效、网络抖动</td><td>使用 <code>iodepth_batch_complete</code> 等批量参数，限速避免过载</td></tr></tbody></table><h2 id="读写混合测试（randrw）的具体流程"><a href="#读写混合测试（randrw）的具体流程" class="headerlink" title="读写混合测试（randrw）的具体流程"></a>读写混合测试（<code>randrw</code>）的具体流程</h2><p>举例<code>randrw</code> + <code>iodepth=16</code> + <code>numjobs=1</code>：</p><ul><li><strong>准备阶段</strong><ul><li>fio打开目标文件 <code>/tmp/testfile</code>，文件大小100M。</li><li>根据<code>bs=4k</code>，文件被切成约 25,600 个块（100M&#x2F;4k）。</li></ul></li><li><strong>执行阶段</strong><ul><li>fio的单线程循环：<ul><li>它随机选择一个块（因为是<code>randrw</code>，随机读写）。</li><li>根据<code>rwmixread=70</code>，它有70%概率选择读，30%概率选择写。</li><li>提交一个异步I&#x2F;O请求到操作系统（通过<code>libaio</code>）。</li></ul></li><li>同时，它不会等第一个请求完成就停住，而是会继续提交请求，直到挂起的请求数达到<code>iodepth=16</code>。</li><li>当某个I&#x2F;O完成，线程会收到通知，然后提交下一个请求，保持挂起请求数量稳定在16左右。</li></ul></li><li><strong>总结</strong><ul><li>这样，fio的单线程模拟了一个深队列、高并发的I&#x2F;O负载。</li><li>存储设备能同时处理多个请求，提高吞吐量。</li><li>fio收集带宽、IOPS、延迟等指标，反映设备在这种负载下的表现。</li></ul></li></ul><h2 id="示例-FIO-代码仓库"><a href="#示例-FIO-代码仓库" class="headerlink" title="示例 FIO 代码仓库"></a>示例 FIO 代码仓库</h2><ol><li><p><a href="https://github.com/storpool/fio-tests">The StorPool FIO Test Suite</a>  这个仓库提供基于FIO的块存储性能测试脚本，专为分布式存储系统（如StorPool集群）设计，支持在HPC环境中运行多节点测试。包括预定义的测试模板，适用于随机&#x2F;顺序读写基准，适合分布式块存储的性能评估。仓库中有template目录下的.fio配置文件模板。</p></li><li><p><a href="https://github.com/axboe/fio">axboe&#x2F;fio仓库（FIO官方仓库</a>  FIO工具的官方GitHub仓库，examples&#x2F;目录下有大量通用FIO job文件示例。虽然不是专为HPC分布式存储设计，但许多配置（如SSD或NVMe测试）可以修改用于分布式环境（如在HPC集群的多节点并行运行）。例如，ssd-steady.fio适用于高性能存储基准，可结合MPI或脚本实现分布式测试。</p></li><li><p><a href="https://github.com/distributed-system-analysis/pbench">distributed-system-analysis&#x2F;pbench仓库</a>  pbench工具集中的FIO基准脚本，专为存储性能测试设计，支持HPC环境下的自动化测试，包括随机&#x2F;顺序工作负载和统计计算。适用于分布式系统，如在集群中测试文件系统I&#x2F;O。文档中描述了如何配置FIO参数以模拟HPC场景。</p></li><li><p><a href="https://github.com/ls1intum/storage-benchmarking">ls1intum&#x2F;storage-benchmarking仓库</a>  使用FIO测试容器化环境中的I&#x2F;O性能，适用于分布式存储系统（如Kubernetes集群中的HPC应用）。仓库提供预定义的job配置，适合基准测试分布式存储的性能比较。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;FIO测试 学习文档&lt;/center&gt;&lt;/h1&gt;

&lt;h2 id=&quot;Job-File-配置文件执行-FIO-测试&quot;&gt;&lt;a href=&quot;#Job-File-配置文件执行-FIO-测试&quot; class=&quot;headerlink&quot; title=&quot;Job File 配</summary>
      
    
    
    
    <category term="存储测试教程" scheme="https://leeway2zc.top/categories/%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="存储测试教程" scheme="https://leeway2zc.top/tags/%E5%AD%98%E5%82%A8%E6%B5%8B%E8%AF%95%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核实验笔记</title>
    <link href="https://leeway2zc.top/2025/08/11/Linux%E5%86%85%E6%A0%B8%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    <id>https://leeway2zc.top/2025/08/11/Linux%E5%86%85%E6%A0%B8%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</id>
    <published>2025-08-11T17:04:55.000Z</published>
    <updated>2025-08-21T00:52:53.145Z</updated>
    
    <content type="html"><![CDATA[<h1><center>OS2 内核编程和驱动程序开发实验</center></h1><blockquote><p>基于布加勒斯特理工大学自动控制与计算机学院计算机科学与工程系的 “操作系统2” 课程</p></blockquote><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h3><ul><li>主机：在win10上使用oracle virtualbox创建的 ubuntu 20.04 作为上位机，用于编辑模块源代码、编译模块、将模块应用到操作系统上等</li><li>虚拟机：通过Docker配置虚拟机模拟OS内核，在ubuntu 20.04上直接使用，通过脚本运行完成内核模块代码测试</li></ul><h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><blockquote><p>若提示用户没有sudo权限，使用<code>su -</code>切换到 root 用户即可，密码是虚拟机设置镜像时自己设置的，一般就是开机密码</p></blockquote><ol><li><p>在ubuntu 20.04中安装Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加 Docker 官方 GPG 密钥</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \</span><br><span class="line">    <span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加 Docker 软件源</span></span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> \</span></span><br><span class="line"><span class="string">  signed-by=/etc/apt/keyrings/docker.gpg] \</span></span><br><span class="line"><span class="string">  https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | \</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 更新 apt 并安装 Docker</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 启动并设置开机启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure></li><li><p>在ubuntu 20.04中安装必需软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y flex bison build-essential gcc-multilib libncurses5-dev \</span><br><span class="line">qemu-system-x86 qemu-system-arm python3 minicom</span><br></pre></td></tr></table></figure></li><li><p>创建一个脚本文件并编辑如下内容，随后运行脚本</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ $(<span class="built_in">id</span> -u) != <span class="string">&quot;0&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Please run as root (or use sudo)&quot;</span></span><br><span class="line">   <span class="built_in">exit</span> 1 </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#================================= CONSTANTS =================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"></span><br><span class="line">RED=<span class="string">&#x27;\033[0;31m&#x27;</span></span><br><span class="line">NC=<span class="string">&#x27;\033[0m&#x27;</span></span><br><span class="line"></span><br><span class="line">DEFAULT_IMAGE_NAME=<span class="string">&quot;so2/so2-assignments&quot;</span></span><br><span class="line">DEFAULT_TAG=<span class="string">&#x27;latest&#x27;</span></span><br><span class="line">DEFAULT_REGISTRY=<span class="string">&#x27;gitlab.cs.pub.ro:5050&#x27;</span></span><br><span class="line">SO2_WORKSPACE=<span class="string">&quot;/linux/tools/labs&quot;</span></span><br><span class="line">SO2_VOLUME=<span class="string">&quot;SO2_DOCKER_VOLUME&quot;</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#=================================== UTILS ===================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">LOG_INFO</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[<span class="subst">$(date +%FT%T)</span>] [INFO] <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">LOG_FATAL</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[<span class="subst">$(date +%FT%T)</span>] [<span class="variable">$&#123;RED&#125;</span>FATAL<span class="variable">$&#123;NC&#125;</span>] <span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print_help</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;local.sh docker interactive [--privileged]&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;      --privileged - run a privileged container. This allows the use of KVM (if available)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;      --allow-gui - run the docker such that it can open GUI apps&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">docker_interactive</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> full_image_name=<span class="string">&quot;<span class="variable">$&#123;DEFAULT_REGISTRY&#125;</span>/<span class="variable">$&#123;DEFAULT_IMAGE_NAME&#125;</span>:<span class="variable">$&#123;DEFAULT_TAG&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">local</span> executable=<span class="string">&quot;/bin/bash&quot;</span></span><br><span class="line">    <span class="built_in">local</span> registry=<span class="variable">$&#123;DEFAULT_REGISTRY&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> [[ <span class="variable">$#</span> -gt 0 ]]; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        --privileged)</span><br><span class="line">            privileged=--privileged</span><br><span class="line">            ;;</span><br><span class="line">        --allow-gui)</span><br><span class="line">            allow_gui=<span class="literal">true</span></span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            print_help</span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ $(docker images -q <span class="variable">$full_image_name</span> 2&gt; /dev/null) == <span class="string">&quot;&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        docker pull <span class="variable">$full_image_name</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ! docker volume inspect <span class="variable">$SO2_VOLUME</span> &gt;/dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Volume <span class="variable">$SO2_VOLUME</span> does not exist.&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Creating it&quot;</span></span><br><span class="line">docker volume create <span class="variable">$SO2_VOLUME</span></span><br><span class="line"><span class="built_in">local</span> vol_mount=$(docker inspect <span class="variable">$SO2_VOLUME</span> | grep -i mountpoin | <span class="built_in">cut</span> -d : -f2 | <span class="built_in">cut</span> -d, -f1)</span><br><span class="line"><span class="built_in">chmod</span> 777 -R <span class="variable">$vol_mount</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The /linux directory is made persistent within the <span class="variable">$SO2_VOLUME</span>:&quot;</span></span><br><span class="line">    docker inspect <span class="variable">$SO2_VOLUME</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$allow_gui</span>; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO: remove this after you change sdl to gtk in qemu-runqemu.sh</span></span><br><span class="line"> docker run <span class="variable">$privileged</span> --<span class="built_in">rm</span> -it --cap-add=NET_ADMIN --device /dev/net/tun:/dev/net/tun \</span><br><span class="line">        -v <span class="variable">$SO2_VOLUME</span>:/linux \</span><br><span class="line">        --workdir <span class="string">&quot;<span class="variable">$SO2_WORKSPACE</span>&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$full_image_name</span>&quot;</span> sed <span class="string">&quot;s+\$&#123;QEMU_DISPLAY:-\&quot;sdl\&quot;+\$&#123;QEMU_DISPLAY:-\&quot;gtk\&quot;+g&quot;</span> -i /linux/tools/labs/qemu/run-qemu.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># wsl</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cat</span> /proc/version | grep -i microsoft &amp;&gt; /dev/null ; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">export</span> DISPLAY=<span class="string">&quot;<span class="subst">$(ip r show default | awk &#x27;&#123;print $3&#125;&#x27;)</span>:0.0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$DISPLAY</span> == <span class="string">&quot;&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Error: Something unexpected happend. The environment var DISPLAY is not set. Consider setting it with&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\texport DISPLAY=&lt;dispaly&gt;&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> xauth_var=$(<span class="built_in">echo</span> $(xauth info | grep Auth | <span class="built_in">cut</span> -d: -f2))</span><br><span class="line">        docker run --privileged --<span class="built_in">rm</span> -it \</span><br><span class="line">        --net=host --<span class="built_in">env</span>=<span class="string">&quot;DISPLAY&quot;</span> --volume=<span class="string">&quot;<span class="variable">$&#123;xauth_var&#125;</span>:/root/.Xauthority:rw&quot;</span> \</span><br><span class="line">        -v <span class="variable">$SO2_VOLUME</span>:/linux \</span><br><span class="line">        --workdir <span class="string">&quot;<span class="variable">$SO2_WORKSPACE</span>&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$full_image_name</span>&quot;</span> <span class="string">&quot;<span class="variable">$executable</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        docker run <span class="variable">$privileged</span> --<span class="built_in">rm</span> -it --cap-add=NET_ADMIN --device /dev/net/tun:/dev/net/tun \</span><br><span class="line">        -v <span class="variable">$SO2_VOLUME</span>:/linux \</span><br><span class="line">        --workdir <span class="string">&quot;<span class="variable">$SO2_WORKSPACE</span>&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$full_image_name</span>&quot;</span> <span class="string">&quot;<span class="variable">$executable</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">docker_main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;interactive&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">        docker_interactive <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;docker&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    docker_main <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;-h&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;--help&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    print_help</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    print_help</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在终端运行脚本</span></span><br><span class="line"><span class="built_in">sudo</span> bash ./local.sh docker interactive --privileged</span><br></pre></td></tr></table></figure><blockquote><p>显示如下内容时说明配置成功</p></blockquote><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250804165404202.png" alt="image-20250804165404202" style="zoom:67%;" /><ol start="4"><li><p>此时根目录下会出现一个目录&#x2F;linux，这是docker虚拟挂载出来的，只有执行脚本时才会出现这个目录。&#x2F;linux&#x2F;tools&#x2F;lab是这个docker容器的工作目录，是我们编译模块和启动虚拟机的地方。</p></li><li><p>需要两个Docker内部的终端，通过tmux(终端复用器)可以得到分离的两个终端，输入指令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$tmux</span></span><br></pre></td></tr></table></figure><p>使用ctrl+b然后shift+”可以得到水平分割的两个终端，如下所示</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/docker_tmux_VM.png" style="zoom:67%;" /><blockquote><p>使用ctrl+b然后shift+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>可以得到垂直分割的两个终端，但是不方便复制代码</mtext></mrow><annotation encoding="application/x-tex">可以得到垂直分割的两个终端，但是不方便复制代码</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">可以得到垂直分割的两个终端，但是不方便复制代码</span></span></span></span>   &gt; 使用ctrl+b然后按下 [ 可以自由浏览终端界面，方便复制粘贴代码<br>使用ctrl+b然后按下 d 可以推出tmux，但这会杀死所有tmux正在执行的进程</p></blockquote></li><li><p>配置好环境以后就可以进行试验了，将上面的窗格作为虚拟机OS2，下面的窗格作为主机Docker容器，在上面的窗格中执行以下命令即可生成骨架，开始实验</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ LABS=&lt;实验名称&gt; make skels</span><br></pre></td></tr></table></figure></li><li><p>接下来要启动虚拟机，执行 <code>make console</code> 使用 <code>root</code> 用户名登陆</p></li><li><p>我们的工作流程包括：在Docker内编写模块代码，修改Make|Kbuild文件，执行make build编译得到ko模块，然后在虚拟机中通过 <code>insmod</code> 命令将其插入到虚拟机，或者通过 <code>rmmod</code> 将其移除。</p><blockquote><p>每次构建模块无需重启虚拟机，停止虚拟机的操作是 ctrl+a，然后按下 q</p></blockquote></li></ol><h2 id="一-内核模块"><a href="#一-内核模块" class="headerlink" title="一 内核模块"></a>一 内核模块</h2><h3 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h3><ul><li>创建简单的模块</li><li>描述内核模块编译的过程</li><li>展示如何在内核中使用模块</li><li>简单的内核调试方法</li></ul><h3 id="1-内核模块的使用-加载-卸载"><a href="#1-内核模块的使用-加载-卸载" class="headerlink" title="1 内核模块的使用|加载|卸载"></a>1 内核模块的使用|加载|卸载</h3><blockquote><p>使用 make console 启动虚拟机，并完成以下任务 (正确启动虚拟机以及上位机应该是下面这个界面)</p></blockquote><ol><li>使用<code>ctrl+alt+t</code>打开一个终端，确保pwd下有文件<code>local.sh</code>，使用以下代码进入docker容器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash ./local.sh docker interactive --privileged</span><br></pre></td></tr></table></figure><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/%E4%B8%8A%E4%BD%8D%E6%9C%BA.png"  /><ol start="2"><li>在docker容器中构建骨架，编写模块代码，编译模块，然后启动虚拟机安装测试模块</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在docker容器中构建骨架，在里面编写代码</span></span><br><span class="line"><span class="comment"># 实验名称一般是skel目录下的目录路径如LABS=&quot;kernel_modules/6-cmd-mod kernel_modules/8-kprobes&quot;</span></span><br><span class="line">LABS=&lt;实验名称&gt; make skels</span><br><span class="line"><span class="comment"># 编写完成后，修改Make和Kbuild文件，使用 make build 编译得到 .ko 模块文件，就可以测试了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用tmux分离出一个终端，使用make console启动虚拟机</span></span><br><span class="line">make console <span class="comment">#使用root用户名login，效果如下，此时主机名为qemu</span></span><br></pre></td></tr></table></figure><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/xv6%E8%99%9A%E6%8B%9F%E6%9C%BA.png"></p><ul><li>加载内核模块<ol><li>在 <code>~/skels/kernel_modules</code> 目录下有很多模块目录，里面存放要完成的任务</li></ol></li></ul><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806091936889.png" alt="image-20250806091936889"></p><p>​          2. 在 <code>1-2-test-mod</code> 这个目录下，执行命令 <code>insmod hello_mod.ko</code> 完成模块加载</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806092135698.png" alt="image-20250806092135698"></p><ul><li><p>列出内核模块并检查当前模块是否存在</p><ol><li><p>使用指令 <code>lsmod</code>  查看模块是否加载成功</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806092445847.png" alt="image-20250806092445847" style="zoom:67%;" /></li></ol></li><li><p>卸载内核模块</p><ol><li>使用指令 <code>rmmod hello_mod</code> (不需要后缀) 完成模块卸载</li></ol></li><li><p>使用 <strong>dmesg</strong> 命令查看加载&#x2F;卸载内核模块时显示的消息</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806092748489.png" alt="image-20250806092748489"></p></li></ul><h3 id="2-Printk"><a href="#2-Printk" class="headerlink" title="2 Printk"></a>2 Printk</h3><blockquote><p>配置系统，使消息不直接显示在串行控制台上，只能使用 <code>dmesg</code> 命令来查看</p></blockquote><ul><li><p>使用命令 <code>echo &quot;4 4 1 7&quot; &gt; /proc/sys/kernel/printk</code> 修改打印日志行为设置</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806093723057.png" alt="image-20250806093723057"></p></li><li><p>此时再加载模块就不会显示消息在串行控制台上了</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806094004426.png" alt="image-20250806094004426"></p></li></ul><h3 id="3-错误"><a href="#3-错误" class="headerlink" title="3 错误"></a>3 错误</h3><blockquote><p>生成名为 <strong>3-error-mod</strong> 的任务的框架。编译源代码并得到相应的内核模块。</p><p>为什么会出现编译错误? <strong>提示:</strong> 这个模块与前一个模块有什么不同？</p><p>修改该模块以解决这些错误的原因，然后编译和测试该模块。</p></blockquote><ul><li><p>根据TODO提示，缺少头文件 <code>&lt;linux/module.h&gt;</code>，添加后能编译成功</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806104845849.png" alt="image-20250806104845849"></p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806104917752.png" alt="image-20250806104917752"></p></li></ul><h3 id="4-子模块"><a href="#4-子模块" class="headerlink" title="4 子模块"></a>4 子模块</h3><blockquote><p>查看 <code>4-multi-mod/</code> 目录中的 C 源代码文件 <code>mod1.c</code> 和 <code>mod2.c</code>。模块 2 仅包含模块 1 使用的函数的定义。</p><p>修改 <code>Kbuild</code> 文件，从这两个 C 源文件创建 <code>multi_mod.ko</code> 模块。</p><p>编译、复制、启动虚拟机、加载和卸载内核模块。确保消息在控制台上正确显示。</p></blockquote><ol><li><p>使用 <code>LABS=&quot;kernel_modules/4-multi-mod&quot; make skels</code> 构建骨架</p></li><li><p>在目录 <code>root@ubuntu20:/linux/tools/labs/skels/kernel_modules/4-multi-mod</code> 中修改Kbuild文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> add rules to create a multi object module</span></span><br><span class="line">obj-m = multi-mod.o</span><br><span class="line">multi-mod-y = mod1.o mod2.o</span><br></pre></td></tr></table></figure></li><li><p>然后 <code>cd /linux/tools/labs</code> 进行编译 <code>make build</code></p></li><li><p>启动虚拟机，加载和卸载 <code>multi-mod.ko</code> 模块</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806161240091.png" alt="image-20250806161240091" style="zoom:67%;" /></li></ol><h3 id="5-内核-oops"><a href="#5-内核-oops" class="headerlink" title="5 内核 oops"></a>5 内核 oops</h3><blockquote><p>学习当内核模块代码有问题导致模块插入后内核发生了错误应该怎么处理</p></blockquote><ol><li><p>使用 <code>LABS=&quot;kernel_modules/5-oops-mod&quot; make skels</code>  构建骨架</p></li><li><p>在 <code>root@ubuntu20:/linux/tools/labs/skels/kernel_modules/5-oops-mod</code> 中修改Kbuild文件，为Kbuild文件添加编译标记，使得之后在安装模块时，会出现编译过程信息，提示哪里出现了问题</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> add flags to generate debug information</span></span><br><span class="line">ccflags-y += -g</span><br><span class="line"></span><br><span class="line">obj-m = oops_mod.o</span><br></pre></td></tr></table></figure></li><li><p><code>make build</code> 进行编译，然后在虚拟机中安装模块 <code>insmod oops_mod.ko</code> 会输出很长一段编译信息，其中最重要的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 告诉我们错误的原因</span><br><span class="line">BUG: kernel NULL pointer dereference, address: 00000000</span><br><span class="line"># 告诉我们这是第一个 oops（#1）</span><br><span class="line">Oops: 0002 [#1] SMP</span><br><span class="line"># 造成错误的指令的地址，它解码了指令指针 (EIP) 的值，并指出错误出现在 my_oops_init 函数中，偏移为 d个字节</span><br><span class="line">EIP: my_oops_init+0xd/0x22 [oops_mod]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oops 代码（0002）提供了有关错误类型的信息（参见 arch/x86/include/asm/trap_pf.h ）：</span><br><span class="line"></span><br><span class="line">第 0 位 == 0 表示找不到页面，1 表示保护故障</span><br><span class="line">第 1 位 == 0 表示读取，1 表示写入</span><br><span class="line">第 2 位 == 0 表示内核模式，1 表示用户模式</span><br></pre></td></tr></table></figure></li><li><p>有了 EIP 值就可以使用 address2line 来找到出错的代码出现的位置，在主机中使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addr2line -e oops_mod.ko +0xd</span><br><span class="line">/linux/tools/labs/skels/./kernel_modules/5-oops-mod/oops_mod.c:15</span><br></pre></td></tr></table></figure><p>可以知道是 oops_mod.c 的第 15 行出现了问题</p></li><li><p>由于oops_mod.ko模块加载卡住了，所以无法正常卸载，因此要重启虚拟机才能完成卸载</p><blockquote><p>模块加载必须经过init函数以及注册exit函数</p></blockquote></li><li><p>重启虚拟机之后，删去第15行代码，重新编译以及插入模块即可完成模块的加载与卸载</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250807083857615.png" alt="image-20250807083857615" style="zoom:67%;" /></li></ol><h3 id="6-模块参数"><a href="#6-模块参数" class="headerlink" title="6 模块参数"></a>6 模块参数</h3><blockquote><p>在不修改源代码 <code>cmd_mod.c</code> 的情况下，加载内核模块以显示消息 <code>Early bird gets tired</code></p></blockquote><ul><li><p>通过命令行传递参数可以修改函数变量的值从而输出特定内容</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250807090120386.png" alt="image-20250807090120386" style="zoom: 80%;" /></li><li><p>使用命令行传递参数需要源代码满足以下条件</p><ol><li><p>变量必须是模块级别的全局变量，不能是函数内部变量，必须像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *str = <span class="string">&quot;default&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>module_param()</code> 宏声明该变量为模块参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">str：变量名</span></span><br><span class="line"><span class="comment">charp：变量类型（支持 int、charp、bool、ulong 等）</span></span><br><span class="line"><span class="comment">0：权限标志位（sysfs 中的访问权限）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">module_param(str, charp, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>模块必须使用标准 <code>init</code> &#x2F; <code>exit</code> 入口函数机制，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span> &#123; ... &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span> &#123; ... &#125;</span><br><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_exit);</span><br><span class="line"># 这样，内核在执行 insmod 时会先处理模块参数，再调用 init 函数。</span><br></pre></td></tr></table></figure></li><li><p>模块参数变量声明前不能加 <code>const</code> 因为内核需要在运行时修改它</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// ❌ 无法作为 module_param</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="7-进程信息"><a href="#7-进程信息" class="headerlink" title="7 进程信息"></a>7 进程信息</h3><blockquote><p>检查名为 <strong>7-list-proc</strong> 的任务的框架。添加代码来显示当前进程的进程 ID（ <code>PID</code> ）和可执行文件名</p></blockquote><ol><li><p>执行 <code>root@ubuntu20:/linux/tools/labs/skels/kernel_modules/7-list-proc# vim list_proc.c</code> 命令，修改 <code>list_proc.c</code> 文件源代码</p></li><li><p>在注释TO DO处添加如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> add missing headers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched/signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/* TODO/2: print current process pid and its name */</span></span><br><span class="line">pr_info(<span class="string">&quot;Current process: pid = %d; comm = %s\n&quot;</span>,</span><br><span class="line">        current-&gt;pid, current-&gt;comm);</span><br><span class="line"><span class="comment">/* TODO/3: print the pid and name of all processes */</span></span><br><span class="line">pr_info(<span class="string">&quot;\nProcess list:\n\n&quot;</span>);</span><br><span class="line">for_each_process(p)</span><br><span class="line">        pr_info(<span class="string">&quot;pid = %d; comm = %s\n&quot;</span>, p-&gt;pid, p-&gt;comm);</span><br><span class="line"><span class="comment">/* TODO/2: print current process pid and name */</span></span><br><span class="line">pr_info(<span class="string">&quot;Current process: pid = %d; comm = %s\n&quot;</span>,</span><br><span class="line">        current-&gt;pid, current-&gt;comm);</span><br></pre></td></tr></table></figure></li><li><p>编译执行得到如下输出</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250807100210962.png" alt="image-20250807100210962" style="zoom:67%;" /></li><li><p>这里得查很多资料才能知道这些代码是什么意思</p></li></ol><h3 id="8-KDB"><a href="#8-KDB" class="headerlink" title="8 KDB"></a>8 KDB</h3><blockquote><p>使用KDB(Kernel Debugger)分析堆栈找出错误代码位置|使用KDB找到模块加载的地址|在一个新窗口中使用 GDB 并根据 KDB 提供的信息查看代码(没解决)</p></blockquote><ol><li><p>在虚拟机中配置KDB使用hvc0串口 <code>echo hvc0 &gt; /sys/module/kgdboc/parameters/kgdboc</code></p></li><li><p>使用 SysRq 命令启用 KDB (<strong>Ctrl + O g</strong>)，此时进入KDB调试命令行，输入Help可查看可用KDB命令，如果出现乱码例如文字显示不出来，很多乱码挤在界面右侧，是因为minicom的换行格式有问题，按下 ctrl + A 然后按下 U(或者L)，这样会将minicom从列显示模式切换到行显示模式，此时输出即可恢复正常</p><blockquote><p> kdb&gt; “这里输入go可以继续执行内核跳出kdb调试，按回车是重新输入并执行上一个命令，按↑是显示上一个命令”</p></blockquote></li><li><p>加载 <code>hello_kdb</code> 模块。该模块在写入 <code>/proc/hello_kdb_bug</code> 文件时会模拟一个错误。使用以下命令模拟错误：<code>echo 1 &gt; /proc/hello_kdb_bug</code></p></li><li><p>运行这个命令就会发生oops错误，然后会进入KDB调试命令行，使用 <code>[0]kdb&gt; bt</code> 即可分析堆栈跟踪并确定导致错误的代码，bt输出的最下面是执行的起始处(堆栈跟踪要从后往前看)，有些行前面的 ? 是指KDB不确定这个地址偏移是否计算正确，bt输出中最重要的就是kgbd_panic、kgdb_breakpoint这两个点，这表明有函数执行之后发生了错误，可以看到kgbd_panic下面的函数是panic，panic下面的函数是dummy_func1并指明它是 hello_kdb.c文件中的函数，所以错误代码就是 hello_kdb.c 中的函数 dummy_func1 有问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">notify_die+0x4d/0x90</span><br><span class="line">exc_int3+0x5c/0x140</span><br><span class="line">handle_exception+0x140/0x140</span><br><span class="line">EIP: kgdb_breakpoint+0xe/0x20                                                         </span><br><span class="line">Code: b4 26 00 00 00 00 8d b6 00 00 00 00 31 c0 c3 8d b4 26 00 00 00 00 8d b6 00 00 00 00 3e ff8</span><br><span class="line">EAX: 0000001e EBX: c40b9e00 ECX: 00000000 EDX: 00000000</span><br><span class="line">ESI: c180e898 EDI: c1badb40 EBP: c4519e2c ESP: c4519e20                               </span><br><span class="line">DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068 EFLAGS: 00000002                         </span><br><span class="line">? exc_general_protection+0x2c0/0x2c0                                                 </span><br><span class="line">? kgdb_breakpoint+0xe/0x20                                                           </span><br><span class="line">? kgdb_panic+0x4d/0x60                                                               </span><br><span class="line">panic+0xbc/0x266                                                                     </span><br><span class="line">? dummy_func1+0x8/0x8 [hello_kdb]                                                     </span><br><span class="line">dummy_func18+0xd/0xd [hello_kdb]                                                     </span><br><span class="line">dummy_func17+0x8/0x8 [hello_kdb] </span><br></pre></td></tr></table></figure></li><li><p>使用 <code>[0]kdb&gt; lsmod</code> 可以看到模块的加载地址</p><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250808170413340.png" alt="image-20250808170413340"></p></li></ol><h2 id="二-内核-API"><a href="#二-内核-API" class="headerlink" title="二 内核 API"></a>二 内核 API</h2><p>实验目标：</p><ul><li><p>熟悉基本的Linux内核API</p><blockquote><p>内核是一个独立运行的实体，不能调用用户空间的任何库，所以不能使用printf、malloc、free等常见的用户控件函数</p></blockquote></li><li><p>描述内存分配机制</p></li><li><p>描述锁定机制</p></li></ul><h3 id="1-Linux-内核中的内存分配"><a href="#1-Linux-内核中的内存分配" class="headerlink" title="1 Linux 内核中的内存分配"></a>1 Linux 内核中的内存分配</h3><ul><li><code>GFP_KERNEL</code> ——使用此值可能导致当前进程被挂起。因此，它不能在中断上下文中使用。</li><li><code>GFP_ATOMIC</code> ——使用此值确保 <code>kmalloc()</code> 函数不会挂起当前进程。它可以随时使用。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *mem;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="comment">// 第一个参数是字节大小，这里是4096个字节，第二个参数是分配标志</span></span><br><span class="line">    <span class="comment">// 表示这是普通内核上下文分配，允许睡眠、可以进行内存回收</span></span><br><span class="line">mem = kmalloc(<span class="number">4096</span> * <span class="keyword">sizeof</span>(*mem), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (mem == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> err_mem;</span><br><span class="line"><span class="comment">// 打印mem~mem+4096内存地址区间的所有值为字母的元素</span></span><br><span class="line">pr_info(<span class="string">&quot;chars: &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isalpha</span>(mem[i]))</span><br><span class="line">printk(<span class="string">&quot;%c &quot;</span>, mem[i]);</span><br><span class="line">&#125;</span><br><span class="line">pr_info(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_mem:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">kfree(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重点在于使用kmalloc分配内存给指针，从而能使用指针指向内存空间进行引用、操作，其实kmalloc的用法和malloc差不多</p></blockquote><h3 id="2-在原子上下文中睡眠"><a href="#2-在原子上下文中睡眠" class="headerlink" title="2 在原子上下文中睡眠"></a>2 在原子上下文中睡眠</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sched_spin_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个自旋锁变量</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line"><span class="comment">// 初始化自旋锁变量</span></span><br><span class="line">spin_lock_init(&amp;lock);</span><br><span class="line"><span class="comment">// 执行锁定，此时CPU进入中断上下文进行原语操作，即此时代码运行在由自旋锁保护的临界区域当前进程不能挂起或睡眠</span></span><br><span class="line">spin_lock(&amp;lock);</span><br><span class="line"><span class="comment">// 强制使当前进程进入睡眠，因此执行insmod时会报错</span></span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">schedule_timeout(<span class="number">5</span> * HZ);</span><br><span class="line"><span class="comment">// 释放锁定，使用自旋锁时一定注意，在spin_lock和unlock这两个函数之间不能有挂机或睡眠操作代码</span></span><br><span class="line">spin_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>学习重点在于学会使用自旋锁变量以及使用时的注意要点</p></blockquote><h3 id="3-使用内核内存"><a href="#3-使用内核内存" class="headerlink" title="3 使用内核内存"></a>3 使用内核内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> &#123;</span></span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> timestamp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti1</span>, *<span class="title">ti2</span>, *<span class="title">ti3</span>, *<span class="title">ti4</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_info *<span class="title function_">task_info_alloc</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 1/5: allocated and initialize a task_info struct */</span></span><br><span class="line"><span class="comment">// 没有使用sizeof(struct task_info)，可能是为了更好的复用，这里参考1内存分配的操作即可</span></span><br><span class="line">    ti = kmalloc(<span class="keyword">sizeof</span>(*ti), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (ti == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">ti-&gt;pid = pid;</span><br><span class="line">    <span class="comment">// jiffies 是一个全局可见变量，表示当前的时间</span></span><br><span class="line">ti-&gt;timestamp = jiffies;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">memory_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* TODO 2/1: call task_info_alloc for current pid */</span></span><br><span class="line">    <span class="comment">// current是一个可以直接使用的宏，等价于struct task_struct结构体，使用current-&gt;pid查找当前进程的PID值</span></span><br><span class="line">ti1 = task_info_alloc(current-&gt;pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/1: call task_info_alloc for parent PID */</span></span><br><span class="line"><span class="comment">// 使用current-&gt;parent查找当前进程的父进程，这里纯属背板操作，无需了解为什么</span></span><br><span class="line">    ti2 = task_info_alloc(current-&gt;parent-&gt;pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/1: call task_info alloc for next process PID */</span></span><br><span class="line">    <span class="comment">// 使用next_task(current)宏找到当前进程的下一个进程</span></span><br><span class="line">ti3 = task_info_alloc(next_task(current)-&gt;pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/1: call task_info_alloc for next process of the next process */</span></span><br><span class="line">ti4 = task_info_alloc(next_task(next_task(current))-&gt;pid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">memory_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 3/4: print ti* field values */</span></span><br><span class="line">printk(<span class="string">&quot;pid: %d, timestamp: %lu\n&quot;</span>, ti1-&gt;pid, ti1-&gt;timestamp);</span><br><span class="line">printk(<span class="string">&quot;pid: %d, timestamp: %lu\n&quot;</span>, ti2-&gt;pid, ti2-&gt;timestamp);</span><br><span class="line">printk(<span class="string">&quot;pid: %d, timestamp: %lu\n&quot;</span>, ti3-&gt;pid, ti3-&gt;timestamp);</span><br><span class="line">printk(<span class="string">&quot;pid: %d, timestamp: %lu\n&quot;</span>, ti4-&gt;pid, ti4-&gt;timestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 4/4: free ti* structures */</span></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">kfree(ti1);</span><br><span class="line">kfree(ti2);</span><br><span class="line">kfree(ti3);</span><br><span class="line">kfree(ti4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重点在于学习如何给分配了内存的变量赋值以及如何使用current宏、next_task宏找到进程PID值</p></blockquote><h3 id="4-使用内核列表"><a href="#4-使用内核列表" class="headerlink" title="4 使用内核列表"></a>4 使用内核列表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> &#123;</span></span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> timestamp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_info *<span class="title function_">task_info_alloc</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">ti = kmalloc(<span class="keyword">sizeof</span>(*ti), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (ti == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">ti-&gt;pid = pid;</span><br><span class="line">ti-&gt;timestamp = jiffies;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_info_add_to_list</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 1/2: Allocate task_info and add it to list */</span></span><br><span class="line">    <span class="comment">// 分配内存给ti变量,ti是一个task_info结构体指针，描述任务信息(这里指描述当前进程的PID和时间)</span></span><br><span class="line">ti = task_info_alloc(pid);</span><br><span class="line"><span class="comment">// 将ti添加到链表，注意list_add函数的用法，传入的是ti-&gt;list的地址和head的地址(没有使用结构体指针)</span></span><br><span class="line">    list_add(&amp;ti-&gt;<span class="built_in">list</span>, &amp;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_info_add_for_current</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Add current, parent, next and next of next to the list */</span></span><br><span class="line">task_info_add_to_list(current-&gt;pid);</span><br><span class="line">task_info_add_to_list(current-&gt;parent-&gt;pid);</span><br><span class="line">task_info_add_to_list(next_task(current)-&gt;pid);</span><br><span class="line">task_info_add_to_list(next_task(next_task(current))-&gt;pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_info_print_list</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">&quot;%s: [ &quot;</span>, msg);</span><br><span class="line">list_for_each(p, &amp;head) &#123;</span><br><span class="line">ti = list_entry(p, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line">pr_info(<span class="string">&quot;(%d, %lu) &quot;</span>, ti-&gt;pid, ti-&gt;timestamp);</span><br><span class="line">&#125;</span><br><span class="line">pr_info(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_info_purge_list</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>, *<span class="title">q</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/5: Iterate over the list and delete all elements */</span></span><br><span class="line">    <span class="comment">// 这里要注意，list_for_each_safe是一个宏而不是函数，不要加分号</span></span><br><span class="line">list_for_each_safe(p, q, &amp;head) &#123;</span><br><span class="line"><span class="comment">// list_entry是找到当前链表节点相对应的原来的结构体指针变量，即映射回去</span></span><br><span class="line">        ti = list_entry(p, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line">list_del(p);</span><br><span class="line">kfree(ti);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  知识点</p><ul><li><code>list_entry(ptr, type, member)()</code> 返回列表中包含元素 <code>ptr</code> 的类型为 <code>type</code> 的结构，该结构中具有名为 <code>member</code> 的成员。</li><li><code>list_for_each(pos, head)</code> 使用 <code>pos</code> 作为游标来迭代列表。</li><li><code>list_for_each_safe(pos, n, head)</code> 使用 <code>pos</code> 作为游标，<code>n</code> 作为临时游标来迭代列表。此宏用于从列表中删除项目。</li><li><code>list_del(struct list_head *entry)()</code> 删除属于列表的 <code>entry</code> 地址处的项目。</li><li><code>list_add(struct list_head *new, struct list_head *head)()</code> 将 <code>new</code> 指针所引用的元素添加到 <code>head</code> 指针所引用的元素之后。</li><li>使用 <code>static struct list_head head;</code> 来声明一个链表头，在使用head前进行 <code>INIT_LIST_HEAD(&amp;head);</code> </li><li><code>INIT_LIST_HEAD(struct list_head *list)()</code> 用于在进行动态分配时，通过设置链表字段 <code>next</code> 和 <code>prev</code>，来初始化链表的标记。</li></ul><h3 id="5-使用内核列表进行进程处理"><a href="#5-使用内核列表进行进程处理" class="headerlink" title="5 使用内核列表进行进程处理"></a>5 使用内核列表进行进程处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel_api\5-list-full\list-full.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_info *<span class="title function_">task_info_find_pid</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 1/5: Look for pid and return task_info or NULL if not found */</span></span><br><span class="line"><span class="comment">// 找到成员pid值等于参数pid值的链表节点ti</span></span><br><span class="line">    list_for_each(p, &amp;head) &#123;</span><br><span class="line">ti = list_entry(p, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">if</span> (ti-&gt;pid == pid)</span><br><span class="line"><span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">list_full_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2/2: Ensure that at least one task is not deleted */</span></span><br><span class="line"><span class="comment">// 这里要学会使用原子操作函数atomic_set，原子操作是一种不会被打断必定执行的操作，必须使用原子变量atomic_t</span></span><br><span class="line">    ti = list_entry(head.prev, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line"><span class="type">atomic_set</span>(&amp;ti-&gt;count, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">task_info_remove_expired();</span><br><span class="line">task_info_print_list(<span class="string">&quot;after removing expired&quot;</span>);</span><br><span class="line">task_info_purge_list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一些常用的原子操作函数</p></blockquote><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2025-08-13_15-12-15.png"></p><h3 id="6-同步列表工作"><a href="#6-同步列表工作" class="headerlink" title="6 同步列表工作"></a>6 同步列表工作</h3><blockquote><p>代码相关答案可以看&#x2F;templates文件夹下的代码</p></blockquote><p>  使用DEFINE_RWLOCK(lock)定义一个读写自旋锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TODO 1: you can use either a spinlock or rwlock, define it here */</span></span><br><span class="line">DEFINE_RWLOCK(lock);</span><br></pre></td></tr></table></figure><p>  读写自旋锁中的代码涉及到的共享资源会被锁定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">write_lock(&amp;lock);</span><br><span class="line"><span class="comment">/* 临界区（critical region） */</span></span><br><span class="line">ti = task_info_find_pid(pid);</span><br><span class="line"><span class="keyword">if</span> (ti != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ti-&gt;timestamp = jiffies;</span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;ti-&gt;count);</span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> Guess why this comment was added  here */</span></span><br><span class="line">    <span class="comment">/* 临界区（critical region） */</span></span><br><span class="line">    write_unlock(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TODO 1: critical section ends here */</span></span><br><span class="line"><span class="comment">/* 临界区（critical region） */</span></span><br><span class="line">write_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">read_lock(&amp;lock);</span><br><span class="line">list_for_each(p, &amp;head) &#123;</span><br><span class="line">    ti = list_entry(p, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line">    pr_info(<span class="string">&quot;(%d, %lu) &quot;</span>, ti-&gt;pid, ti-&gt;timestamp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TODO 1: Critical section ends here */</span></span><br><span class="line">read_unlock(&amp;lock);</span><br><span class="line">pr_info(<span class="string">&quot;]\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>  简单来说，就是write_lock和write_unlock之间的代码片段当cpu在执行时会进入临界区，此时如果是write_lock，那就是只有当前的进程能写，其他的进程包括CPU都不能写，如果是read_lock，那就是所有进程都不能写，但是可以一起读</p><blockquote><p>如果代码只涉及共享资源的访问就使用read_lock，如果设计对共享资源的修改就使用write_lock，在这个例子中，由于要修改ti的时间戳和计数器，所以使用了write_lock读自旋锁，而只需要打印ti的pid和时间戳，所以使用read_lock</p></blockquote><p>  关于 <code>EXPORT_SYMBOL(name);</code> ，其作用是导出模块代码中的函数或者变量给其它模块使用，当模块代码中使用了 <code>EXPORT_SYMBOL(name);</code> 那么加载此模块后，其他模块也能使用 name 代表的函数或者变量，但有几点要求</p><ol><li>函数或变量不能是静态的，即不能使用 static 关键字</li><li>必须在函数定义或变量赋值后使用</li></ol><h3 id="7-在我们的列表模块中测试模块调用"><a href="#7-在我们的列表模块中测试模块调用" class="headerlink" title="7 在我们的列表模块中测试模块调用"></a>7 在我们的列表模块中测试模块调用</h3><p>  这一节没什么好讲的，就是一个模块依赖关系，如果模块代码使用了其他模块导出的内核符号name，则这个模块依赖于其他模块，被依赖的模块由于模块引用计数refcnt&gt;0无法卸载，所以必须先卸载依赖模块，在这个例子中就是必须先卸载 list-test 模块，然后卸载 list-sync 模块</p><p>  除此以外，如果一个模块要使用其他模块导出的内核符号(函数或者变量)，必须先extern声明这个内核符号再使用，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要使用 task_info_print_list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_info_print_list</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> <span class="comment">//被依赖模块代码</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">pr_info(<span class="string">&quot;%s: [ &quot;</span>, msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 1: Protect list, is this read or write access? */</span></span><br><span class="line">read_lock(&amp;lock);</span><br><span class="line">list_for_each(p, &amp;head) &#123;</span><br><span class="line">ti = list_entry(p, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line">pr_info(<span class="string">&quot;(%d, %lu) &quot;</span>, ti-&gt;pid, ti-&gt;timestamp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TODO 1: Critical section ends here */</span></span><br><span class="line">read_unlock(&amp;lock);</span><br><span class="line">pr_info(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(task_info_print_list);</span><br><span class="line"><span class="comment">// 必须先 extern task_info_print_list</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">task_info_print_list</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span>; <span class="comment">//依赖模块代码</span></span><br></pre></td></tr></table></figure><blockquote><p>很多东西都是背板式的，如果每个不熟悉的符号都使用LXR或cscope去查询，会消耗大量时间而且不一定能查找正确，学习linux内核编程有如学习一个语法无比复杂的语言，与其先背下来所有单词和认识所有语法后再实践练习使用，不如先开口把最常用最实用的操作记下来，让自己变得熟练，那么以前那些晦涩难懂的知识也就比较容易理解了</p></blockquote><h2 id="三-字符设备驱动程序"><a href="#三-字符设备驱动程序" class="headerlink" title="三 字符设备驱动程序"></a>三 字符设备驱动程序</h2><p> 实验目标</p><ul><li>理解字符设备驱动程序背后的概念</li><li>理解可以在字符设备上执行的各种操作</li><li>使用等待队列进行工作</li></ul><h3 id="0-简介"><a href="#0-简介" class="headerlink" title="0 简介"></a>0 简介</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct file -linux - linux-2.6.0\include\linux\fs.h</span></span><br><span class="line"><span class="comment">// struct file_operations - linux-2.6.0\include\linux\fs.h</span></span><br><span class="line"><span class="comment">// generic_ro_fops - linux-2.6.0\include\linux\fs.h</span></span><br><span class="line"><span class="comment">// vfs_read() - linux-2.6.0\fs\read_write.c</span></span><br></pre></td></tr></table></figure><h3 id="1-注册-注销"><a href="#1-注册-注销" class="headerlink" title="1 注册&#x2F;注销"></a>1 注册&#x2F;注销</h3><ol><li>使用 <strong>mknod</strong> 创建 <strong>&#x2F;dev&#x2F;so2_cdev</strong> 字符设备节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在QUMU上使用mknod命令</span></span><br><span class="line">mknod /dev/so2_cdev c <span class="number">42</span> <span class="number">0</span></span><br><span class="line"><span class="comment">// 42是主设备号，0是此设备号，均在so2_cdev.c中定义过</span></span><br></pre></td></tr></table></figure><blockquote><p>此时只是创建了一个节点，要使用register_chrdev_region完成注册才能在&#x2F;proc&#x2F;devices中看到设备文件</p></blockquote><ol start="2"><li>实现设备的注册和注销</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TODO 1/6: register char device region for MY_MAJOR and NUM_MINORS starting at MY_MINOR */</span></span><br><span class="line">err = register_chrdev_region(MKDEV(MY_MAJOR, MY_MINOR),</span><br><span class="line">NUM_MINORS, MODULE_NAME);</span><br><span class="line"><span class="comment">/* TODO 1/1: unregister char device region, for MY_MAJOR and NUM_MINORS starting at MY_MINOR */</span></span><br><span class="line">unregister_chrdev_region(MKDEV(MY_MAJOR, MY_MINOR),NUM_MINORS);</span><br></pre></td></tr></table></figure><blockquote><p>MKDEV的意思是从主设备号MY_MAJOR开始注册次设备号MY_MINOR，注册NUM_MINORS个设备文件，如果当前主设备号下的设备文件数大于NUM_MINORS，则让主设备号＋1继续注册</p></blockquote><h3 id="2-注册一个已经注册过的主设备号"><a href="#2-注册一个已经注册过的主设备号" class="headerlink" title="2 注册一个已经注册过的主设备号"></a>2 注册一个已经注册过的主设备号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 cat proc/devices 看已有的设备文件的主设备号，然后替换掉下面的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MAJOR42</span></span><br></pre></td></tr></table></figure><blockquote><p>此时会返回错误码 -16，#define EBUSY  16   &#x2F;* Device or resource busy *&#x2F; 表示是当前设备正忙无法被注册</p></blockquote><h3 id="3-打开和关闭"><a href="#3-打开和关闭" class="headerlink" title="3 打开和关闭"></a>3 打开和关闭</h3><blockquote><p>打开和关闭字符设备文件</p></blockquote><ol><li>初始化设备</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">so2_device_data</span> &#123;</span></span><br><span class="line"><span class="comment">/* TODO 2/1: add cdev member */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="comment">/* TODO 4/2: add buffer with BUFSIZ elements */</span></span><br><span class="line"><span class="type">char</span> buffer[BUFSIZ];</span><br><span class="line"><span class="type">size_t</span> size;</span><br><span class="line"><span class="comment">/* TODO 7/2: extra members for home */</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> wq;</span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"><span class="comment">/* TODO 3/1: add atomic_t access variable to keep track if file is opened */</span></span><br><span class="line"><span class="type">atomic_t</span> access;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>为当前设备文件建立一个结构体，成员有cdev结构体，该结构体用于在系统中注册字符设备(供cdev_init和cdev_add函数使用)，字符数组buffer用于读操作，size用于指示传输数据的大小，access是一个原子变量，用于计数实现阻塞其它进程干涉，这里只需要关注 TODO 2&#x2F;1</p></blockquote><ol start="2"><li>实现打开和释放函数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在结构体定义static const struct file_operations so2_fops中</span></span><br><span class="line"><span class="comment">/* TODO 2/2: add open and release functions */</span></span><br><span class="line">.open = so2_cdev_open,</span><br><span class="line">.release = so2_cdev_release,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数so2_cdev_open中</span></span><br><span class="line"><span class="comment">/* TODO 3/1: inode-&gt;i_cdev contains our cdev struct, use container_of to obtain a pointer to so2_device_data */</span></span><br><span class="line"><span class="comment">// 获取当前设备文件的结构体</span></span><br><span class="line">data = container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> so2_device_data, cdev);</span><br><span class="line"><span class="comment">// 让file指针指向当前设备文件，实现打开</span></span><br><span class="line">file-&gt;private_data = data;</span><br></pre></td></tr></table></figure><blockquote><p>container_of 宏用于从一个结构体成员的地址反推出成员所在的结构体的首地址，用法是container_of(ptr, type, member)，在这个例子中container_of 从 inode-&gt;i_cdev（一个struct cdev 类型的指针，指向so2_device_data的成员cdev）反推出它所在的 struct so2_device_data 结构体的首地址，从而获得设备的私有数据指针 data</p></blockquote><ol start="3"><li>显示消息</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用pr_info函数，与printf类似</span></span><br></pre></td></tr></table></figure><ol start="4"><li>再次读取</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 cat /dev/so2_cdev</span></span><br></pre></td></tr></table></figure><h3 id="4-访问限制"><a href="#4-访问限制" class="headerlink" title="4 访问限制"></a>4 访问限制</h3><blockquote><p>使用原子变量限制设备访问</p></blockquote><ol><li>在设备结构体中添加 <code>atomic_t</code> 变量</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在结构体so2_device_data中</span></span><br><span class="line"><span class="comment">/* TODO 3/1: add atomic_t access variable to keep track if file is opened */</span></span><br><span class="line"><span class="type">atomic_t</span> access;</span><br></pre></td></tr></table></figure><ol start="2"><li>在模块初始化时对该变量进行初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数so2_cdev_init中</span></span><br><span class="line"><span class="comment">/* TODO 3/1: set access variable to 0, use atomic_set */</span></span><br><span class="line"><span class="type">atomic_set</span>(&amp;devs[i].access, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 这里的devs是设备文件的实例化，在设备文件结构体下有定义</span></span><br><span class="line"><span class="comment">// struct so2_device_data devs[NUM_MINORS];</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在打开函数中使用该变量限制对设备的访问。我们建议使用 <code>atomic_cmpxchg()</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数so2_cdev_open中</span></span><br><span class="line"><span class="comment">/* TODO 3/2: return immediately if access is != 0, use atomic_cmpxchg */</span></span><br><span class="line"><span class="keyword">if</span> (atomic_cmpxchg(&amp;data-&gt;access, <span class="number">0</span>, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EBUSY;</span><br></pre></td></tr></table></figure><blockquote><p>static inline int atomic_cmpxchg(atomic_t *ptr, int old, int new)<br>这个函数可以在一个原子操作中检查变量的旧值并将其设为新值，在上面的例子中，它表示如果当前的access等于旧值0就将access设为1，不等于0就不修改，无论是否发生替换，atomic_cmpxchg函数都会返回ptr指向的原始值（也就是操作之前的值）。</p></blockquote><ol start="4"><li>在释放函数中重置该变量以恢复对设备的访问权限</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数so2_cdev_release中</span></span><br><span class="line"><span class="comment">/* TODO 3/1: reset access variable to 0, use atomic_set */</span></span><br><span class="line"><span class="type">atomic_set</span>(&amp;data-&gt;access, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li>模拟休眠</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在函数so2_cdev_open中</span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">schedule_timeout(1000);</span><br></pre></td></tr></table></figure><blockquote><p><code>set_current_state(TASK_INTERRUPTIBLE);</code>把当前进程（<code>current</code>）的状态设置为可中断睡眠 (<code>TASK_INTERRUPTIBLE</code>)。在这个状态下，进程会被调度器认为是“睡着的”，直到有事件唤醒它<br><code>schedule_timeout(10 * HZ);</code>把当前进程从 CPU 调度队列里移走，并设置一个定时器，在 <code>10 * HZ</code> 个 <strong>jiffies</strong> 后唤醒它。<code>HZ</code> 是内核的时钟频率（例如在 x86 上常见是 100、250 或 1000），<code>10 * HZ</code> 表示 10 秒。如果在这段时间内进程收到信号，会提前被唤醒。</p></blockquote><h3 id="5-读操作"><a href="#5-读操作" class="headerlink" title="5 读操作"></a>5 读操作</h3><blockquote><p>在驱动程序中实现读取函数</p></blockquote><ol><li>在 <code>so2_device_data</code> 结构中保持一个缓冲区，并用 <code>MESSAGE</code> 宏的值进行初始化。缓冲区的初始化在模块的 <code>init</code> 函数中完成</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct so2_device_data</span></span><br><span class="line"><span class="comment">/* TODO 4/2: add buffer with BUFSIZ elements */</span></span><br><span class="line"><span class="type">char</span> buffer[BUFSIZ];</span><br><span class="line"><span class="type">size_t</span> size;</span><br><span class="line"><span class="comment">// static int so2_cdev_init(void)</span></span><br><span class="line"><span class="comment">/*TODO 4/2: initialize buffer with MESSAGE string */</span></span><br><span class="line"><span class="built_in">memcpy</span>(devs[i].buffer, MESSAGE, <span class="keyword">sizeof</span>(MESSAGE));</span><br><span class="line">devs[i].size = <span class="keyword">sizeof</span>(MESSAGE);</span><br></pre></td></tr></table></figure><ol start="2"><li>在读取调用时，将内核空间缓冲区的内容复制到用户空间缓冲区</li></ol><p>使用 <code>copy_to_user()</code> 函数将信息从内核空间复制到用户空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static ssize_t so2_cdev_read(file, user_buffer, size, offset)</span></span><br><span class="line"><span class="comment">// 首先定义传输的字节数to_read以及获取设备文件指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">so2_device_data</span> *<span class="title">data</span> =</span></span><br><span class="line">(<span class="keyword">struct</span> so2_device_data *) file-&gt;private_data;</span><br><span class="line"><span class="type">size_t</span> to_read = (size &gt; data-&gt;size - *offset) ? (data-&gt;size - *offset) : size;</span><br><span class="line"><span class="comment">/* TODO 4/4: Copy data-&gt;buffer to user_buffer, use copy_to_user */</span></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(user_buffer, data-&gt;buffer + *offset, to_read) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">*offset += to_read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> to_read;</span><br></pre></td></tr></table></figure><blockquote><p>需要将请求的字节数size和内部缓冲区大小data-&gt;size - *offset作比较，有可能请求的字节数要超过内部缓存区大小，从而引发错误，其实这里应该是判断 size+*offset &gt; data-&gt;size，可能为了防止越界写成了减去，注意要更新偏移参数，以便于用户达到文件内部缓冲区末尾时退出</p></blockquote><blockquote><p>读取函数so2_cdev_read调用返回的值是从内核空间缓冲区传输到用户空间缓冲区的字节数</p></blockquote><h3 id="6-写操作"><a href="#6-写操作" class="headerlink" title="6 写操作"></a>6 写操作</h3><h3 id="7-ioctl-操作"><a href="#7-ioctl-操作" class="headerlink" title="7 ioctl 操作"></a>7 ioctl 操作</h3><h3 id="8-带消息的-ioctl"><a href="#8-带消息的-ioctl" class="headerlink" title="8 带消息的 ioctl"></a>8 带消息的 ioctl</h3><h3 id="9-使用等待队列的-ioctl"><a href="#9-使用等待队列的-ioctl" class="headerlink" title="9 使用等待队列的 ioctl"></a>9 使用等待队列的 ioctl</h3><h3 id="10-O-NONBLOCK-实现"><a href="#10-O-NONBLOCK-实现" class="headerlink" title="10 O_NONBLOCK 实现"></a>10 O_NONBLOCK 实现</h3><h2 id="四-I-O访问和中断"><a href="#四-I-O访问和中断" class="headerlink" title="四 I&#x2F;O访问和中断"></a>四 I&#x2F;O访问和中断</h2><p>实验目标：</p><ul><li><p>与外围设备进行通信</p></li><li><p>实现中断处理程序</p></li><li><p>将中断与进程上下文同步</p></li></ul><p>关键词：IRQ，I&#x2F;O 端口，I&#x2F;O 地址，基地址，UART，request_region，release_region，inb，outb</p><h3 id="0-简介-1"><a href="#0-简介-1" class="headerlink" title="0 简介"></a>0 简介</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//resource - /inclue/linux/ioport.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line"><span class="type">resource_size_t</span> start;</span><br><span class="line"><span class="type">resource_size_t</span> end;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> desc;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//request_region - /inclue/linux/ioport.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request_region(start,n,name)\</span></span><br><span class="line"><span class="meta">__request_region(&amp;ioport_resource, (start), (n), (name), 0)</span></span><br><span class="line"><span class="comment">//__request_region() - /kernel/resource.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *__<span class="title">request_region</span>(<span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>,</span></span><br><span class="line"><span class="class">  <span class="title">resource_size_t</span> <span class="title">start</span>, <span class="title">resource_size_t</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">  <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, <span class="title">int</span> <span class="title">flags</span>)</span></span><br><span class="line"><span class="class">//<span class="title">request_irq</span>() - /<span class="title">include</span>/<span class="title">linux</span>/<span class="title">interrupt</span>.<span class="title">h</span></span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">inline</span> <span class="title">int</span> __<span class="title">must_check</span></span></span><br><span class="line"><span class="class"><span class="title">request_irq</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">irq</span>, <span class="title">irq_handler_t</span> <span class="title">handler</span>, <span class="title">unsigned</span> <span class="title">long</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, <span class="title">void</span> *<span class="title">dev</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//request_threaded_irq() - /kernel/irq/manage.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params"> <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br></pre></td></tr></table></figure><h3 id="实现键盘驱动程序"><a href="#实现键盘驱动程序" class="headerlink" title="实现键盘驱动程序"></a>实现键盘驱动程序</h3><p>  目标是创建一个使用键盘IRQ的驱动程序，检查传入的按键代码并将其存储在缓冲区中。通过字符设备驱动程序，用户空间可以访问该缓冲区。</p><blockquote><p>如果说上一个实验字符设备驱动程序是关于如何驱动外设如何实现物理设备的读写I&#x2F;O操作，那么这个实验是关于如何通过中断来操控外设</p></blockquote><h3 id="1-请求I-O端口"><a href="#1-请求I-O端口" class="headerlink" title="1 请求I&#x2F;O端口"></a>1 请求I&#x2F;O端口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 kbd_init 函数中</span></span><br><span class="line"><span class="comment">/* TODO 1/8: request the keyboard I/O ports */</span></span><br><span class="line"><span class="keyword">if</span> (request_region(I8042_DATA_REG+<span class="number">1</span>, <span class="number">1</span>, MODULE_NAME) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    err = -EBUSY;</span><br><span class="line">    <span class="keyword">goto</span> out_unregister;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (request_region(I8042_STATUS_REG+<span class="number">1</span>, <span class="number">1</span>, MODULE_NAME) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    err = -EBUSY;</span><br><span class="line">    <span class="keyword">goto</span> out_release_region;</span><br><span class="line">&#125;</span><br><span class="line">out_release_regions:</span><br><span class="line">release_region(I8042_STATUS_REG+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">out_release_region:</span><br><span class="line">release_region(I8042_DATA_REG+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">out_unregister:</span><br><span class="line">unregister_chrdev_region(MKDEV(KBD_MAJOR, KBD_MINOR),</span><br><span class="line"> KBD_NR_MINORS);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"><span class="comment">// 在 kbd_exit 函数中</span></span><br><span class="line"><span class="comment">/* TODO 1/2: release keyboard I/O ports */</span></span><br><span class="line">release_region(I8042_STATUS_REG+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">release_region(I8042_DATA_REG+<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><blockquote><p>请求 I&#x2F;O 端口后，可以在&#x2F;proc&#x2F;ioports中找到自己的端口号<br>如果遇到报错提示-EBUSY，可能是因为没有执行release_region或者unregister_chrdev_region，需要在init函数开头写release_region或者unregister_chrdev_region然后重新插入模块</p></blockquote><h3 id="2-中断处理例程"><a href="#2-中断处理例程" class="headerlink" title="2 中断处理例程"></a>2 中断处理例程</h3><blockquote><p>所谓中断处理例程，就是中断发生时会执行的代码功能函数，一般是xxx_interrupt_handler()</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己写的一个函数 kbd_interrupt_handle 注意类型是 irqreturn_t</span></span><br><span class="line"><span class="comment">/* TODO 2/27: implement interrupt handler */</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">kbd_interrupt_handle</span><span class="params">(<span class="type">int</span> irq_no, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 当中断发生时输出</span></span><br><span class="line">    pr_info(<span class="string">&quot;You just pressed A key!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* TODO 3: read the scancode */</span></span><br><span class="line"><span class="comment">/* TODO 3/2: interpret the scancode */</span></span><br><span class="line"><span class="comment">/* TODO 3/2: display information about the keystrokes */</span></span><br><span class="line"><span class="comment">/* TODO 3/7: store ASCII key to buffer */</span></span><br><span class="line"><span class="keyword">return</span> IRQ_NONE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 kbd_init 函数中, 注册中断处理例程，使用 request_irq</span></span><br><span class="line"><span class="comment">/* TODO 2/7: Register IRQ handler for keyboard IRQ (IRQ 1). */</span></span><br><span class="line">err = request_irq(I8042_KBD_IRQ,</span><br><span class="line">        kbd_interrupt_handle,</span><br><span class="line">        IRQF_SHARED, MODULE_NAME, &amp;devs[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">    pr_err(<span class="string">&quot;request_irq failed: %d\n&quot;</span>, err);</span><br><span class="line">    <span class="keyword">goto</span> out_release_regions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用request_irq注册中断例程后，能在&#x2F;proc&#x2F;interrupts中看到自己的中断程序 kbd</p></blockquote><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817211748806.png" alt="image-20250817211748806"></p><blockquote><p>按照“注意”的提示使用 <code>QEMU_DISPLAY=gtk make boot</code> 是无法启动成功的，因为QEMU中的Makefile指定需要下载yotco2.4版本的镜像系统，但是链接早就失效了，必须修改QEMU中的Makefile的yotco版本号为4.1才能正常下载系统镜像从而启动，如下图所示修改，如果下载的很慢或者还是下载不了，可能需要使用代理，使用clash-verge的TUN模式可以让虚拟机走代理</p></blockquote><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817211057473.png" alt="image-20250817211057473" style="zoom:67%;" /><blockquote><p>没有报错之后应该能正常启动系统，如下所示</p></blockquote><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817211345350.png" alt="image-20250817211345350" style="zoom:67%;" /><blockquote><p>但此时要退出来，因为没有在Docker内执行 <code>make copy</code>，执行前系统内是没有 <code>skels</code> 这个文件夹的</p></blockquote><p>在QEMU中按下键盘按键会触发中断例程程序，使用dmesg可以看到：</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817211707033.png" alt="image-20250817211707033" style="zoom: 80%;" /><h3 id="3-将-ASCII-键存储到缓冲区"><a href="#3-将-ASCII-键存储到缓冲区" class="headerlink" title="3 将 ASCII 键存储到缓冲区"></a>3 将 ASCII 键存储到缓冲区</h3><h4 id="读取数据存储器"><a href="#读取数据存储器" class="headerlink" title="读取数据存储器"></a>读取数据存储器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用函数 inb 读取 I/O 端口的数据，只读一个字符大小的数据(1 Byte)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u8 <span class="title function_">i8042_read_data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 val;</span><br><span class="line"><span class="comment">/* TODO 3: Read DATA register (8 bits). */</span></span><br><span class="line">val = inb(I8042_DATA_REG);  <span class="comment">// 此时读取的是寄存器中的扫描码，还需要转换才能成为ASCII码</span></span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 kbd_interrupt_handle 函数中</span></span><br><span class="line"><span class="comment">/* TODO 3: read the scancode */</span></span><br><span class="line">scancode = i8042_read_data();</span><br></pre></td></tr></table></figure><h4 id="解释扫描码"><a href="#解释扫描码" class="headerlink" title="解释扫描码"></a>解释扫描码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 kbd_interrupt_handle 函数中</span></span><br><span class="line"><span class="comment">/* TODO 3/2: interpret the scancode */</span></span><br><span class="line">pressed = is_key_press(scancode); <span class="comment">// 此函数能判断扫描码是按下键还是释放键</span></span><br><span class="line">ch = get_ascii(scancode);  <span class="comment">// 此函数能将扫描码转换为ASCII码</span></span><br><span class="line"><span class="comment">/* TODO 3/2: display information about the keystrokes */</span></span><br><span class="line">pr_info(<span class="string">&quot;IRQ %d: scancode=0x%x (%u) pressed=%d ch=%c\n&quot;</span>,</span><br><span class="line">    irq_no, scancode, scancode, pressed, ch);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_ascii</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> scancode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *row1 = <span class="string">&quot;1234567890&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *row2 = <span class="string">&quot;qwertyuiop&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *row3 = <span class="string">&quot;asdfghjkl&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *row4 = <span class="string">&quot;zxcvbnm&quot;</span>;</span><br><span class="line"></span><br><span class="line">scancode &amp;= ~SCANCODE_RELEASED_MASK;</span><br><span class="line"><span class="keyword">if</span> (scancode &gt;= <span class="number">0x02</span> &amp;&amp; scancode &lt;= <span class="number">0x0b</span>)</span><br><span class="line"><span class="keyword">return</span> *(row1 + scancode - <span class="number">0x02</span>);</span><br><span class="line"><span class="keyword">if</span> (scancode &gt;= <span class="number">0x10</span> &amp;&amp; scancode &lt;= <span class="number">0x19</span>)</span><br><span class="line"><span class="keyword">return</span> *(row2 + scancode - <span class="number">0x10</span>);</span><br><span class="line"><span class="keyword">if</span> (scancode &gt;= <span class="number">0x1e</span> &amp;&amp; scancode &lt;= <span class="number">0x26</span>)</span><br><span class="line"><span class="keyword">return</span> *(row3 + scancode - <span class="number">0x1e</span>);</span><br><span class="line"><span class="keyword">if</span> (scancode &gt;= <span class="number">0x2c</span> &amp;&amp; scancode &lt;= <span class="number">0x32</span>)</span><br><span class="line"><span class="keyword">return</span> *(row4 + scancode - <span class="number">0x2c</span>);</span><br><span class="line"><span class="keyword">if</span> (scancode == <span class="number">0x39</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (scancode == <span class="number">0x1c</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_press</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> scancode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(scancode &amp; SCANCODE_RELEASED_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将字符存储到缓冲区"><a href="#将字符存储到缓冲区" class="headerlink" title="将字符存储到缓冲区"></a>将字符存储到缓冲区</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 kbd_interrupt_handle 函数中</span></span><br><span class="line"><span class="comment">/* TODO 3/7: store ASCII key to buffer */</span></span><br><span class="line"><span class="keyword">if</span> (pressed) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kbd</span> *<span class="title">data</span> =</span> (<span class="keyword">struct</span> kbd *)dev_id; <span class="comment">// 获取设备结构体</span></span><br><span class="line"><span class="comment">// 使用自旋锁，确保共享资源缓冲区是同步访问的，需要先在init函数中初始化</span></span><br><span class="line">    spin_lock(&amp;data-&gt;lock); </span><br><span class="line">    <span class="comment">// 读取字符，将 I/O 端口的字符读取到设备缓冲区中，以便于用户空间读取</span></span><br><span class="line">    put_char(data, ch);</span><br><span class="line">    spin_unlock(&amp;data-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 kbd_init 函数中</span></span><br><span class="line"><span class="comment">/* TODO 3: initialize spinlock */</span></span><br><span class="line">spin_lock_init(&amp;devs[<span class="number">0</span>].lock);</span><br><span class="line"><span class="comment">// put_char 函数定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_char</span><span class="params">(<span class="keyword">struct</span> kbd *data, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果缓冲区中的字符数量大于缓冲区的容量，则丢弃当前读取的字符</span></span><br><span class="line"><span class="keyword">if</span> (data-&gt;count &gt;= BUFFER_SIZE)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// put-&gt;idx指向缓冲区下一个写入位置的索引</span></span><br><span class="line">data-&gt;buf[data-&gt;put_idx] = c;</span><br><span class="line">    <span class="comment">// 更新索引</span></span><br><span class="line">data-&gt;put_idx = (data-&gt;put_idx + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">data-&gt;count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-读取缓冲区"><a href="#4-读取缓冲区" class="headerlink" title="4 读取缓冲区"></a>4 读取缓冲区</h3><blockquote><p>为了访问键盘记录器的数据，我们需要将其发送到用户空间。我们将使用 <em>&#x2F;dev&#x2F;kbd</em> 字符设备来实现这一点。当从该设备读取数据时，我们将从内核空间的缓冲区中获取按键数据</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 get_char() 从缓冲区中读取一个字符，并使用 put_user() 将其存储到用户缓冲区中</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">get_char</span><span class="params">(<span class="type">char</span> *c, <span class="keyword">struct</span> kbd *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* TODO 4/6: get char from buffer; update count and get_idx */</span></span><br><span class="line"><span class="keyword">if</span> (data-&gt;count &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果缓冲区中的字符数量大于0，则读取字符</span></span><br><span class="line">*c = data-&gt;buf[data-&gt;get_idx];</span><br><span class="line">data-&gt;get_idx = (data-&gt;get_idx + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">data-&gt;count--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 kbd_read 函数中</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">kbd_read</span><span class="params">(<span class="keyword">struct</span> file *file,  <span class="type">char</span> __user *user_buffer,</span></span><br><span class="line"><span class="params"><span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kbd</span> *<span class="title">data</span> =</span> (<span class="keyword">struct</span> kbd *) file-&gt;private_data;</span><br><span class="line"><span class="type">size_t</span> read = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* TODO 4/18: read data from buffer */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">bool</span> more = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (size--) &#123;</span><br><span class="line">        <span class="comment">// 在读取函数中，使用 spin_lock_irqsave() 和 spin_unlock_irqrestore() 进行加锁</span></span><br><span class="line">spin_lock_irqsave(&amp;data-&gt;lock, flags);</span><br><span class="line">more = get_char(&amp;ch, data);</span><br><span class="line"><span class="comment">// 原子上下文中不允许访问用户空间</span></span><br><span class="line">        spin_unlock_irqrestore(&amp;data-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (!more)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 关键的一句在这，使用put_user函数将字符存储到用户缓存区</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(ch, user_buffer++))  <span class="comment">// 参数是ch(字符)和user_buffer(传入的用户缓冲区)</span></span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">read++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了测试是否成功实现了从键盘这一物理设备驱动程序的中断中实现数据读取，应该先使用<code>mknod</code>创建<code>/dev/kbd</code>字符设备驱动程序，正如在<code>kbd_init</code>函数中注册字符驱动设备文件的函数 <code>register_chrdev_region</code> 中的参数一样，要使用同样的<code>KBD_MAJOR</code>和<code>MODULE_NAME</code>以及<code>KBD_MINOR</code>，也就是 <code>42</code>、<code>kbd</code>、<code>0</code>，使用命令 <code>mknod /dev/kbd c 42 0</code> 在QEMU中创建设备驱动文件kbd，构建复制和启动QEMU，加载模块后，能在<code>/proc/devices</code>中看到自己的设备文件<code>42 kbd</code>，最后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 cat /dev/kbd 读取缓冲区中的数据吧，因为 cat 是用户空间使用的命令，因此此时应该显示</span></span><br></pre></td></tr></table></figure><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817214906662.png" alt="image-20250817214906662" style="zoom: 80%;" /><h3 id="5-重置缓冲区"><a href="#5-重置缓冲区" class="headerlink" title="5 重置缓冲区"></a>5 重置缓冲区</h3><blockquote><p>使用 <code>echo &quot;clear&quot; &gt; /dev/kbd</code> 将数据写入设备</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 reset_buffer</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">reset_buffer</span><span class="params">(<span class="keyword">struct</span> kbd *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* TODO 5/3: reset count, put_idx, get_idx */</span></span><br><span class="line">data-&gt;count = <span class="number">0</span>;</span><br><span class="line">data-&gt;put_idx = <span class="number">0</span>;</span><br><span class="line">data-&gt;get_idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当写操作发生时，应该执行...</span></span><br><span class="line"><span class="comment">/* TODO 5/12: add write operation and reset the buffer */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">kbd_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *user_buffer,</span></span><br><span class="line"><span class="params"> <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kbd</span> *<span class="title">data</span> =</span> (<span class="keyword">struct</span> kbd *) file-&gt;private_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;data-&gt;lock, flags);</span><br><span class="line">reset_buffer(data);</span><br><span class="line">spin_unlock_irqrestore(&amp;data-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加写操作</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">kbd_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = kbd_open,</span><br><span class="line">.release = kbd_release,</span><br><span class="line">.read = kbd_read,</span><br><span class="line"><span class="comment">/* TODO 5: add write operation */</span></span><br><span class="line">.write = kbd_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时执行命令 <code>echo &quot;clear&quot; &gt; /dev/kbd</code> 会让缓冲区清空</p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817215433645.png" alt="image-20250817215433645" style="zoom:80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;center&gt;OS2 内核编程和驱动程序开发实验&lt;/center&gt;&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;基于布加勒斯特理工大学自动控制与计算机学院计算机科学与工程系的 “操作系统2” 课程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;环境配置&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="内核教程" scheme="https://leeway2zc.top/categories/%E5%86%85%E6%A0%B8%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="内核教程" scheme="https://leeway2zc.top/tags/%E5%86%85%E6%A0%B8%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>上传博客的教程</title>
    <link href="https://leeway2zc.top/2025/08/10/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%95%99%E7%A8%8B/"/>
    <id>https://leeway2zc.top/2025/08/10/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%95%99%E7%A8%8B/</id>
    <published>2025-08-10T20:26:31.000Z</published>
    <updated>2025-08-21T00:52:53.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以后写文章的流程"><a href="#以后写文章的流程" class="headerlink" title="以后写文章的流程"></a><strong>以后写文章的流程</strong></h2><ol><li><code>npx hexo new post &quot;文章标题&quot;</code></li><li>编辑 <code>source/_posts/文章标题.md</code></li><li><code>git add . &amp;&amp; git commit -m &quot;update post&quot; &amp;&amp; git push</code></li><li>等 1~2 分钟，GitHub Pages 自动更新</li></ol><h2 id="在其他设备上推送博客的流程"><a href="#在其他设备上推送博客的流程" class="headerlink" title="在其他设备上推送博客的流程"></a>在其他设备上推送博客的流程</h2><ol><li><p>安装git、node.js、npm</p><blockquote><p>使用git -v, node -v, npm -v检查是否安装成功</p></blockquote></li><li><p>选择一个目录打开 git bash，执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/Leeway2ZC/hexo-blog.git</span></span><br></pre></td></tr></table></figure></li><li><p>进入仓库目录 <code>cd hexo-blog</code></p></li><li><p>安装项目依赖 <code>npm install</code></p></li><li><p>在Git中设置本地用户名和邮箱</p><ul><li><p>配置全局Git用户名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Leeway2ZC&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>配置全局Git邮箱</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;leeway2zc@gmail.com&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>然后就可以按照上面的流程写文章啦</p></li></ol><h2 id="关于修改添加测试博客功能"><a href="#关于修改添加测试博客功能" class="headerlink" title="关于修改添加测试博客功能"></a>关于修改添加测试博客功能</h2><blockquote><p>参考hexo官方教程<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p></blockquote><p>使用git退回上一个提交版本(将源码分支和网站都退回到上个版本)：</p><ol><li><code>git log --oneline </code> # 找到上一个版本的 commit ID</li><li><code>git reset --hard &lt;commit-id&gt;</code> # 找到上一个版本的 commit ID</li><li><code>git push origin main --force</code> # 推送（覆盖远端）</li></ol><p>更改主题时，使用git在本地先进行测试，然后推送博客更新</p><ol><li><p><code>git branch</code>  # 查看当前分支</p></li><li><p><code>git checkout -b test-theme</code> # 创建并切换到测试分支</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这一步做了两件事，此时的 `test-theme` 是完全跟 `main` 一样的，只是互不影响</span><br><span class="line"></span><br><span class="line">1. 从 `main` 复制当前代码</span><br><span class="line">2. 切换到新分支 `test-theme`</span><br></pre></td></tr></table></figure></li><li><p>在测试分支修改主题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你在这个分支上可以随便改主题、调整配置、改文章。</span><br><span class="line">如果改坏了，直接删掉这个分支就行，main 分支不受影响。</span><br></pre></td></tr></table></figure></li><li><p>本地测试，在test-theme分支中运行 <code>npx hexo server</code> 浏览效果</p></li><li><p>确认没问题后合并到main</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge test-theme</span><br></pre></td></tr></table></figure></li><li><p>推送到远程（更新博客）<code>git push origin main</code></p></li><li><p>如果发现问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git branch -D test-theme</span><br></pre></td></tr></table></figure><p>直接删除分支，一切回到切换主题前</p></li></ol><h2 id="关于配置图床"><a href="#关于配置图床" class="headerlink" title="关于配置图床"></a>关于配置图床</h2><ol><li>安装PicGo</li><li>配置PicGo<ol><li>使用ini文件设置腾讯云Cos</li><li>设置Server修改监听端口与Typora保持一致</li></ol></li><li>配置Typora<ol><li>修改偏好设置中的图像</li><li>修改为上传图片，上传服务更改为PicGo</li><li>验证图片上传选项</li></ol></li></ol><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250811005047923.png" alt="image-20250811005047923" style="zoom:50%;" /><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>如果在另一台设备上做了修改，那么写文章前先要拉取最新代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure><p>从而确保代码库是最新的，避免冲突</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;以后写文章的流程&quot;&gt;&lt;a href=&quot;#以后写文章的流程&quot; class=&quot;headerlink&quot; title=&quot;以后写文章的流程&quot;&gt;&lt;/a&gt;&lt;strong&gt;以后写文章的流程&lt;/strong&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;npx hexo new post</summary>
      
    
    
    
    
    <category term="教程" scheme="https://leeway2zc.top/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="https://leeway2zc.top/2025/08/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>https://leeway2zc.top/2025/08/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</id>
    <published>2025-08-10T18:50:13.000Z</published>
    <updated>2025-08-21T00:52:53.145Z</updated>
    
    <content type="html"><![CDATA[<p>这是我的第一篇博客，以后会记录很多学习笔记，还有很多值得记录的事情。</p><p>不能总是等到失去才发现错过了什么，要时刻记录确保不会遗忘。以此怀念我的爷爷，愿您在天堂不再有苦痛，再见时希望您过的安详。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是我的第一篇博客，以后会记录很多学习笔记，还有很多值得记录的事情。&lt;/p&gt;
&lt;p&gt;不能总是等到失去才发现错过了什么，要时刻记录确保不会遗忘。以此怀念我的爷爷，愿您在天堂不再有苦痛，再见时希望您过的安详。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
