<!DOCTYPE html><html lang="cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> C++开发学习笔记 · LeeWay</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="C++开发学习笔记 - David Lee"><meta name="keywords"><meta name="author" content="David Lee"><link rel="short icon" href="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/favicon-32x32.png"><link rel="stylesheet" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://leeway2zc.top/atom.xml" title="LeeWay"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g==" crossorigin="anonymous" referrerpolicy="no-referrer" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="LeeWay" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250811154253_3.jpg"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/categories/live/" target="_self" data-hover="生活" class="nav-list-link">生活</a></li><li class="nav-list-item"><a href="/categories/read/" target="_self" data-hover="读书" class="nav-list-link">读书</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">C++开发学习笔记</h1><div class="post-info">2025-08-12<p id="busuanzi_container_page_pv" class="visit"><span id="busuanzi_value_page_pv"> </span><span>次访问</span></p></div><div class="post-content"><h1><center>C/C++全栈开发学习笔记</center></h1>

<h2 id="1-1-1-随处可见的红黑树"><a href="#1-1-1-随处可见的红黑树" class="headerlink" title="1.1.1 随处可见的红黑树"></a>1.1.1 随处可见的红黑树</h2><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250813231311627.png" alt="image-20250813231311627"></p>
<p>学习目标：</p>
<ul>
<li>能使用C语言实现红黑树</li>
<li>能记住红黑树的代码实现</li>
</ul>
<p>红黑树的性质：</p>
<ol>
<li>每个结点是红的或者黑的</li>
<li>根结点是黑的</li>
<li>每个叶子结点是黑的</li>
<li>如果一个结点是红的，则它的两个儿子都是黑的（不存在相邻红色）</li>
<li><strong>对每个结点，从该结点到其子孙结点的所有路径包含相同数目的黑节点</strong>（即黑高度相同）</li>
<li>最长路径长度不超过最短路径长度的2倍（2n-1，一条黑红黑红，一条全黑）</li>
</ol>
<p>红黑树的优点：插入和删除的时间复杂度优于平衡二叉搜索树，又没有二叉搜索树可能退化为链表的Bug</p>
<ul>
<li>rbTree查询元素：O(log(N))</li>
<li>rbTree插入元素：插入最多2次旋转，加上查询的时间O(log(N))，插入的复杂度O(log(N))</li>
<li>rbTree删除元素：删除最多需要3次旋转，加上查询的时间，删除的复杂度O(log(N))</li>
</ul>
<p>红黑树的应用场景</p>
<ol>
<li>c++ stl map,set（红黑树的封装）</li>
<li>进程调度cfs（用红黑树存储进程的集合，把调度的时间作为key，那么树的左下角时间就是最小的）</li>
<li>内存管理（每次使用malloc的时候都会分配一块小内存出来，那么这么块就是用红黑树来存，如何表述一段内存块呢，用开始地址+长度来表示，所以key-&gt;开始地址，val-&gt;大小）</li>
<li>epoll中使用红黑树管理socketfd</li>
<li>nginx中使用红黑树管理定时器，中序遍历第一个就是最小的定时器</li>
</ol>
<h3 id="红黑树结点的定义"><a href="#红黑树结点的定义" class="headerlink" title="红黑树结点的定义"></a><strong>红黑树结点的定义</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree_node</span> &#123;</span></span><br><span class="line">    <span class="comment">//rbtree</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> color; <span class="comment">// #define RED 0 define BLACK 1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree_node</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree_node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">rbtree_node</span> *<span class="title">right</span>;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    KEY_TYPE key; <span class="comment">// 例如 typedef int KEY_TYPE </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// value	// value 的类型也是自己定义</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125; rbtree_node;</span><br></pre></td></tr></table></figure>

<h3 id="红黑树的定义"><a href="#红黑树的定义" class="headerlink" title="红黑树的定义"></a><strong>红黑树的定义</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rbtree</span> &#123;</span></span><br><span class="line">    <span class="comment">// 只需要一个 root 根结点</span></span><br><span class="line">    rbtree_node *root;</span><br><span class="line">    <span class="comment">// 红黑树中空结点的类型也是红黑树结点，也有left、right、parent指针</span></span><br><span class="line">    rbtree_node *nil; <span class="comment">// NULL </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>红黑树的四个难点：删除、插入、调整、左旋右旋</p>
</blockquote>
<h3 id="红黑树结点的左旋与右旋"><a href="#红黑树结点的左旋与右旋" class="headerlink" title="红黑树结点的左旋与右旋"></a><strong>红黑树结点的左旋与右旋</strong></h3><p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250813231400708.png" alt="image-20250813231400708"></p>
<p>红黑树的左旋操作：左旋就是向左倾斜，记住要操作三条线，六个指针，分别是:</p>
<ul>
<li>x-&gt;right &#x3D; y-&gt;left | y-&gt;left-&gt;parent &#x3D; x</li>
<li>y-&gt;parent &#x3D; x-&gt;parent | x-&gt;parent-&gt;left&#x2F;right &#x3D; y</li>
<li>x-&gt;parent-&gt;left&#x2F;right &#x3D; y | y-&gt;left-&gt;parent &#x3D; x</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rbtree_left_rotate</span><span class="params">(<span class="keyword">struct</span> rbtree *T, rbtree_node *x)</span> &#123;</span><br><span class="line">	<span class="comment">// 左旋只需要一个结点就能完成，引入 T 是为了判断是否为根结点或者叶子结点</span></span><br><span class="line">	<span class="keyword">if</span>(x == T-&gt;nil)  <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 直接读取左旋需要的右节点</span></span><br><span class="line">	rbtree_node *y = x-&gt;right;</span><br><span class="line">	<span class="comment">// x到y的那条线</span></span><br><span class="line">	x-&gt;right = y-&gt;left;</span><br><span class="line">	<span class="keyword">if</span>(y-&gt;left != T-&gt;nil) &#123;</span><br><span class="line">		y-&gt;left-&gt;parent = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// x上面那条线</span></span><br><span class="line">	y-&gt;parent = x-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;parent == T-&gt;nil) &#123;  <span class="comment">// 如果x是根节点</span></span><br><span class="line">        T-&gt;root = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;left) &#123; <span class="comment">// 否则判断x是x父节点的左结点还是右节点</span></span><br><span class="line">    	x-&gt;parent-&gt;left = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// y到b那条线</span></span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>红黑树的右旋操作：右旋就是向右倾斜，由于左旋和右旋是完全对称的，因此在代码上可以直接替换来实现右旋</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x --&gt; y, y --&gt;x </span></span><br><span class="line"><span class="comment">// left --&gt; right, right --&gt; left</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rbtree_right_rotate</span><span class="params">(<span class="keyword">struct</span> rbtree *T, rbtree_node *y)</span> &#123;</span><br><span class="line">    <span class="comment">// NULL --&gt; T-&gt;nil</span></span><br><span class="line">    <span class="keyword">if</span> (y == T-&gt;nil) <span class="keyword">return</span> ;</span><br><span class="line">    rbtree_node *x = y-&gt;left;</span><br><span class="line">	<span class="comment">// y到x的那条线</span></span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != T-&gt;nil) &#123;</span><br><span class="line">        x-&gt;right-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// y上面那条线</span></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == T-&gt;nil) &#123;</span><br><span class="line">        T-&gt;root = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;right) &#123;</span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y-&gt;parent-&gt;left = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// x到b那条线</span></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意红黑树的左旋右旋代码执行顺序</p>
</blockquote>
<h3 id="红黑树插入结点后的调整"><a href="#红黑树插入结点后的调整" class="headerlink" title="红黑树插入结点后的调整"></a><strong>红黑树插入结点后的调整</strong></h3><blockquote>
<p>当插入一个结点时，有时要对红黑树进行调整，包括变色和左旋右旋以及回溯这三个操作</p>
</blockquote>
<p>CASE 1：父节点是爷结点的左子树 且 叔结点是红色的</p>
<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250813234540234.png" alt="image-20250813234540234" style="zoom:67%;" />

<blockquote>
<p>无需旋转，只需要将父节点和叔结点变黑，将爷结点变红，然后令z指向爷结点即回溯调整</p>
</blockquote>
<p>CASE 2：父节点是叶结点的左子树的情况 且 叔结点是红色 以及 当前结点是右孩子</p>
<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250813235352684.png" alt="image-20250813235352684" style="zoom:67%;" />

<blockquote>
<p>此时需要先旋转变为第三种情况，然后按照第三种情况处理，即让当前结点指向其父结点并进行一次左旋</p>
</blockquote>
<p>CASE 3：父节点是祖父结点的左子树 且 叔节点是黑色的 以及 当前结点是左孩子</p>
<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250813235727547.png" alt="image-20250813235727547" style="zoom:67%;" />

<blockquote>
<p>此时需要先将当前结点的父节点变为黑色，以及让爷结点变为红色，然后让爷结点进行一次右旋</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rbtree_insert_fixup</span><span class="params">(rbtree *T, rbtree_node *z)</span> &#123;</span><br><span class="line">	<span class="comment">// z是插入的结点，y是z的父节点，y是z的叔结点</span></span><br><span class="line">    <span class="comment">//只有当父节点是红的时需要调整，因为插入的节点必须为红，两个红色结点不能相邻</span></span><br><span class="line">	<span class="keyword">while</span> (z-&gt;parent-&gt;color == RED) &#123; </span><br><span class="line">		<span class="keyword">if</span> (z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left) &#123;</span><br><span class="line">			rbtree_node *y = z-&gt;parent-&gt;parent-&gt;right;</span><br><span class="line">			<span class="keyword">if</span> (y-&gt;color == RED) &#123; <span class="comment">// 对应于CASE 1</span></span><br><span class="line">				z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				y-&gt;color = BLACK;</span><br><span class="line">				z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				<span class="comment">// 回溯判断调整后是否满足红黑树条件</span></span><br><span class="line">				z = z-&gt;parent-&gt;parent; <span class="comment">// z --&gt; RED</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (z == z-&gt;parent-&gt;right) &#123;  <span class="comment">// 对应于CASE 2</span></span><br><span class="line">					z = z-&gt;parent;</span><br><span class="line">					rbtree_left_rotate(T, z);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 对应于CASE 3</span></span><br><span class="line">				z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				rbtree_right_rotate(T, z-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 而对于父节点是爷结点右子树的情况，只需要镜像替换即可</span></span><br><span class="line">             <span class="comment">// left -&gt; right, right -&gt; left</span></span><br><span class="line">			rbtree_node *y = z-&gt;parent-&gt;parent-&gt;left;</span><br><span class="line">			<span class="keyword">if</span> (y-&gt;color == RED) &#123;</span><br><span class="line">				z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				y-&gt;color = BLACK;</span><br><span class="line">				z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				z = z-&gt;parent-&gt;parent; <span class="comment">// z --&gt; RED</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (z == z-&gt;parent-&gt;left) &#123;</span><br><span class="line">					z = z-&gt;parent;</span><br><span class="line">					rbtree_right_rotate(T, z);</span><br><span class="line">				&#125;</span><br><span class="line">				z-&gt;parent-&gt;color = BLACK;</span><br><span class="line">				z-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">				rbtree_left_rotate(T, z-&gt;parent-&gt;parent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	T-&gt;root-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="红黑树插入结点"><a href="#红黑树插入结点" class="headerlink" title="红黑树插入结点"></a><strong>红黑树插入结点</strong></h3><blockquote>
<p>插入其实很简单，不过是判断大小找到合适的插入位置</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rbtree_insert</span><span class="params">(rbtree *T, rbtree_node *z)</span> &#123;</span><br><span class="line">	rbtree_node *y = T-&gt;nil;</span><br><span class="line">	rbtree_node *x = T-&gt;root;</span><br><span class="line">	<span class="keyword">while</span> (x != T-&gt;nil) &#123;</span><br><span class="line">		y = x;</span><br><span class="line">		<span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key) &#123;</span><br><span class="line">			x = x-&gt;left;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &gt; x-&gt;key) &#123;</span><br><span class="line">			x = x-&gt;right;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//Exist</span></span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	z-&gt;parent = y;</span><br><span class="line">	<span class="keyword">if</span> (y == T-&gt;nil) &#123;</span><br><span class="line">		T-&gt;root = z;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key) &#123;</span><br><span class="line">		y-&gt;left = z;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y-&gt;right = z;</span><br><span class="line">	&#125;</span><br><span class="line">	z-&gt;left = T-&gt;nil;</span><br><span class="line">	z-&gt;right = T-&gt;nil;</span><br><span class="line">	z-&gt;color = RED;</span><br><span class="line">	rbtree_insert_fixup(T, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="红黑树删除结点"><a href="#红黑树删除结点" class="headerlink" title="红黑树删除结点"></a>红黑树删除结点</h3><blockquote>
<p>待办</p>
</blockquote>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2025/08/21/%E5%8D%9A%E5%AE%A2%E5%8D%87%E7%BA%A7/" title="博客升级" class="prev">上一篇</a><a href="/2025/08/12/FIO-%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/" title="FIO 测试学习文档" class="next">下一篇</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz",
    appKey: "FdzS5SOPHdhYQoEUngQ8K2QW",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2016 - 2025 <a target="_blank">David Lee</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p><span id="busuanzi_container_site_pv">本站总访问数：<span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv" style="padding-left: 6px;">访客数：<span id="busuanzi_value_site_uv"></span></span></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>