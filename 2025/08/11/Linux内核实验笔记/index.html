<!DOCTYPE html><html lang="cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> Linux内核实验笔记 · LeeWay</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Linux内核实验笔记 - David Lee"><meta name="keywords" content="Linux内核、C语言、操作系统"><meta name="author" content="David Lee"><link rel="short icon" href="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/favicon-32x32.png"><link rel="stylesheet" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://leeway2zc.top/atom.xml" title="LeeWay"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g==" crossorigin="anonymous" referrerpolicy="no-referrer" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="LeeWay" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250811154253_3.jpg"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/categories/live/" target="_self" data-hover="生活" class="nav-list-link">生活</a></li><li class="nav-list-item"><a href="/categories/read/" target="_self" data-hover="读书" class="nav-list-link">读书</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">Linux内核实验笔记</h1><div class="post-info">2025-08-11<p id="busuanzi_container_page_pv" class="visit"><span id="busuanzi_value_page_pv"> </span><span>次访问</span></p><a href="https://linux-kernel-labs-zh.xyz/" target="_blank" title="https://linux-kernel-labs-zh.xyz/" class="post-from">原文地址</a></div><div class="post-content"><h1><center>OS2 内核编程和驱动程序开发实验</center></h1>

<blockquote>
<p>基于布加勒斯特理工大学自动控制与计算机学院计算机科学与工程系的 “操作系统2” 课程</p>
</blockquote>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h3><ul>
<li>主机：在win10上使用oracle virtualbox创建的 ubuntu 20.04 作为上位机，用于编辑模块源代码、编译模块、将模块应用到操作系统上等</li>
<li>虚拟机：通过Docker配置虚拟机模拟OS内核，在ubuntu 20.04上直接使用，通过脚本运行完成内核模块代码测试</li>
</ul>
<h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><blockquote>
<p>若提示用户没有sudo权限，使用<code>su -</code>切换到 root 用户即可，密码是虚拟机设置镜像时自己设置的，一般就是开机密码</p>
</blockquote>
<ol>
<li><p>在ubuntu 20.04中安装Docker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加 Docker 官方 GPG 密钥</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \</span><br><span class="line">    <span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加 Docker 软件源</span></span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> \</span></span><br><span class="line"><span class="string">  signed-by=/etc/apt/keyrings/docker.gpg] \</span></span><br><span class="line"><span class="string">  https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | \</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 更新 apt 并安装 Docker</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 启动并设置开机启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>在ubuntu 20.04中安装必需软件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y flex bison build-essential gcc-multilib libncurses5-dev \</span><br><span class="line">qemu-system-x86 qemu-system-arm python3 minicom</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个脚本文件并编辑如下内容，随后运行脚本</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ $(<span class="built_in">id</span> -u) != <span class="string">&quot;0&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Please run as root (or use sudo)&quot;</span></span><br><span class="line">   <span class="built_in">exit</span> 1 </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span>&quot;</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#================================= CONSTANTS =================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"></span><br><span class="line">RED=<span class="string">&#x27;\033[0;31m&#x27;</span></span><br><span class="line">NC=<span class="string">&#x27;\033[0m&#x27;</span></span><br><span class="line"></span><br><span class="line">DEFAULT_IMAGE_NAME=<span class="string">&quot;so2/so2-assignments&quot;</span></span><br><span class="line">DEFAULT_TAG=<span class="string">&#x27;latest&#x27;</span></span><br><span class="line">DEFAULT_REGISTRY=<span class="string">&#x27;gitlab.cs.pub.ro:5050&#x27;</span></span><br><span class="line">SO2_WORKSPACE=<span class="string">&quot;/linux/tools/labs&quot;</span></span><br><span class="line">SO2_VOLUME=<span class="string">&quot;SO2_DOCKER_VOLUME&quot;</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#=================================== UTILS ===================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">LOG_INFO</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[<span class="subst">$(date +%FT%T)</span>] [INFO] <span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">LOG_FATAL</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[<span class="subst">$(date +%FT%T)</span>] [<span class="variable">$&#123;RED&#125;</span>FATAL<span class="variable">$&#123;NC&#125;</span>] <span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"><span class="comment">#=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print_help</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;local.sh docker interactive [--privileged]&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;      --privileged - run a privileged container. This allows the use of KVM (if available)&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;      --allow-gui - run the docker such that it can open GUI apps&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">docker_interactive</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> full_image_name=<span class="string">&quot;<span class="variable">$&#123;DEFAULT_REGISTRY&#125;</span>/<span class="variable">$&#123;DEFAULT_IMAGE_NAME&#125;</span>:<span class="variable">$&#123;DEFAULT_TAG&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">local</span> executable=<span class="string">&quot;/bin/bash&quot;</span></span><br><span class="line">    <span class="built_in">local</span> registry=<span class="variable">$&#123;DEFAULT_REGISTRY&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> [[ <span class="variable">$#</span> -gt 0 ]]; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        --privileged)</span><br><span class="line">            privileged=--privileged</span><br><span class="line">            ;;</span><br><span class="line">        --allow-gui)</span><br><span class="line">            allow_gui=<span class="literal">true</span></span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            print_help</span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ $(docker images -q <span class="variable">$full_image_name</span> 2&gt; /dev/null) == <span class="string">&quot;&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        docker pull <span class="variable">$full_image_name</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ! docker volume inspect <span class="variable">$SO2_VOLUME</span> &gt;/dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Volume <span class="variable">$SO2_VOLUME</span> does not exist.&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Creating it&quot;</span></span><br><span class="line">	docker volume create <span class="variable">$SO2_VOLUME</span></span><br><span class="line">	<span class="built_in">local</span> vol_mount=$(docker inspect <span class="variable">$SO2_VOLUME</span> | grep -i mountpoin | <span class="built_in">cut</span> -d : -f2 | <span class="built_in">cut</span> -d, -f1)</span><br><span class="line">	<span class="built_in">chmod</span> 777 -R <span class="variable">$vol_mount</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The /linux directory is made persistent within the <span class="variable">$SO2_VOLUME</span>:&quot;</span></span><br><span class="line">    docker inspect <span class="variable">$SO2_VOLUME</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$allow_gui</span>; <span class="keyword">then</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># TODO: remove this after you change sdl to gtk in qemu-runqemu.sh</span></span><br><span class="line"> 	docker run <span class="variable">$privileged</span> --<span class="built_in">rm</span> -it --cap-add=NET_ADMIN --device /dev/net/tun:/dev/net/tun \</span><br><span class="line">        -v <span class="variable">$SO2_VOLUME</span>:/linux \</span><br><span class="line">        --workdir <span class="string">&quot;<span class="variable">$SO2_WORKSPACE</span>&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$full_image_name</span>&quot;</span> sed <span class="string">&quot;s+\$&#123;QEMU_DISPLAY:-\&quot;sdl\&quot;+\$&#123;QEMU_DISPLAY:-\&quot;gtk\&quot;+g&quot;</span> -i /linux/tools/labs/qemu/run-qemu.sh</span><br><span class="line"></span><br><span class="line">	<span class="comment"># wsl</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">cat</span> /proc/version | grep -i microsoft &amp;&gt; /dev/null ; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">export</span> DISPLAY=<span class="string">&quot;<span class="subst">$(ip r show default | awk &#x27;&#123;print $3&#125;&#x27;)</span>:0.0&quot;</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> [[ <span class="variable">$DISPLAY</span> == <span class="string">&quot;&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;Error: Something unexpected happend. The environment var DISPLAY is not set. Consider setting it with&quot;</span></span><br><span class="line">		<span class="built_in">echo</span> -e <span class="string">&quot;\texport DISPLAY=&lt;dispaly&gt;&quot;</span></span><br><span class="line">		<span class="built_in">exit</span> 1</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">local</span> xauth_var=$(<span class="built_in">echo</span> $(xauth info | grep Auth | <span class="built_in">cut</span> -d: -f2))</span><br><span class="line">        docker run --privileged --<span class="built_in">rm</span> -it \</span><br><span class="line">        --net=host --<span class="built_in">env</span>=<span class="string">&quot;DISPLAY&quot;</span> --volume=<span class="string">&quot;<span class="variable">$&#123;xauth_var&#125;</span>:/root/.Xauthority:rw&quot;</span> \</span><br><span class="line">        -v <span class="variable">$SO2_VOLUME</span>:/linux \</span><br><span class="line">        --workdir <span class="string">&quot;<span class="variable">$SO2_WORKSPACE</span>&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$full_image_name</span>&quot;</span> <span class="string">&quot;<span class="variable">$executable</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        docker run <span class="variable">$privileged</span> --<span class="built_in">rm</span> -it --cap-add=NET_ADMIN --device /dev/net/tun:/dev/net/tun \</span><br><span class="line">        -v <span class="variable">$SO2_VOLUME</span>:/linux \</span><br><span class="line">        --workdir <span class="string">&quot;<span class="variable">$SO2_WORKSPACE</span>&quot;</span> \</span><br><span class="line">        <span class="string">&quot;<span class="variable">$full_image_name</span>&quot;</span> <span class="string">&quot;<span class="variable">$executable</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">docker_main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;interactive&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">        docker_interactive <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;docker&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    docker_main <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;-h&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&quot;--help&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    print_help</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    print_help</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在终端运行脚本</span></span><br><span class="line"><span class="built_in">sudo</span> bash ./local.sh docker interactive --privileged</span><br></pre></td></tr></table></figure>

<blockquote>
<p>显示如下内容时说明配置成功</p>
</blockquote>
<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250804165404202.png" alt="image-20250804165404202" style="zoom:67%;" />

<ol start="4">
<li><p>此时根目录下会出现一个目录&#x2F;linux，这是docker虚拟挂载出来的，只有执行脚本时才会出现这个目录。&#x2F;linux&#x2F;tools&#x2F;lab是这个docker容器的工作目录，是我们编译模块和启动虚拟机的地方。</p>
</li>
<li><p>需要两个Docker内部的终端，通过tmux(终端复用器)可以得到分离的两个终端，输入指令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$tmux</span></span><br></pre></td></tr></table></figure>

<p>使用ctrl+b然后shift+”可以得到水平分割的两个终端，如下所示</p>
<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/docker_tmux_VM.png" style="zoom:67%;" />

<blockquote>
<p>使用ctrl+b然后shift+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>可以得到垂直分割的两个终端，但是不方便复制代码</mtext></mrow><annotation encoding="application/x-tex">可以得到垂直分割的两个终端，但是不方便复制代码</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">可以得到垂直分割的两个终端，但是不方便复制代码</span></span></span></span>   &gt; 使用ctrl+b然后按下 [ 可以自由浏览终端界面，方便复制粘贴代码<br>使用ctrl+b然后按下 d 可以推出tmux，但这会杀死所有tmux正在执行的进程</p>
</blockquote>
</li>
<li><p>配置好环境以后就可以进行试验了，将上面的窗格作为虚拟机OS2，下面的窗格作为主机Docker容器，在上面的窗格中执行以下命令即可生成骨架，开始实验</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ LABS=&lt;实验名称&gt; make skels</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来要启动虚拟机，执行 <code>make console</code> 使用 <code>root</code> 用户名登陆</p>
</li>
<li><p>我们的工作流程包括：在Docker内编写模块代码，修改Make|Kbuild文件，执行make build编译得到ko模块，然后在虚拟机中通过 <code>insmod</code> 命令将其插入到虚拟机，或者通过 <code>rmmod</code> 将其移除。</p>
<blockquote>
<p>每次构建模块无需重启虚拟机，停止虚拟机的操作是 ctrl+a，然后按下 q</p>
</blockquote>
</li>
</ol>
<h2 id="一-内核模块"><a href="#一-内核模块" class="headerlink" title="一 内核模块"></a>一 内核模块</h2><h3 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h3><ul>
<li>创建简单的模块</li>
<li>描述内核模块编译的过程</li>
<li>展示如何在内核中使用模块</li>
<li>简单的内核调试方法</li>
</ul>
<h3 id="1-内核模块的使用-加载-卸载"><a href="#1-内核模块的使用-加载-卸载" class="headerlink" title="1 内核模块的使用|加载|卸载"></a>1 内核模块的使用|加载|卸载</h3><blockquote>
<p>使用 make console 启动虚拟机，并完成以下任务 (正确启动虚拟机以及上位机应该是下面这个界面)</p>
</blockquote>
<ol>
<li>使用<code>ctrl+alt+t</code>打开一个终端，确保pwd下有文件<code>local.sh</code>，使用以下代码进入docker容器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash ./local.sh docker interactive --privileged</span><br></pre></td></tr></table></figure>

<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/%E4%B8%8A%E4%BD%8D%E6%9C%BA.png"  />

<ol start="2">
<li>在docker容器中构建骨架，编写模块代码，编译模块，然后启动虚拟机安装测试模块</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在docker容器中构建骨架，在里面编写代码</span></span><br><span class="line"><span class="comment"># 实验名称一般是skel目录下的目录路径如LABS=&quot;kernel_modules/6-cmd-mod kernel_modules/8-kprobes&quot;</span></span><br><span class="line">LABS=&lt;实验名称&gt; make skels</span><br><span class="line"><span class="comment"># 编写完成后，修改Make和Kbuild文件，使用 make build 编译得到 .ko 模块文件，就可以测试了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用tmux分离出一个终端，使用make console启动虚拟机</span></span><br><span class="line">make console <span class="comment">#使用root用户名login，效果如下，此时主机名为qemu</span></span><br></pre></td></tr></table></figure>

<p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/xv6%E8%99%9A%E6%8B%9F%E6%9C%BA.png"></p>
<ul>
<li>加载内核模块<ol>
<li>在 <code>~/skels/kernel_modules</code> 目录下有很多模块目录，里面存放要完成的任务</li>
</ol>
</li>
</ul>
<p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806091936889.png" alt="image-20250806091936889"></p>
<p>​          2. 在 <code>1-2-test-mod</code> 这个目录下，执行命令 <code>insmod hello_mod.ko</code> 完成模块加载</p>
<p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806092135698.png" alt="image-20250806092135698"></p>
<ul>
<li><p>列出内核模块并检查当前模块是否存在</p>
<ol>
<li><p>使用指令 <code>lsmod</code>  查看模块是否加载成功</p>
<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806092445847.png" alt="image-20250806092445847" style="zoom:67%;" /></li>
</ol>
</li>
<li><p>卸载内核模块</p>
<ol>
<li>使用指令 <code>rmmod hello_mod</code> (不需要后缀) 完成模块卸载</li>
</ol>
</li>
<li><p>使用 <strong>dmesg</strong> 命令查看加载&#x2F;卸载内核模块时显示的消息</p>
<p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806092748489.png" alt="image-20250806092748489"></p>
</li>
</ul>
<h3 id="2-Printk"><a href="#2-Printk" class="headerlink" title="2 Printk"></a>2 Printk</h3><blockquote>
<p>配置系统，使消息不直接显示在串行控制台上，只能使用 <code>dmesg</code> 命令来查看</p>
</blockquote>
<ul>
<li><p>使用命令 <code>echo &quot;4 4 1 7&quot; &gt; /proc/sys/kernel/printk</code> 修改打印日志行为设置</p>
<p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806093723057.png" alt="image-20250806093723057"></p>
</li>
<li><p>此时再加载模块就不会显示消息在串行控制台上了</p>
<p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806094004426.png" alt="image-20250806094004426"></p>
</li>
</ul>
<h3 id="3-错误"><a href="#3-错误" class="headerlink" title="3 错误"></a>3 错误</h3><blockquote>
<p>生成名为 <strong>3-error-mod</strong> 的任务的框架。编译源代码并得到相应的内核模块。</p>
<p>为什么会出现编译错误? <strong>提示:</strong> 这个模块与前一个模块有什么不同？</p>
<p>修改该模块以解决这些错误的原因，然后编译和测试该模块。</p>
</blockquote>
<ul>
<li><p>根据TODO提示，缺少头文件 <code>&lt;linux/module.h&gt;</code>，添加后能编译成功</p>
<p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806104845849.png" alt="image-20250806104845849"></p>
<p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806104917752.png" alt="image-20250806104917752"></p>
</li>
</ul>
<h3 id="4-子模块"><a href="#4-子模块" class="headerlink" title="4 子模块"></a>4 子模块</h3><blockquote>
<p>查看 <code>4-multi-mod/</code> 目录中的 C 源代码文件 <code>mod1.c</code> 和 <code>mod2.c</code>。模块 2 仅包含模块 1 使用的函数的定义。</p>
<p>修改 <code>Kbuild</code> 文件，从这两个 C 源文件创建 <code>multi_mod.ko</code> 模块。</p>
<p>编译、复制、启动虚拟机、加载和卸载内核模块。确保消息在控制台上正确显示。</p>
</blockquote>
<ol>
<li><p>使用 <code>LABS=&quot;kernel_modules/4-multi-mod&quot; make skels</code> 构建骨架</p>
</li>
<li><p>在目录 <code>root@ubuntu20:/linux/tools/labs/skels/kernel_modules/4-multi-mod</code> 中修改Kbuild文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> add rules to create a multi object module</span></span><br><span class="line">obj-m = multi-mod.o</span><br><span class="line">multi-mod-y = mod1.o mod2.o</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后 <code>cd /linux/tools/labs</code> 进行编译 <code>make build</code></p>
</li>
<li><p>启动虚拟机，加载和卸载 <code>multi-mod.ko</code> 模块</p>
<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250806161240091.png" alt="image-20250806161240091" style="zoom:67%;" /></li>
</ol>
<h3 id="5-内核-oops"><a href="#5-内核-oops" class="headerlink" title="5 内核 oops"></a>5 内核 oops</h3><blockquote>
<p>学习当内核模块代码有问题导致模块插入后内核发生了错误应该怎么处理</p>
</blockquote>
<ol>
<li><p>使用 <code>LABS=&quot;kernel_modules/5-oops-mod&quot; make skels</code>  构建骨架</p>
</li>
<li><p>在 <code>root@ubuntu20:/linux/tools/labs/skels/kernel_modules/5-oops-mod</code> 中修改Kbuild文件，为Kbuild文件添加编译标记，使得之后在安装模块时，会出现编译过程信息，提示哪里出现了问题</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> add flags to generate debug information</span></span><br><span class="line">ccflags-y += -g</span><br><span class="line"></span><br><span class="line">obj-m = oops_mod.o</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>make build</code> 进行编译，然后在虚拟机中安装模块 <code>insmod oops_mod.ko</code> 会输出很长一段编译信息，其中最重要的是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 告诉我们错误的原因</span><br><span class="line">BUG: kernel NULL pointer dereference, address: 00000000</span><br><span class="line"># 告诉我们这是第一个 oops（#1）</span><br><span class="line">Oops: 0002 [#1] SMP</span><br><span class="line"># 造成错误的指令的地址，它解码了指令指针 (EIP) 的值，并指出错误出现在 my_oops_init 函数中，偏移为 d个字节</span><br><span class="line">EIP: my_oops_init+0xd/0x22 [oops_mod]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oops 代码（0002）提供了有关错误类型的信息（参见 arch/x86/include/asm/trap_pf.h ）：</span><br><span class="line"></span><br><span class="line">第 0 位 == 0 表示找不到页面，1 表示保护故障</span><br><span class="line">第 1 位 == 0 表示读取，1 表示写入</span><br><span class="line">第 2 位 == 0 表示内核模式，1 表示用户模式</span><br></pre></td></tr></table></figure>
</li>
<li><p>有了 EIP 值就可以使用 address2line 来找到出错的代码出现的位置，在主机中使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addr2line -e oops_mod.ko +0xd</span><br><span class="line">/linux/tools/labs/skels/./kernel_modules/5-oops-mod/oops_mod.c:15</span><br></pre></td></tr></table></figure>

<p>可以知道是 oops_mod.c 的第 15 行出现了问题</p>
</li>
<li><p>由于oops_mod.ko模块加载卡住了，所以无法正常卸载，因此要重启虚拟机才能完成卸载</p>
<blockquote>
<p>模块加载必须经过init函数以及注册exit函数</p>
</blockquote>
</li>
<li><p>重启虚拟机之后，删去第15行代码，重新编译以及插入模块即可完成模块的加载与卸载</p>
<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250807083857615.png" alt="image-20250807083857615" style="zoom:67%;" /></li>
</ol>
<h3 id="6-模块参数"><a href="#6-模块参数" class="headerlink" title="6 模块参数"></a>6 模块参数</h3><blockquote>
<p>在不修改源代码 <code>cmd_mod.c</code> 的情况下，加载内核模块以显示消息 <code>Early bird gets tired</code></p>
</blockquote>
<ul>
<li><p>通过命令行传递参数可以修改函数变量的值从而输出特定内容</p>
<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250807090120386.png" alt="image-20250807090120386" style="zoom: 80%;" />
</li>
<li><p>使用命令行传递参数需要源代码满足以下条件</p>
<ol>
<li><p>变量必须是模块级别的全局变量，不能是函数内部变量，必须像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *str = <span class="string">&quot;default&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>module_param()</code> 宏声明该变量为模块参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">str：变量名</span></span><br><span class="line"><span class="comment">charp：变量类型（支持 int、charp、bool、ulong 等）</span></span><br><span class="line"><span class="comment">0：权限标志位（sysfs 中的访问权限）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">module_param(str, charp, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块必须使用标准 <code>init</code> &#x2F; <code>exit</code> 入口函数机制，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span> &#123; ... &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span> &#123; ... &#125;</span><br><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_exit);</span><br><span class="line"># 这样，内核在执行 insmod 时会先处理模块参数，再调用 init 函数。</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块参数变量声明前不能加 <code>const</code> 因为内核需要在运行时修改它</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// ❌ 无法作为 module_param</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="7-进程信息"><a href="#7-进程信息" class="headerlink" title="7 进程信息"></a>7 进程信息</h3><blockquote>
<p>检查名为 <strong>7-list-proc</strong> 的任务的框架。添加代码来显示当前进程的进程 ID（ <code>PID</code> ）和可执行文件名</p>
</blockquote>
<ol>
<li><p>执行 <code>root@ubuntu20:/linux/tools/labs/skels/kernel_modules/7-list-proc# vim list_proc.c</code> 命令，修改 <code>list_proc.c</code> 文件源代码</p>
</li>
<li><p>在注释TO DO处添加如下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> add missing headers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched/signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/* TODO/2: print current process pid and its name */</span></span><br><span class="line">pr_info(<span class="string">&quot;Current process: pid = %d; comm = %s\n&quot;</span>,</span><br><span class="line">        current-&gt;pid, current-&gt;comm);</span><br><span class="line"><span class="comment">/* TODO/3: print the pid and name of all processes */</span></span><br><span class="line">pr_info(<span class="string">&quot;\nProcess list:\n\n&quot;</span>);</span><br><span class="line">for_each_process(p)</span><br><span class="line">        pr_info(<span class="string">&quot;pid = %d; comm = %s\n&quot;</span>, p-&gt;pid, p-&gt;comm);</span><br><span class="line"><span class="comment">/* TODO/2: print current process pid and name */</span></span><br><span class="line">pr_info(<span class="string">&quot;Current process: pid = %d; comm = %s\n&quot;</span>,</span><br><span class="line">        current-&gt;pid, current-&gt;comm);</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译执行得到如下输出</p>
<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250807100210962.png" alt="image-20250807100210962" style="zoom:67%;" />
</li>
<li><p>这里得查很多资料才能知道这些代码是什么意思</p>
</li>
</ol>
<h3 id="8-KDB"><a href="#8-KDB" class="headerlink" title="8 KDB"></a>8 KDB</h3><blockquote>
<p>使用KDB(Kernel Debugger)分析堆栈找出错误代码位置|使用KDB找到模块加载的地址|在一个新窗口中使用 GDB 并根据 KDB 提供的信息查看代码(没解决)</p>
</blockquote>
<ol>
<li><p>在虚拟机中配置KDB使用hvc0串口 <code>echo hvc0 &gt; /sys/module/kgdboc/parameters/kgdboc</code></p>
</li>
<li><p>使用 SysRq 命令启用 KDB (<strong>Ctrl + O g</strong>)，此时进入KDB调试命令行，输入Help可查看可用KDB命令，如果出现乱码例如文字显示不出来，很多乱码挤在界面右侧，是因为minicom的换行格式有问题，按下 ctrl + A 然后按下 U(或者L)，这样会将minicom从列显示模式切换到行显示模式，此时输出即可恢复正常</p>
<blockquote>
<p> kdb&gt; “这里输入go可以继续执行内核跳出kdb调试，按回车是重新输入并执行上一个命令，按↑是显示上一个命令”</p>
</blockquote>
</li>
<li><p>加载 <code>hello_kdb</code> 模块。该模块在写入 <code>/proc/hello_kdb_bug</code> 文件时会模拟一个错误。使用以下命令模拟错误：<code>echo 1 &gt; /proc/hello_kdb_bug</code></p>
</li>
<li><p>运行这个命令就会发生oops错误，然后会进入KDB调试命令行，使用 <code>[0]kdb&gt; bt</code> 即可分析堆栈跟踪并确定导致错误的代码，bt输出的最下面是执行的起始处(堆栈跟踪要从后往前看)，有些行前面的 ? 是指KDB不确定这个地址偏移是否计算正确，bt输出中最重要的就是kgbd_panic、kgdb_breakpoint这两个点，这表明有函数执行之后发生了错误，可以看到kgbd_panic下面的函数是panic，panic下面的函数是dummy_func1并指明它是 hello_kdb.c文件中的函数，所以错误代码就是 hello_kdb.c 中的函数 dummy_func1 有问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">notify_die+0x4d/0x90</span><br><span class="line">exc_int3+0x5c/0x140</span><br><span class="line">handle_exception+0x140/0x140</span><br><span class="line">EIP: kgdb_breakpoint+0xe/0x20                                                         </span><br><span class="line">Code: b4 26 00 00 00 00 8d b6 00 00 00 00 31 c0 c3 8d b4 26 00 00 00 00 8d b6 00 00 00 00 3e ff8</span><br><span class="line">EAX: 0000001e EBX: c40b9e00 ECX: 00000000 EDX: 00000000</span><br><span class="line">ESI: c180e898 EDI: c1badb40 EBP: c4519e2c ESP: c4519e20                               </span><br><span class="line">DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068 EFLAGS: 00000002                         </span><br><span class="line">? exc_general_protection+0x2c0/0x2c0                                                 </span><br><span class="line">? kgdb_breakpoint+0xe/0x20                                                           </span><br><span class="line">? kgdb_panic+0x4d/0x60                                                               </span><br><span class="line">panic+0xbc/0x266                                                                     </span><br><span class="line">? dummy_func1+0x8/0x8 [hello_kdb]                                                     </span><br><span class="line">dummy_func18+0xd/0xd [hello_kdb]                                                     </span><br><span class="line">dummy_func17+0x8/0x8 [hello_kdb] </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>[0]kdb&gt; lsmod</code> 可以看到模块的加载地址</p>
<p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250808170413340.png" alt="image-20250808170413340"></p>
</li>
</ol>
<h2 id="二-内核-API"><a href="#二-内核-API" class="headerlink" title="二 内核 API"></a>二 内核 API</h2><p>实验目标：</p>
<ul>
<li><p>熟悉基本的Linux内核API</p>
<blockquote>
<p>内核是一个独立运行的实体，不能调用用户空间的任何库，所以不能使用printf、malloc、free等常见的用户控件函数</p>
</blockquote>
</li>
<li><p>描述内存分配机制</p>
</li>
<li><p>描述锁定机制</p>
</li>
</ul>
<h3 id="1-Linux-内核中的内存分配"><a href="#1-Linux-内核中的内存分配" class="headerlink" title="1 Linux 内核中的内存分配"></a>1 Linux 内核中的内存分配</h3><ul>
<li><code>GFP_KERNEL</code> ——使用此值可能导致当前进程被挂起。因此，它不能在中断上下文中使用。</li>
<li><code>GFP_ATOMIC</code> ——使用此值确保 <code>kmalloc()</code> 函数不会挂起当前进程。它可以随时使用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *mem;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="comment">// 第一个参数是字节大小，这里是4096个字节，第二个参数是分配标志</span></span><br><span class="line">    <span class="comment">// 表示这是普通内核上下文分配，允许睡眠、可以进行内存回收</span></span><br><span class="line">	mem = kmalloc(<span class="number">4096</span> * <span class="keyword">sizeof</span>(*mem), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (mem == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_mem;</span><br><span class="line">	<span class="comment">// 打印mem~mem+4096内存地址区间的所有值为字母的元素</span></span><br><span class="line">	pr_info(<span class="string">&quot;chars: &quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isalpha</span>(mem[i]))</span><br><span class="line">			printk(<span class="string">&quot;%c &quot;</span>, mem[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	pr_info(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_mem:</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mem_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	kfree(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重点在于使用kmalloc分配内存给指针，从而能使用指针指向内存空间进行引用、操作，其实kmalloc的用法和malloc差不多</p>
</blockquote>
<h3 id="2-在原子上下文中睡眠"><a href="#2-在原子上下文中睡眠" class="headerlink" title="2 在原子上下文中睡眠"></a>2 在原子上下文中睡眠</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sched_spin_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 定义一个自旋锁变量</span></span><br><span class="line">	<span class="type">spinlock_t</span> lock;</span><br><span class="line">	<span class="comment">// 初始化自旋锁变量</span></span><br><span class="line">	spin_lock_init(&amp;lock);</span><br><span class="line">	<span class="comment">// 执行锁定，此时CPU进入中断上下文进行原语操作，即此时代码运行在由自旋锁保护的临界区域当前进程不能挂起或睡眠</span></span><br><span class="line">	spin_lock(&amp;lock);</span><br><span class="line">	<span class="comment">// 强制使当前进程进入睡眠，因此执行insmod时会报错</span></span><br><span class="line">	set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">	schedule_timeout(<span class="number">5</span> * HZ);</span><br><span class="line">	<span class="comment">// 释放锁定，使用自旋锁时一定注意，在spin_lock和unlock这两个函数之间不能有挂机或睡眠操作代码</span></span><br><span class="line">	spin_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>学习重点在于学会使用自旋锁变量以及使用时的注意要点</p>
</blockquote>
<h3 id="3-使用内核内存"><a href="#3-使用内核内存" class="headerlink" title="3 使用内核内存"></a>3 使用内核内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> &#123;</span></span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> timestamp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti1</span>, *<span class="title">ti2</span>, *<span class="title">ti3</span>, *<span class="title">ti4</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_info *<span class="title function_">task_info_alloc</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1/5: allocated and initialize a task_info struct */</span></span><br><span class="line">	<span class="comment">// 没有使用sizeof(struct task_info)，可能是为了更好的复用，这里参考1内存分配的操作即可</span></span><br><span class="line">    ti = kmalloc(<span class="keyword">sizeof</span>(*ti), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (ti == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	ti-&gt;pid = pid;</span><br><span class="line">    <span class="comment">// jiffies 是一个全局可见变量，表示当前的时间</span></span><br><span class="line">	ti-&gt;timestamp = jiffies;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">memory_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* TODO 2/1: call task_info_alloc for current pid */</span></span><br><span class="line">    <span class="comment">// current是一个可以直接使用的宏，等价于struct task_struct结构体，使用current-&gt;pid查找当前进程的PID值</span></span><br><span class="line">	ti1 = task_info_alloc(current-&gt;pid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2/1: call task_info_alloc for parent PID */</span></span><br><span class="line">	<span class="comment">// 使用current-&gt;parent查找当前进程的父进程，这里纯属背板操作，无需了解为什么</span></span><br><span class="line">    ti2 = task_info_alloc(current-&gt;parent-&gt;pid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2/1: call task_info alloc for next process PID */</span></span><br><span class="line">    <span class="comment">// 使用next_task(current)宏找到当前进程的下一个进程</span></span><br><span class="line">	ti3 = task_info_alloc(next_task(current)-&gt;pid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2/1: call task_info_alloc for next process of the next process */</span></span><br><span class="line">	ti4 = task_info_alloc(next_task(next_task(current))-&gt;pid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">memory_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 3/4: print ti* field values */</span></span><br><span class="line">	printk(<span class="string">&quot;pid: %d, timestamp: %lu\n&quot;</span>, ti1-&gt;pid, ti1-&gt;timestamp);</span><br><span class="line">	printk(<span class="string">&quot;pid: %d, timestamp: %lu\n&quot;</span>, ti2-&gt;pid, ti2-&gt;timestamp);</span><br><span class="line">	printk(<span class="string">&quot;pid: %d, timestamp: %lu\n&quot;</span>, ti3-&gt;pid, ti3-&gt;timestamp);</span><br><span class="line">	printk(<span class="string">&quot;pid: %d, timestamp: %lu\n&quot;</span>, ti4-&gt;pid, ti4-&gt;timestamp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 4/4: free ti* structures */</span></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">	kfree(ti1);</span><br><span class="line">	kfree(ti2);</span><br><span class="line">	kfree(ti3);</span><br><span class="line">	kfree(ti4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重点在于学习如何给分配了内存的变量赋值以及如何使用current宏、next_task宏找到进程PID值</p>
</blockquote>
<h3 id="4-使用内核列表"><a href="#4-使用内核列表" class="headerlink" title="4 使用内核列表"></a>4 使用内核列表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> &#123;</span></span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> timestamp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_info *<span class="title function_">task_info_alloc</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	ti = kmalloc(<span class="keyword">sizeof</span>(*ti), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (ti == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	ti-&gt;pid = pid;</span><br><span class="line">	ti-&gt;timestamp = jiffies;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_info_add_to_list</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1/2: Allocate task_info and add it to list */</span></span><br><span class="line">    <span class="comment">// 分配内存给ti变量,ti是一个task_info结构体指针，描述任务信息(这里指描述当前进程的PID和时间)</span></span><br><span class="line">	ti = task_info_alloc(pid);</span><br><span class="line">	<span class="comment">// 将ti添加到链表，注意list_add函数的用法，传入的是ti-&gt;list的地址和head的地址(没有使用结构体指针)</span></span><br><span class="line">    list_add(&amp;ti-&gt;<span class="built_in">list</span>, &amp;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_info_add_for_current</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Add current, parent, next and next of next to the list */</span></span><br><span class="line">	task_info_add_to_list(current-&gt;pid);</span><br><span class="line">	task_info_add_to_list(current-&gt;parent-&gt;pid);</span><br><span class="line">	task_info_add_to_list(next_task(current)-&gt;pid);</span><br><span class="line">	task_info_add_to_list(next_task(next_task(current))-&gt;pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_info_print_list</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;%s: [ &quot;</span>, msg);</span><br><span class="line">	list_for_each(p, &amp;head) &#123;</span><br><span class="line">		ti = list_entry(p, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line">		pr_info(<span class="string">&quot;(%d, %lu) &quot;</span>, ti-&gt;pid, ti-&gt;timestamp);</span><br><span class="line">	&#125;</span><br><span class="line">	pr_info(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_info_purge_list</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>, *<span class="title">q</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2/5: Iterate over the list and delete all elements */</span></span><br><span class="line">    <span class="comment">// 这里要注意，list_for_each_safe是一个宏而不是函数，不要加分号</span></span><br><span class="line">	list_for_each_safe(p, q, &amp;head) &#123;</span><br><span class="line">		<span class="comment">// list_entry是找到当前链表节点相对应的原来的结构体指针变量，即映射回去</span></span><br><span class="line">        ti = list_entry(p, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line">		list_del(p);</span><br><span class="line">		kfree(ti);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  知识点</p>
<ul>
<li><code>list_entry(ptr, type, member)()</code> 返回列表中包含元素 <code>ptr</code> 的类型为 <code>type</code> 的结构，该结构中具有名为 <code>member</code> 的成员。</li>
<li><code>list_for_each(pos, head)</code> 使用 <code>pos</code> 作为游标来迭代列表。</li>
<li><code>list_for_each_safe(pos, n, head)</code> 使用 <code>pos</code> 作为游标，<code>n</code> 作为临时游标来迭代列表。此宏用于从列表中删除项目。</li>
<li><code>list_del(struct list_head *entry)()</code> 删除属于列表的 <code>entry</code> 地址处的项目。</li>
<li><code>list_add(struct list_head *new, struct list_head *head)()</code> 将 <code>new</code> 指针所引用的元素添加到 <code>head</code> 指针所引用的元素之后。</li>
<li>使用 <code>static struct list_head head;</code> 来声明一个链表头，在使用head前进行 <code>INIT_LIST_HEAD(&amp;head);</code> </li>
<li><code>INIT_LIST_HEAD(struct list_head *list)()</code> 用于在进行动态分配时，通过设置链表字段 <code>next</code> 和 <code>prev</code>，来初始化链表的标记。</li>
</ul>
<h3 id="5-使用内核列表进行进程处理"><a href="#5-使用内核列表进行进程处理" class="headerlink" title="5 使用内核列表进行进程处理"></a>5 使用内核列表进行进程处理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel_api\5-list-full\list-full.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_info *<span class="title function_">task_info_find_pid</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1/5: Look for pid and return task_info or NULL if not found */</span></span><br><span class="line">	<span class="comment">// 找到成员pid值等于参数pid值的链表节点ti</span></span><br><span class="line">    list_for_each(p, &amp;head) &#123;</span><br><span class="line">		ti = list_entry(p, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (ti-&gt;pid == pid)</span><br><span class="line">			<span class="keyword">return</span> ti;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">list_full_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2/2: Ensure that at least one task is not deleted */</span></span><br><span class="line">	<span class="comment">// 这里要学会使用原子操作函数atomic_set，原子操作是一种不会被打断必定执行的操作，必须使用原子变量atomic_t</span></span><br><span class="line">    ti = list_entry(head.prev, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;ti-&gt;count, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	task_info_remove_expired();</span><br><span class="line">	task_info_print_list(<span class="string">&quot;after removing expired&quot;</span>);</span><br><span class="line">	task_info_purge_list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一些常用的原子操作函数</p>
</blockquote>
<p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/Snipaste_2025-08-13_15-12-15.png"></p>
<h3 id="6-同步列表工作"><a href="#6-同步列表工作" class="headerlink" title="6 同步列表工作"></a>6 同步列表工作</h3><blockquote>
<p>代码相关答案可以看&#x2F;templates文件夹下的代码</p>
</blockquote>
<p>  使用DEFINE_RWLOCK(lock)定义一个读写自旋锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TODO 1: you can use either a spinlock or rwlock, define it here */</span></span><br><span class="line">DEFINE_RWLOCK(lock);</span><br></pre></td></tr></table></figure>

<p>  读写自旋锁中的代码涉及到的共享资源会被锁定</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">write_lock(&amp;lock);</span><br><span class="line"><span class="comment">/* 临界区（critical region） */</span></span><br><span class="line">ti = task_info_find_pid(pid);</span><br><span class="line"><span class="keyword">if</span> (ti != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ti-&gt;timestamp = jiffies;</span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;ti-&gt;count);</span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> Guess why this comment was added  here */</span></span><br><span class="line">    <span class="comment">/* 临界区（critical region） */</span></span><br><span class="line">    write_unlock(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TODO 1: critical section ends here */</span></span><br><span class="line"><span class="comment">/* 临界区（critical region） */</span></span><br><span class="line">write_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">read_lock(&amp;lock);</span><br><span class="line">list_for_each(p, &amp;head) &#123;</span><br><span class="line">    ti = list_entry(p, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line">    pr_info(<span class="string">&quot;(%d, %lu) &quot;</span>, ti-&gt;pid, ti-&gt;timestamp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* TODO 1: Critical section ends here */</span></span><br><span class="line">read_unlock(&amp;lock);</span><br><span class="line">pr_info(<span class="string">&quot;]\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  简单来说，就是write_lock和write_unlock之间的代码片段当cpu在执行时会进入临界区，此时如果是write_lock，那就是只有当前的进程能写，其他的进程包括CPU都不能写，如果是read_lock，那就是所有进程都不能写，但是可以一起读</p>
<blockquote>
<p>如果代码只涉及共享资源的访问就使用read_lock，如果设计对共享资源的修改就使用write_lock，在这个例子中，由于要修改ti的时间戳和计数器，所以使用了write_lock读自旋锁，而只需要打印ti的pid和时间戳，所以使用read_lock</p>
</blockquote>
<p>  关于 <code>EXPORT_SYMBOL(name);</code> ，其作用是导出模块代码中的函数或者变量给其它模块使用，当模块代码中使用了 <code>EXPORT_SYMBOL(name);</code> 那么加载此模块后，其他模块也能使用 name 代表的函数或者变量，但有几点要求</p>
<ol>
<li>函数或变量不能是静态的，即不能使用 static 关键字</li>
<li>必须在函数定义或变量赋值后使用</li>
</ol>
<h3 id="7-在我们的列表模块中测试模块调用"><a href="#7-在我们的列表模块中测试模块调用" class="headerlink" title="7 在我们的列表模块中测试模块调用"></a>7 在我们的列表模块中测试模块调用</h3><p>  这一节没什么好讲的，就是一个模块依赖关系，如果模块代码使用了其他模块导出的内核符号name，则这个模块依赖于其他模块，被依赖的模块由于模块引用计数refcnt&gt;0无法卸载，所以必须先卸载依赖模块，在这个例子中就是必须先卸载 list-test 模块，然后卸载 list-sync 模块</p>
<p>  除此以外，如果一个模块要使用其他模块导出的内核符号(函数或者变量)，必须先extern声明这个内核符号再使用，例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要使用 task_info_print_list</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_info_print_list</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> <span class="comment">//被依赖模块代码</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;%s: [ &quot;</span>, msg);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: Protect list, is this read or write access? */</span></span><br><span class="line">	read_lock(&amp;lock);</span><br><span class="line">	list_for_each(p, &amp;head) &#123;</span><br><span class="line">		ti = list_entry(p, <span class="keyword">struct</span> task_info, <span class="built_in">list</span>);</span><br><span class="line">		pr_info(<span class="string">&quot;(%d, %lu) &quot;</span>, ti-&gt;pid, ti-&gt;timestamp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* TODO 1: Critical section ends here */</span></span><br><span class="line">	read_unlock(&amp;lock);</span><br><span class="line">	pr_info(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(task_info_print_list);</span><br><span class="line"><span class="comment">// 必须先 extern task_info_print_list</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">task_info_print_list</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span>; <span class="comment">//依赖模块代码</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>很多东西都是背板式的，如果每个不熟悉的符号都使用LXR或cscope去查询，会消耗大量时间而且不一定能查找正确，学习linux内核编程有如学习一个语法无比复杂的语言，与其先背下来所有单词和认识所有语法后再实践练习使用，不如先开口把最常用最实用的操作记下来，让自己变得熟练，那么以前那些晦涩难懂的知识也就比较容易理解了</p>
</blockquote>
<h2 id="三-字符设备驱动程序"><a href="#三-字符设备驱动程序" class="headerlink" title="三 字符设备驱动程序"></a>三 字符设备驱动程序</h2><p> 实验目标</p>
<ul>
<li>理解字符设备驱动程序背后的概念</li>
<li>理解可以在字符设备上执行的各种操作</li>
<li>使用等待队列进行工作</li>
</ul>
<h3 id="0-简介"><a href="#0-简介" class="headerlink" title="0 简介"></a>0 简介</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct file -linux - linux-2.6.0\include\linux\fs.h</span></span><br><span class="line"><span class="comment">// struct file_operations - linux-2.6.0\include\linux\fs.h</span></span><br><span class="line"><span class="comment">// generic_ro_fops - linux-2.6.0\include\linux\fs.h</span></span><br><span class="line"><span class="comment">// vfs_read() - linux-2.6.0\fs\read_write.c</span></span><br></pre></td></tr></table></figure>

<h3 id="1-注册-注销"><a href="#1-注册-注销" class="headerlink" title="1 注册&#x2F;注销"></a>1 注册&#x2F;注销</h3><ol>
<li>使用 <strong>mknod</strong> 创建 <strong>&#x2F;dev&#x2F;so2_cdev</strong> 字符设备节点</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在QUMU上使用mknod命令</span></span><br><span class="line">mknod /dev/so2_cdev c <span class="number">42</span> <span class="number">0</span></span><br><span class="line"><span class="comment">// 42是主设备号，0是此设备号，均在so2_cdev.c中定义过</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时只是创建了一个节点，要使用register_chrdev_region完成注册才能在&#x2F;proc&#x2F;devices中看到设备文件</p>
</blockquote>
<ol start="2">
<li>实现设备的注册和注销</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TODO 1/6: register char device region for MY_MAJOR and NUM_MINORS starting at MY_MINOR */</span></span><br><span class="line">err = register_chrdev_region(MKDEV(MY_MAJOR, MY_MINOR),</span><br><span class="line">			NUM_MINORS, MODULE_NAME);</span><br><span class="line"><span class="comment">/* TODO 1/1: unregister char device region, for MY_MAJOR and NUM_MINORS starting at MY_MINOR */</span></span><br><span class="line">unregister_chrdev_region(MKDEV(MY_MAJOR, MY_MINOR),NUM_MINORS);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MKDEV的意思是从主设备号MY_MAJOR开始注册次设备号MY_MINOR，注册NUM_MINORS个设备文件，如果当前主设备号下的设备文件数大于NUM_MINORS，则让主设备号＋1继续注册</p>
</blockquote>
<h3 id="2-注册一个已经注册过的主设备号"><a href="#2-注册一个已经注册过的主设备号" class="headerlink" title="2 注册一个已经注册过的主设备号"></a>2 注册一个已经注册过的主设备号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 cat proc/devices 看已有的设备文件的主设备号，然后替换掉下面的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MAJOR		42</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时会返回错误码 -16，#define EBUSY  16   &#x2F;* Device or resource busy *&#x2F; 表示是当前设备正忙无法被注册</p>
</blockquote>
<h3 id="3-打开和关闭"><a href="#3-打开和关闭" class="headerlink" title="3 打开和关闭"></a>3 打开和关闭</h3><blockquote>
<p>打开和关闭字符设备文件</p>
</blockquote>
<ol>
<li>初始化设备</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">so2_device_data</span> &#123;</span></span><br><span class="line">	<span class="comment">/* TODO 2/1: add cdev member */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">	<span class="comment">/* TODO 4/2: add buffer with BUFSIZ elements */</span></span><br><span class="line">	<span class="type">char</span> buffer[BUFSIZ];</span><br><span class="line">	<span class="type">size_t</span> size;</span><br><span class="line">	<span class="comment">/* TODO 7/2: extra members for home */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> wq;</span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="comment">/* TODO 3/1: add atomic_t access variable to keep track if file is opened */</span></span><br><span class="line">	<span class="type">atomic_t</span> access;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为当前设备文件建立一个结构体，成员有cdev结构体，该结构体用于在系统中注册字符设备(供cdev_init和cdev_add函数使用)，字符数组buffer用于读操作，size用于指示传输数据的大小，access是一个原子变量，用于计数实现阻塞其它进程干涉，这里只需要关注 TODO 2&#x2F;1</p>
</blockquote>
<ol start="2">
<li>实现打开和释放函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在结构体定义static const struct file_operations so2_fops中</span></span><br><span class="line"><span class="comment">/* TODO 2/2: add open and release functions */</span></span><br><span class="line">.open = so2_cdev_open,</span><br><span class="line">.release = so2_cdev_release,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数so2_cdev_open中</span></span><br><span class="line"><span class="comment">/* TODO 3/1: inode-&gt;i_cdev contains our cdev struct, use container_of to obtain a pointer to so2_device_data */</span></span><br><span class="line"><span class="comment">// 获取当前设备文件的结构体</span></span><br><span class="line">data = container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> so2_device_data, cdev);</span><br><span class="line"><span class="comment">// 让file指针指向当前设备文件，实现打开</span></span><br><span class="line">file-&gt;private_data = data;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>container_of 宏用于从一个结构体成员的地址反推出成员所在的结构体的首地址，用法是container_of(ptr, type, member)，在这个例子中container_of 从 inode-&gt;i_cdev（一个struct cdev 类型的指针，指向so2_device_data的成员cdev）反推出它所在的 struct so2_device_data 结构体的首地址，从而获得设备的私有数据指针 data</p>
</blockquote>
<ol start="3">
<li>显示消息</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用pr_info函数，与printf类似</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>再次读取</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 cat /dev/so2_cdev</span></span><br></pre></td></tr></table></figure>

<h3 id="4-访问限制"><a href="#4-访问限制" class="headerlink" title="4 访问限制"></a>4 访问限制</h3><blockquote>
<p>使用原子变量限制设备访问</p>
</blockquote>
<ol>
<li>在设备结构体中添加 <code>atomic_t</code> 变量</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在结构体so2_device_data中</span></span><br><span class="line"><span class="comment">/* TODO 3/1: add atomic_t access variable to keep track if file is opened */</span></span><br><span class="line"><span class="type">atomic_t</span> access;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在模块初始化时对该变量进行初始化</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数so2_cdev_init中</span></span><br><span class="line"><span class="comment">/* TODO 3/1: set access variable to 0, use atomic_set */</span></span><br><span class="line"><span class="type">atomic_set</span>(&amp;devs[i].access, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 这里的devs是设备文件的实例化，在设备文件结构体下有定义</span></span><br><span class="line"><span class="comment">// struct so2_device_data devs[NUM_MINORS];</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在打开函数中使用该变量限制对设备的访问。我们建议使用 <code>atomic_cmpxchg()</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数so2_cdev_open中</span></span><br><span class="line"><span class="comment">/* TODO 3/2: return immediately if access is != 0, use atomic_cmpxchg */</span></span><br><span class="line"><span class="keyword">if</span> (atomic_cmpxchg(&amp;data-&gt;access, <span class="number">0</span>, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EBUSY;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>static inline int atomic_cmpxchg(atomic_t *ptr, int old, int new)<br>这个函数可以在一个原子操作中检查变量的旧值并将其设为新值，在上面的例子中，它表示如果当前的access等于旧值0就将access设为1，不等于0就不修改，无论是否发生替换，atomic_cmpxchg函数都会返回ptr指向的原始值（也就是操作之前的值）。</p>
</blockquote>
<ol start="4">
<li>在释放函数中重置该变量以恢复对设备的访问权限</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在函数so2_cdev_release中</span></span><br><span class="line"><span class="comment">/* TODO 3/1: reset access variable to 0, use atomic_set */</span></span><br><span class="line"><span class="type">atomic_set</span>(&amp;data-&gt;access, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>模拟休眠</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在函数so2_cdev_open中</span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">schedule_timeout(1000);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>set_current_state(TASK_INTERRUPTIBLE);</code>把当前进程（<code>current</code>）的状态设置为可中断睡眠 (<code>TASK_INTERRUPTIBLE</code>)。在这个状态下，进程会被调度器认为是“睡着的”，直到有事件唤醒它<br><code>schedule_timeout(10 * HZ);</code>把当前进程从 CPU 调度队列里移走，并设置一个定时器，在 <code>10 * HZ</code> 个 <strong>jiffies</strong> 后唤醒它。<code>HZ</code> 是内核的时钟频率（例如在 x86 上常见是 100、250 或 1000），<code>10 * HZ</code> 表示 10 秒。如果在这段时间内进程收到信号，会提前被唤醒。</p>
</blockquote>
<h3 id="5-读操作"><a href="#5-读操作" class="headerlink" title="5 读操作"></a>5 读操作</h3><blockquote>
<p>在驱动程序中实现读取函数</p>
</blockquote>
<ol>
<li>在 <code>so2_device_data</code> 结构中保持一个缓冲区，并用 <code>MESSAGE</code> 宏的值进行初始化。缓冲区的初始化在模块的 <code>init</code> 函数中完成</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct so2_device_data</span></span><br><span class="line"><span class="comment">/* TODO 4/2: add buffer with BUFSIZ elements */</span></span><br><span class="line"><span class="type">char</span> buffer[BUFSIZ];</span><br><span class="line"><span class="type">size_t</span> size;</span><br><span class="line"><span class="comment">// static int so2_cdev_init(void)</span></span><br><span class="line"><span class="comment">/*TODO 4/2: initialize buffer with MESSAGE string */</span></span><br><span class="line"><span class="built_in">memcpy</span>(devs[i].buffer, MESSAGE, <span class="keyword">sizeof</span>(MESSAGE));</span><br><span class="line">devs[i].size = <span class="keyword">sizeof</span>(MESSAGE);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在读取调用时，将内核空间缓冲区的内容复制到用户空间缓冲区</li>
</ol>
<p>使用 <code>copy_to_user()</code> 函数将信息从内核空间复制到用户空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static ssize_t so2_cdev_read(file, user_buffer, size, offset)</span></span><br><span class="line"><span class="comment">// 首先定义传输的字节数to_read以及获取设备文件指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">so2_device_data</span> *<span class="title">data</span> =</span></span><br><span class="line">		(<span class="keyword">struct</span> so2_device_data *) file-&gt;private_data;</span><br><span class="line"><span class="type">size_t</span> to_read = (size &gt; data-&gt;size - *offset) ? (data-&gt;size - *offset) : size;</span><br><span class="line"><span class="comment">/* TODO 4/4: Copy data-&gt;buffer to user_buffer, use copy_to_user */</span></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(user_buffer, data-&gt;buffer + *offset, to_read) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">*offset += to_read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> to_read;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要将请求的字节数size和内部缓冲区大小data-&gt;size - *offset作比较，有可能请求的字节数要超过内部缓存区大小，从而引发错误，其实这里应该是判断 size+*offset &gt; data-&gt;size，可能为了防止越界写成了减去，注意要更新偏移参数，以便于用户达到文件内部缓冲区末尾时退出</p>
</blockquote>
<blockquote>
<p>读取函数so2_cdev_read调用返回的值是从内核空间缓冲区传输到用户空间缓冲区的字节数</p>
</blockquote>
<h3 id="6-写操作"><a href="#6-写操作" class="headerlink" title="6 写操作"></a>6 写操作</h3><h3 id="7-ioctl-操作"><a href="#7-ioctl-操作" class="headerlink" title="7 ioctl 操作"></a>7 ioctl 操作</h3><h3 id="8-带消息的-ioctl"><a href="#8-带消息的-ioctl" class="headerlink" title="8 带消息的 ioctl"></a>8 带消息的 ioctl</h3><h3 id="9-使用等待队列的-ioctl"><a href="#9-使用等待队列的-ioctl" class="headerlink" title="9 使用等待队列的 ioctl"></a>9 使用等待队列的 ioctl</h3><h3 id="10-O-NONBLOCK-实现"><a href="#10-O-NONBLOCK-实现" class="headerlink" title="10 O_NONBLOCK 实现"></a>10 O_NONBLOCK 实现</h3><h2 id="四-I-O访问和中断"><a href="#四-I-O访问和中断" class="headerlink" title="四 I&#x2F;O访问和中断"></a>四 I&#x2F;O访问和中断</h2><p>实验目标：</p>
<ul>
<li><p>与外围设备进行通信</p>
</li>
<li><p>实现中断处理程序</p>
</li>
<li><p>将中断与进程上下文同步</p>
</li>
</ul>
<p>关键词：IRQ，I&#x2F;O 端口，I&#x2F;O 地址，基地址，UART，request_region，release_region，inb，outb</p>
<h3 id="0-简介-1"><a href="#0-简介-1" class="headerlink" title="0 简介"></a>0 简介</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//resource - /inclue/linux/ioport.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">	<span class="type">resource_size_t</span> start;</span><br><span class="line">	<span class="type">resource_size_t</span> end;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> desc;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//request_region - /inclue/linux/ioport.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request_region(start,n,name)\</span></span><br><span class="line"><span class="meta">		__request_region(&amp;ioport_resource, (start), (n), (name), 0)</span></span><br><span class="line"><span class="comment">//__request_region() - /kernel/resource.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *__<span class="title">request_region</span>(<span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>,</span></span><br><span class="line"><span class="class">				  <span class="title">resource_size_t</span> <span class="title">start</span>, <span class="title">resource_size_t</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">				  <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, <span class="title">int</span> <span class="title">flags</span>)</span></span><br><span class="line"><span class="class">//<span class="title">request_irq</span>() - /<span class="title">include</span>/<span class="title">linux</span>/<span class="title">interrupt</span>.<span class="title">h</span></span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">inline</span> <span class="title">int</span> __<span class="title">must_check</span></span></span><br><span class="line"><span class="class"><span class="title">request_irq</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">irq</span>, <span class="title">irq_handler_t</span> <span class="title">handler</span>, <span class="title">unsigned</span> <span class="title">long</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">	    <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, <span class="title">void</span> *<span class="title">dev</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//request_threaded_irq() - /kernel/irq/manage.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br></pre></td></tr></table></figure>

<h3 id="实现键盘驱动程序"><a href="#实现键盘驱动程序" class="headerlink" title="实现键盘驱动程序"></a>实现键盘驱动程序</h3><p>  目标是创建一个使用键盘IRQ的驱动程序，检查传入的按键代码并将其存储在缓冲区中。通过字符设备驱动程序，用户空间可以访问该缓冲区。</p>
<blockquote>
<p>如果说上一个实验字符设备驱动程序是关于如何驱动外设如何实现物理设备的读写I&#x2F;O操作，那么这个实验是关于如何通过中断来操控外设</p>
</blockquote>
<h3 id="1-请求I-O端口"><a href="#1-请求I-O端口" class="headerlink" title="1 请求I&#x2F;O端口"></a>1 请求I&#x2F;O端口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 kbd_init 函数中</span></span><br><span class="line"><span class="comment">/* TODO 1/8: request the keyboard I/O ports */</span></span><br><span class="line"><span class="keyword">if</span> (request_region(I8042_DATA_REG+<span class="number">1</span>, <span class="number">1</span>, MODULE_NAME) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    err = -EBUSY;</span><br><span class="line">    <span class="keyword">goto</span> out_unregister;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (request_region(I8042_STATUS_REG+<span class="number">1</span>, <span class="number">1</span>, MODULE_NAME) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    err = -EBUSY;</span><br><span class="line">    <span class="keyword">goto</span> out_release_region;</span><br><span class="line">&#125;</span><br><span class="line">out_release_regions:</span><br><span class="line">	release_region(I8042_STATUS_REG+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">out_release_region:</span><br><span class="line">	release_region(I8042_DATA_REG+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">out_unregister:</span><br><span class="line">	unregister_chrdev_region(MKDEV(KBD_MAJOR, KBD_MINOR),</span><br><span class="line">				 KBD_NR_MINORS);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"><span class="comment">// 在 kbd_exit 函数中</span></span><br><span class="line"><span class="comment">/* TODO 1/2: release keyboard I/O ports */</span></span><br><span class="line">release_region(I8042_STATUS_REG+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">release_region(I8042_DATA_REG+<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请求 I&#x2F;O 端口后，可以在&#x2F;proc&#x2F;ioports中找到自己的端口号<br>如果遇到报错提示-EBUSY，可能是因为没有执行release_region或者unregister_chrdev_region，需要在init函数开头写release_region或者unregister_chrdev_region然后重新插入模块</p>
</blockquote>
<h3 id="2-中断处理例程"><a href="#2-中断处理例程" class="headerlink" title="2 中断处理例程"></a>2 中断处理例程</h3><blockquote>
<p>所谓中断处理例程，就是中断发生时会执行的代码功能函数，一般是xxx_interrupt_handler()</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己写的一个函数 kbd_interrupt_handle 注意类型是 irqreturn_t</span></span><br><span class="line"><span class="comment">/* TODO 2/27: implement interrupt handler */</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">kbd_interrupt_handle</span><span class="params">(<span class="type">int</span> irq_no, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 当中断发生时输出</span></span><br><span class="line">    pr_info(<span class="string">&quot;You just pressed A key!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* TODO 3: read the scancode */</span></span><br><span class="line">	<span class="comment">/* TODO 3/2: interpret the scancode */</span></span><br><span class="line">	<span class="comment">/* TODO 3/2: display information about the keystrokes */</span></span><br><span class="line">	<span class="comment">/* TODO 3/7: store ASCII key to buffer */</span></span><br><span class="line">	<span class="keyword">return</span> IRQ_NONE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 kbd_init 函数中, 注册中断处理例程，使用 request_irq</span></span><br><span class="line"><span class="comment">/* TODO 2/7: Register IRQ handler for keyboard IRQ (IRQ 1). */</span></span><br><span class="line">err = request_irq(I8042_KBD_IRQ,</span><br><span class="line">        kbd_interrupt_handle,</span><br><span class="line">        IRQF_SHARED, MODULE_NAME, &amp;devs[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">    pr_err(<span class="string">&quot;request_irq failed: %d\n&quot;</span>, err);</span><br><span class="line">    <span class="keyword">goto</span> out_release_regions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用request_irq注册中断例程后，能在&#x2F;proc&#x2F;interrupts中看到自己的中断程序 kbd</p>
</blockquote>
<p><img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817211748806.png" alt="image-20250817211748806"></p>
<blockquote>
<p>按照“注意”的提示使用 <code>QEMU_DISPLAY=gtk make boot</code> 是无法启动成功的，因为QEMU中的Makefile指定需要下载yotco2.4版本的镜像系统，但是链接早就失效了，必须修改QEMU中的Makefile的yotco版本号为4.1才能正常下载系统镜像从而启动，如下图所示修改，如果下载的很慢或者还是下载不了，可能需要使用代理，使用clash-verge的TUN模式可以让虚拟机走代理</p>
</blockquote>
<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817211057473.png" alt="image-20250817211057473" style="zoom:67%;" />

<blockquote>
<p>没有报错之后应该能正常启动系统，如下所示</p>
</blockquote>
<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817211345350.png" alt="image-20250817211345350" style="zoom:67%;" />

<blockquote>
<p>但此时要退出来，因为没有在Docker内执行 <code>make copy</code>，执行前系统内是没有 <code>skels</code> 这个文件夹的</p>
</blockquote>
<p>在QEMU中按下键盘按键会触发中断例程程序，使用dmesg可以看到：</p>
<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817211707033.png" alt="image-20250817211707033" style="zoom: 80%;" />

<h3 id="3-将-ASCII-键存储到缓冲区"><a href="#3-将-ASCII-键存储到缓冲区" class="headerlink" title="3 将 ASCII 键存储到缓冲区"></a>3 将 ASCII 键存储到缓冲区</h3><h4 id="读取数据存储器"><a href="#读取数据存储器" class="headerlink" title="读取数据存储器"></a>读取数据存储器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用函数 inb 读取 I/O 端口的数据，只读一个字符大小的数据(1 Byte)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u8 <span class="title function_">i8042_read_data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 val;</span><br><span class="line">	<span class="comment">/* TODO 3: Read DATA register (8 bits). */</span></span><br><span class="line">	val = inb(I8042_DATA_REG);  <span class="comment">// 此时读取的是寄存器中的扫描码，还需要转换才能成为ASCII码</span></span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 kbd_interrupt_handle 函数中</span></span><br><span class="line"><span class="comment">/* TODO 3: read the scancode */</span></span><br><span class="line">scancode = i8042_read_data();</span><br></pre></td></tr></table></figure>

<h4 id="解释扫描码"><a href="#解释扫描码" class="headerlink" title="解释扫描码"></a>解释扫描码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 kbd_interrupt_handle 函数中</span></span><br><span class="line"><span class="comment">/* TODO 3/2: interpret the scancode */</span></span><br><span class="line">pressed = is_key_press(scancode); <span class="comment">// 此函数能判断扫描码是按下键还是释放键</span></span><br><span class="line">ch = get_ascii(scancode);  <span class="comment">// 此函数能将扫描码转换为ASCII码</span></span><br><span class="line"><span class="comment">/* TODO 3/2: display information about the keystrokes */</span></span><br><span class="line">pr_info(<span class="string">&quot;IRQ %d: scancode=0x%x (%u) pressed=%d ch=%c\n&quot;</span>,</span><br><span class="line">    irq_no, scancode, scancode, pressed, ch);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_ascii</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> scancode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *row1 = <span class="string">&quot;1234567890&quot;</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *row2 = <span class="string">&quot;qwertyuiop&quot;</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *row3 = <span class="string">&quot;asdfghjkl&quot;</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *row4 = <span class="string">&quot;zxcvbnm&quot;</span>;</span><br><span class="line"></span><br><span class="line">	scancode &amp;= ~SCANCODE_RELEASED_MASK;</span><br><span class="line">	<span class="keyword">if</span> (scancode &gt;= <span class="number">0x02</span> &amp;&amp; scancode &lt;= <span class="number">0x0b</span>)</span><br><span class="line">		<span class="keyword">return</span> *(row1 + scancode - <span class="number">0x02</span>);</span><br><span class="line">	<span class="keyword">if</span> (scancode &gt;= <span class="number">0x10</span> &amp;&amp; scancode &lt;= <span class="number">0x19</span>)</span><br><span class="line">		<span class="keyword">return</span> *(row2 + scancode - <span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">if</span> (scancode &gt;= <span class="number">0x1e</span> &amp;&amp; scancode &lt;= <span class="number">0x26</span>)</span><br><span class="line">		<span class="keyword">return</span> *(row3 + scancode - <span class="number">0x1e</span>);</span><br><span class="line">	<span class="keyword">if</span> (scancode &gt;= <span class="number">0x2c</span> &amp;&amp; scancode &lt;= <span class="number">0x32</span>)</span><br><span class="line">		<span class="keyword">return</span> *(row4 + scancode - <span class="number">0x2c</span>);</span><br><span class="line">	<span class="keyword">if</span> (scancode == <span class="number">0x39</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (scancode == <span class="number">0x1c</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_press</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> scancode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(scancode &amp; SCANCODE_RELEASED_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="将字符存储到缓冲区"><a href="#将字符存储到缓冲区" class="headerlink" title="将字符存储到缓冲区"></a>将字符存储到缓冲区</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 kbd_interrupt_handle 函数中</span></span><br><span class="line"><span class="comment">/* TODO 3/7: store ASCII key to buffer */</span></span><br><span class="line"><span class="keyword">if</span> (pressed) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kbd</span> *<span class="title">data</span> =</span> (<span class="keyword">struct</span> kbd *)dev_id; <span class="comment">// 获取设备结构体</span></span><br><span class="line">	<span class="comment">// 使用自旋锁，确保共享资源缓冲区是同步访问的，需要先在init函数中初始化</span></span><br><span class="line">    spin_lock(&amp;data-&gt;lock); </span><br><span class="line">    <span class="comment">// 读取字符，将 I/O 端口的字符读取到设备缓冲区中，以便于用户空间读取</span></span><br><span class="line">    put_char(data, ch);</span><br><span class="line">    spin_unlock(&amp;data-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 kbd_init 函数中</span></span><br><span class="line"><span class="comment">/* TODO 3: initialize spinlock */</span></span><br><span class="line">spin_lock_init(&amp;devs[<span class="number">0</span>].lock);</span><br><span class="line"><span class="comment">// put_char 函数定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_char</span><span class="params">(<span class="keyword">struct</span> kbd *data, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果缓冲区中的字符数量大于缓冲区的容量，则丢弃当前读取的字符</span></span><br><span class="line">	<span class="keyword">if</span> (data-&gt;count &gt;= BUFFER_SIZE)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// put-&gt;idx指向缓冲区下一个写入位置的索引</span></span><br><span class="line">	data-&gt;buf[data-&gt;put_idx] = c;</span><br><span class="line">    <span class="comment">// 更新索引</span></span><br><span class="line">	data-&gt;put_idx = (data-&gt;put_idx + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">	data-&gt;count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-读取缓冲区"><a href="#4-读取缓冲区" class="headerlink" title="4 读取缓冲区"></a>4 读取缓冲区</h3><blockquote>
<p>为了访问键盘记录器的数据，我们需要将其发送到用户空间。我们将使用 <em>&#x2F;dev&#x2F;kbd</em> 字符设备来实现这一点。当从该设备读取数据时，我们将从内核空间的缓冲区中获取按键数据</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 get_char() 从缓冲区中读取一个字符，并使用 put_user() 将其存储到用户缓冲区中</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">get_char</span><span class="params">(<span class="type">char</span> *c, <span class="keyword">struct</span> kbd *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* TODO 4/6: get char from buffer; update count and get_idx */</span></span><br><span class="line">	<span class="keyword">if</span> (data-&gt;count &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果缓冲区中的字符数量大于0，则读取字符</span></span><br><span class="line">		*c = data-&gt;buf[data-&gt;get_idx];</span><br><span class="line">		data-&gt;get_idx = (data-&gt;get_idx + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">		data-&gt;count--;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 kbd_read 函数中</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">kbd_read</span><span class="params">(<span class="keyword">struct</span> file *file,  <span class="type">char</span> __user *user_buffer,</span></span><br><span class="line"><span class="params">			<span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kbd</span> *<span class="title">data</span> =</span> (<span class="keyword">struct</span> kbd *) file-&gt;private_data;</span><br><span class="line">	<span class="type">size_t</span> read = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* TODO 4/18: read data from buffer */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="type">bool</span> more = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span> (size--) &#123;</span><br><span class="line">        <span class="comment">// 在读取函数中，使用 spin_lock_irqsave() 和 spin_unlock_irqrestore() 进行加锁</span></span><br><span class="line">		spin_lock_irqsave(&amp;data-&gt;lock, flags);</span><br><span class="line">		more = get_char(&amp;ch, data);</span><br><span class="line">		<span class="comment">// 原子上下文中不允许访问用户空间</span></span><br><span class="line">        spin_unlock_irqrestore(&amp;data-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">if</span> (!more)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// 关键的一句在这，使用put_user函数将字符存储到用户缓存区</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(ch, user_buffer++))  <span class="comment">// 参数是ch(字符)和user_buffer(传入的用户缓冲区)</span></span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		read++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了测试是否成功实现了从键盘这一物理设备驱动程序的中断中实现数据读取，应该先使用<code>mknod</code>创建<code>/dev/kbd</code>字符设备驱动程序，正如在<code>kbd_init</code>函数中注册字符驱动设备文件的函数 <code>register_chrdev_region</code> 中的参数一样，要使用同样的<code>KBD_MAJOR</code>和<code>MODULE_NAME</code>以及<code>KBD_MINOR</code>，也就是 <code>42</code>、<code>kbd</code>、<code>0</code>，使用命令 <code>mknod /dev/kbd c 42 0</code> 在QEMU中创建设备驱动文件kbd，构建复制和启动QEMU，加载模块后，能在<code>/proc/devices</code>中看到自己的设备文件<code>42 kbd</code>，最后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 cat /dev/kbd 读取缓冲区中的数据吧，因为 cat 是用户空间使用的命令，因此此时应该显示</span></span><br></pre></td></tr></table></figure>

<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817214906662.png" alt="image-20250817214906662" style="zoom: 80%;" />

<h3 id="5-重置缓冲区"><a href="#5-重置缓冲区" class="headerlink" title="5 重置缓冲区"></a>5 重置缓冲区</h3><blockquote>
<p>使用 <code>echo &quot;clear&quot; &gt; /dev/kbd</code> 将数据写入设备</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 reset_buffer</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">reset_buffer</span><span class="params">(<span class="keyword">struct</span> kbd *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* TODO 5/3: reset count, put_idx, get_idx */</span></span><br><span class="line">	data-&gt;count = <span class="number">0</span>;</span><br><span class="line">	data-&gt;put_idx = <span class="number">0</span>;</span><br><span class="line">	data-&gt;get_idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当写操作发生时，应该执行...</span></span><br><span class="line"><span class="comment">/* TODO 5/12: add write operation and reset the buffer */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">kbd_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *user_buffer,</span></span><br><span class="line"><span class="params">			 <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kbd</span> *<span class="title">data</span> =</span> (<span class="keyword">struct</span> kbd *) file-&gt;private_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;data-&gt;lock, flags);</span><br><span class="line">	reset_buffer(data);</span><br><span class="line">	spin_unlock_irqrestore(&amp;data-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加写操作</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">kbd_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = kbd_open,</span><br><span class="line">	.release = kbd_release,</span><br><span class="line">	.read = kbd_read,</span><br><span class="line">	<span class="comment">/* TODO 5: add write operation */</span></span><br><span class="line">	.write = kbd_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时执行命令 <code>echo &quot;clear&quot; &gt; /dev/kbd</code> 会让缓冲区清空</p>
<img src="https://leeway2zcblog-1373523181.cos.ap-guangzhou.myqcloud.com/img/image-20250817215433645.png" alt="image-20250817215433645" style="zoom:80%;" />

</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2025/08/12/FIO-%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/" title="FIO 测试学习文档" class="prev">PREV</a><a href="/2025/08/10/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%95%99%E7%A8%8B/" title="上传博客的教程" class="next">NEXT</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz",
    appKey: "FdzS5SOPHdhYQoEUngQ8K2QW",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2016 - 2025 <a target="_blank">David Lee</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p><span id="busuanzi_container_site_pv">本站总访问数：<span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv" style="padding-left: 6px;">访客数：<span id="busuanzi_value_site_uv"></span></span></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>